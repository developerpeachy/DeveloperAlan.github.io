/**
 * Created with JetBrains WebStorm.
 * User: Erran
 * Date: 3/29/13
 * Time: 7:02 PM
 * To change this template use File | Settings | File Templates.
 */

          /*
// header / description information:
var columnHeaderArray = [];  // the index corresponds to a name (the header)
var headerDisplayOrderIdxs = [];  // has the headers in the order from the display marker

// group stuff
var groupHash = {};  // maps group names to index values in the lines/ array for Markers
var sortedGroupKeys = [];  // the keys of the above array in sorted order!
var groupImageHash = {};  // maps the group name to the image value (location).


var dataLines = [];   // the data for each line, minus the header, post split (this is an array that contains arrays)

var groupImageHash = {};  // maps the group name to the image value (location).

// filter stuff
var filterListNames = [];  // contains the names of the filters
var filterListArray = [];  //  the value is a hash with the names
var filterListSortedKeyHash = {};  // the key is the filter name,
// the value is a list of keys (the key into the values for the filterListArray



var selectedMapType = 'Street';
                   */


var myMapOptions = ['Street', 'Terrain', 'Satellite', 'Hybrid'];

var GOOGLE_MAPS_VERSION = "";

var MAX_PINS = 20000;
var MAX_FREE_GEO = 250;

var MAX_GROUPS = 10;
var MAX_FILTERS = 4;
var MAX_FILTER_SIZE = 200;

// use this for the kml
var BASE_IMAGE_URL = 'http://images.easymapmaker.com';

var IMAGE_PATH = '/marker_images/';
var IMG_LIST = ["red", "blue", "green", "yellow", "orange", "purple", "brown", "pink", "dark_green", "pale_blue", "dark_pink"];

var IMG_FILE_ENDING = "_Marker.png";
var IMG_HEX_COLORS = ["FF776B", "6B98FF", "97EC7D", "FFED5C", "FD8D08", "C89BFF", "CB9D7C", "FDABFF", "01BF00", "BCE3FF", "E14F9E"];

var DOT_IMAGE = "dot_";

var SMALL_IMAGE= "small_";

var DEFAULT_SHADOW = "shadow.png";

var DEFAULT_SHAPE = {
    coord: [13,0,15,1,16,2,17,3,18,4,18,5,19,6,19,7,19,8,19,9,19,10,19,11,19,12,19,13,18,14,18,15,17,16,16,17,15,18,14,19,14,20,13,21,13,22,12,23,12,24,12,25,12,26,11,27,11,28,11,29,11,30,11,31,11,32,11,33,8,33,8,32,8,31,8,30,8,29,8,28,8,27,8,26,7,25,7,24,7,23,6,22,6,21,5,20,5,19,4,18,3,17,2,16,1,15,1,14,0,13,0,12,0,11,0,10,0,9,0,8,0,7,0,6,1,5,1,4,2,3,3,2,4,1,6,0,13,0],
    type: 'poly'
};

// default  image stuff:
var DEFAULT_IMG_SIZE = [20,34];
var DEFAULT_IMG_ORIGIN = [0,0]        ;
var DEFAULT_IMG_ANCHOR = [10,34];


// default  shadow image stuff:
var DEFAULT_IMG_SIZE = [40,34];
var DEFAULT_IMG_ORIGIN = [0,0]        ;
var DEFAULT_IMG_ANCHOR = [10,34];


var ALL_FILTER = "All";


// used to store the selected filter keys.  The array is in parallel with the filter names array, the value is the item 'filter name' selected
// from the drop down.
var selectedFilterValues = [];




// don't filter on any of the above, except for group!

// maps  the select box name to the index value in the header.
//var selected_columns = {};

var userSettings = {};
 userSettings.email = null;
 userSettings.title = null;
 userSettings.description = null;
 userSettings.protectionLevel = null;
 userSettings.alias = null;
 userSettings.view_count = null;
 userSettings.name = null;
 userSettings.autoDelete = null;
 userSettings.dataOnPage = null;
 userSettings.genKML = null;
 //userSettings.mayType = 'basic';               // basic and advanced for now

var mObject = {};
mObject.address = null;
mObject.city = null;
mObject.state = null;
mObject.zip = null;
mObject.country = null;
mObject.lat = null;
mObject.lng = null;
mObject.title = null;
mObject.web = null;
mObject.image = null;
mObject.email = null;
mObject.group = null;
mObject.mapType = null; // valid values are 'baisc', 'advanced'
//mObject.pin = null;   // the pin (icon is disabled for now)

mObject.regionCode = "";
mObject.regionCountry = "Auto-Detect";
mObject.showLabels = true;

// results from geo_coding, the location in the data-line columns; -1 means not present
mObject.emm_lat = -1;
mObject.emm_lng = -1;
mObject.emm_acc = -1;
//mObject.emm__other = -1;

mObject.selectedMapType = 'Street';

// true if the data should be displayed below the map on the page.
mObject.displayDataOnPage = false;
mObject.clustering = true;

// new as of 10/28/2013
mObject.showMoreOptions = null;
mObject.disAbleDynamicFilters = null;

// use the scrollwheel
mObject.scrollWheel = false;

// header / description information:
mObject.columnHeaderArray = [];    // the index corresponds to a name (the header)
mObject.headerDisplayOrderIdxs = [];  // has the headers in the order from the display marker
mObject.groupHash = {};  // maps group names to index values in the lines/ array for Markers
mObject.sortedGroupKeys = [];  // the keys of the above array in sorted order!
mObject.groupImageHash = {};  // maps the group name to the image value (location).


// filter stuff
mObject.filterListNames = [];  // contains the names of the filters
mObject.filterListArray = [];  //  the value is a hash with the names
mObject.filterListSortedKeyHash = {};  // the key is the filter name,
mObject.filterColumnIdxs = [];
// the value is a list of keys (the key into the values for the filterListArray


// the marker index maps to an image color index (in the IMG_LIST)
mObject.markerImageIdx = [];

/*
 var labelNames = ["Address", "City", "Zip Code", "State / Province", "Country", "Latitude", "Longitude",
 "Marker Title", "Url (website)", "(website) Image", "(website) E-mail", "Group", "(Marker) Icon/Pin"
 ];

 */

//JSON.stringify(mObject)    ;

// return true if i is one of the selected items other than the group or pin
function isIgnoreSearchColumn(i) {
    return (i== mObject.lat || i == mObject.lng ||
        i == mObject.web ||
        i == mObject.image )    ;
}

// return true if i is one of the selected items other than the group or pin
function isSelectedColumn(i) {
    return (i== mObject.lat || i == mObject.lng ||
        i == mObject.address ||
        i == mObject.city || i == mObject.state || i == mObject.zip ||
        i == mObject.country || i ==  mObject.title || i == mObject.web ||
        i == mObject.image || i == mObject.email)    ;
}

function urlizeUrl(s) {

    if (s.length > 0 && !s.match(/^(https?|ftp):\/\//))
        return 'http://' + s;

    return s;
}/* ==========================================================
 * bootstrap-alert.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#alerts
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* ALERT CLASS DEFINITION
     * ====================== */

    var dismiss = '[data-dismiss="alert"]'
        , Alert = function (el) {
            $(el).on('click', dismiss, this.close)
        }

    Alert.prototype.close = function (e) {
        var $this = $(this)
            , selector = $this.attr('data-target')
            , $parent

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
        }

        $parent = $(selector)

        e && e.preventDefault()

        $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

        $parent.trigger(e = $.Event('close'))

        if (e.isDefaultPrevented()) return

        $parent.removeClass('in')

        function removeElement() {
            $parent
                .trigger('closed')
                .remove()
        }

        $.support.transition && $parent.hasClass('fade') ?
            $parent.on($.support.transition.end, removeElement) :
            removeElement()
    }


    /* ALERT PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.alert

    $.fn.alert = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('alert')
            if (!data) $this.data('alert', (data = new Alert(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    $.fn.alert.Constructor = Alert


    /* ALERT NO CONFLICT
     * ================= */

    $.fn.alert.noConflict = function () {
        $.fn.alert = old
        return this
    }


    /* ALERT DATA-API
     * ============== */

    $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)

}(window.jQuery);


/* =========================================================
 * bootstrap-modal.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (element, options) {
    this.options = options
    this.$element = $(element)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.escape()

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element.show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element
            .addClass('in')
            .attr('aria-hidden', false)

          that.enforceFocus()

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
            that.$element.focus().trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.escape()

        $(document).off('focusin.modal')

        this.$element
          .removeClass('in')
          .attr('aria-hidden', true)

        $.support.transition && this.$element.hasClass('fade') ?
          this.hideWithTransition() :
          this.hideModal()
      }

    , enforceFocus: function () {
        var that = this
        $(document).on('focusin.modal', function (e) {
          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
            that.$element.focus()
          }
        })
      }

    , escape: function () {
        var that = this
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keyup.dismiss.modal', function ( e ) {
            e.which == 27 && that.hide()
          })
        } else if (!this.isShown) {
          this.$element.off('keyup.dismiss.modal')
        }
      }

    , hideWithTransition: function () {
        var that = this
          , timeout = setTimeout(function () {
              that.$element.off($.support.transition.end)
              that.hideModal()
            }, 500)

        this.$element.one($.support.transition.end, function () {
          clearTimeout(timeout)
          that.hideModal()
        })
      }

    , hideModal: function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
          that.removeBackdrop()
          that.$element.trigger('hidden')
        })
      }

    , removeBackdrop: function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
      }

    , backdrop: function (callback) {
        var that = this
          , animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate

          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
            .appendTo(document.body)

          this.$backdrop.click(
            this.options.backdrop == 'static' ?
              $.proxy(this.$element[0].focus, this.$element[0])
            : $.proxy(this.hide, this)
          )

          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

          this.$backdrop.addClass('in')

          if (!callback) return

          doAnimate ?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')

          $.support.transition && this.$element.hasClass('fade')?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (callback) {
          callback()
        }
      }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.modal

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL NO CONFLICT
  * ================= */

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


 /* MODAL DATA-API
  * ============== */

  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this)
      , href = $this.attr('href')
      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option)
      .one('hide', function () {
        $this.focus()
      })
  })

}(window.jQuery);
/* ===========================================================
 * bootstrap-tooltip.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);




/* ============================================================
 * bootstrap-button.js v2.3.1
 * http://twitter.github.com/bootstrap/javascript.html#buttons
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* BUTTON PUBLIC CLASS DEFINITION
     * ============================== */

    var Button = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, $.fn.button.defaults, options)
    }

    Button.prototype.setState = function (state) {
        var d = 'disabled'
            , $el = this.$element
            , data = $el.data()
            , val = $el.is('input') ? 'val' : 'html'

        state = state + 'Text'
        data.resetText || $el.data('resetText', $el[val]())

        $el[val](data[state] || this.options[state])

        // push to event loop to allow forms to submit
        setTimeout(function () {
            state == 'loadingText' ?
                $el.addClass(d).attr(d, d) :
                $el.removeClass(d).removeAttr(d)
        }, 0)
    }

    Button.prototype.toggle = function () {
        var $parent = this.$element.closest('[data-toggle="buttons-radio"]')

        $parent && $parent
            .find('.active')
            .removeClass('active')

        this.$element.toggleClass('active')
    }


    /* BUTTON PLUGIN DEFINITION
     * ======================== */

    var old = $.fn.button

    $.fn.button = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('button')
                , options = typeof option == 'object' && option
            if (!data) $this.data('button', (data = new Button(this, options)))
            if (option == 'toggle') data.toggle()
            else if (option) data.setState(option)
        })
    }

    $.fn.button.defaults = {
        loadingText: 'loading...'
    }

    $.fn.button.Constructor = Button


    /* BUTTON NO CONFLICT
     * ================== */

    $.fn.button.noConflict = function () {
        $.fn.button = old
        return this
    }


    /* BUTTON DATA-API
     * =============== */

    $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
        var $btn = $(e.target)
        if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
        $btn.button('toggle')
    })

}(window.jQuery);
/*
    json2.js
    2012-10-08

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
/*jslint browser: true, confusion: true, sloppy: true, vars: true, nomen: false, plusplus: false, indent: 2 */
/*global window,google */

/**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.0.15 [October 18, 2012]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>printable</code>,
 *  <code>batchSizeIE</code>, and <code>calculator</code> properties as well as support for
 *  four more events. It also allows greater control over the styling of the text that appears
 *  on the cluster marker. The documentation has been significantly improved and the overall
 *  code has been simplified and polished. Very large numbers of markers can now be managed
 *  without causing Javascript timeout errors on Internet Explorer. Note that the name of the
 *  <code>clusterclick</code> event has been deprecated. The new name is <code>click</code>,
 *  so please change your application code now.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The height (in pixels) of the cluster icon. Required.
 * @property {number} width The width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchor] The anchor position (in pixels) of the label text to be shown on
 *  the cluster icon, relative to the top left corner of the icon.
 *  The format is <code>[yoffset, xoffset]</code>. The <code>yoffset</code> must be positive
 *  and less than <code>height</code> and the <code>xoffset</code> must be positive and less
 *  than <code>width</code>. The default is to anchor the label text so that it is centered
 *  on the icon.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right. The default anchor position is the center of the
 *  cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {number} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images.
 */
/**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
/**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
function ClusterIcon(cluster, styles) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.cluster_ = cluster;
  this.className_ = cluster.getMarkerClusterer().getClusterClass();
  this.styles_ = styles;
  this.center_ = null;
  this.div_ = null;
    this.shadowDiv_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called
}


/**
 * Adds the icon to the DOM.
 */
ClusterIcon.prototype.onAdd = function () {
  var cClusterIcon = this;
  var cMouseDownInCluster;
  var cDraggingMapByCluster;

  this.div_ = document.createElement("div");
  this.shadowDiv_ = document.createElement("div");
  this.div_.className = this.className_;
    this.shadowDiv_.className = this.className_;
    if (this.visible_) {
    this.show();
  }

  this.getPanes().overlayMouseTarget.appendChild(this.div_);
    this.getPanes().overlayMouseTarget.appendChild(this.shadowDiv_);

  // Fix for Issue 157
  google.maps.event.addListener(this.getMap(), "bounds_changed", function () {
    cDraggingMapByCluster = cMouseDownInCluster;
  });

  google.maps.event.addDomListener(this.div_, "mousedown", function () {
    cMouseDownInCluster = true;
    cDraggingMapByCluster = false;
  });

  google.maps.event.addDomListener(this.div_, "click", function (e) {
    cMouseDownInCluster = false;
    if (!cDraggingMapByCluster) {
      var theBounds;
      var mz;
      var mc = cClusterIcon.cluster_.getMarkerClusterer();
      /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
      google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
      google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_); // deprecated name

      // The default click handler follows. Disable it by setting
      // the zoomOnClick property to false.
      if (mc.getZoomOnClick()) {
        // Zoom into the cluster.
        mz = mc.getMaxZoom();
        theBounds = cClusterIcon.cluster_.getBounds();
        mc.getMap().fitBounds(theBounds);
        // There is a fix for Issue 170 here:
        setTimeout(function () {
          mc.getMap().fitBounds(theBounds);
          // Don't zoom beyond the max zoom level
          if (mz !== null && (mc.getMap().getZoom() > mz)) {
            mc.getMap().setZoom(mz + 1);
          }
        }, 100);
      }

      // Prevent event propagation to the map:
      e.cancelBubble = true;
      if (e.stopPropagation) {
        e.stopPropagation();
      }
    }
  });

  google.maps.event.addDomListener(this.div_, "mouseover", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
    google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
  });

  google.maps.event.addDomListener(this.div_, "mouseout", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
    google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
  });
};


/**
 * Removes the icon from the DOM.
 */
ClusterIcon.prototype.onRemove = function () {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    google.maps.event.clearInstanceListeners(this.div_);
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;


      if(this.shadowDiv_ && this.shadowDiv_.parentNode) {
          this.shadowDiv_.parentNode.removeChild(this.shadowDiv_);
          this.shadowDiv_ = null;
      }

  }
};


/**
 * Draws the icon.
 */
ClusterIcon.prototype.draw = function () {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + "px";
    this.div_.style.left = pos.x + "px";

      var pos = this.getPosFromLatLng_(this.center_);
      this.shadowDiv_.style.top = pos.y + "px";
      this.shadowDiv_.style.left = pos.x + "px";

  }
};


/**
 * Hides the icon.
 */
ClusterIcon.prototype.hide = function () {
  if (this.div_) {
    this.div_.style.display = "none";
  }
    if (this.shadowDiv_) {
        this.shadowDiv_.style.display = "none";
    }

  this.visible_ = false;
};


/**
 * Positions and shows the icon.
 */
ClusterIcon.prototype.show = function () {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    if (this.cluster_.printable_) {
      // (Would like to use "width: inherit;" below, but doesn't work with MSIE)
      this.div_.innerHTML = "<img src='" + this.url_ + "'><div style='position: absolute; top: 0px; left: 0px; width: " + this.width_ + "px;'>" + this.sums_.text + "</div>";
    } else {
      this.div_.innerHTML = this.sums_.text;
    }
    if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
    } else {
      this.div_.title = this.sums_.title;
    }
    this.div_.style.display = "";

      if(this.shadowDiv_) {

          this.shadowDiv_.style.cssText = this.createCssShadow(pos);
          this.shadowDiv_.style.display = "";

      }
  }
  this.visible_ = true;
};


/**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
ClusterIcon.prototype.useStyle = function (sums) {
  this.sums_ = sums;
  var index = Math.max(0, sums.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style.url;
  this.shadow_ = style.shadow;
  this.height_ = style.height;
  this.width_ = style.width;
  this.anchor_ = style.anchor;
  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
  this.textColor_ = style.textColor || "black";
  this.textSize_ = style.textSize || 11;
  this.textDecoration_ = style.textDecoration || "none";
  this.fontWeight_ = style.fontWeight || "bold";
  this.fontStyle_ = style.fontStyle || "normal";
  this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
  this.backgroundPosition_ = style.backgroundPosition || "0 0";
};



ClusterIcon.prototype.updateUrl = function (markers) {

    var uniqueMarkerColors = {};

    if (markers.length < 2)
        return;

    // data is separated by a ','; the colors are separated by a '|'

    var uniqueColorCount = 0;

    for (i = 0; i < markers.length; i++) {


        if (uniqueMarkerColors.hasOwnProperty(markers[i].hexColor)) {
            uniqueMarkerColors[markers[i].hexColor] = uniqueMarkerColors[markers[i].hexColor] + 1;
        } else {
            uniqueMarkerColors[markers[i].hexColor] = 1;
            uniqueColorCount++;
        }
    }

    var colorList = "";
    var countList = "";

    for (var color in uniqueMarkerColors) {

        if (colorList.length > 0)
            colorList = colorList + "|" + color;
        else
            colorList = color;

        if (countList.length > 0)
            countList = countList + "," + uniqueMarkerColors[color].toString();
        else
            countList = uniqueMarkerColors[color].toString();
    }

    // this.height_ = parseInt(this.height_ * 1.4);
    // this.width_ = parseInt(this.width_ * 1.4);

    if(uniqueColorCount == 1) {

           this.url_ = this.url_.replace("color_", markers[0].color)     ;
    }

    else {

        var heightIdx =       MarkerClusterer.IMAGE_SIZES.indexOf(this.height_) ;
        this.height_ =      MarkerClusterer.CHART_IMAGE_SIZES[heightIdx];
        this.width_ =      MarkerClusterer.CHART_IMAGE_SIZES[heightIdx];

        this.shadow_ = MarkerClusterer.CHART_SHADOW_PATH + "/" + this.width_.toString() +  MarkerClusterer.CHART_SHADOW;

        this.url_ = "//chart.googleapis.com/chart?cht=p&chs=" + this.height_.toString() + "x" + this.width_.toString() +

            "&chd=t:" + countList + "&chco=" + colorList + "&chf=a,s,000000|bg,s,67676700";
    }
    //  console.debug("url: " + this.height_);

}


/**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function (center) {
  this.center_ = center;
};


/**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
ClusterIcon.prototype.createCss = function (pos) {
  var style = [];
  if (!this.cluster_.printable_) {
    style.push('background-image:url(' + this.url_ + ');');
    style.push('background-position:' + this.backgroundPosition_ + ';');
  }

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + this.textColor_ + '; position:absolute; font-size:' +
      this.textSize_ + 'px; font-family:' + this.fontFamily_ + '; font-weight:' +
      this.fontWeight_ + '; font-style:' + this.fontStyle_ + '; text-decoration:' +
      this.textDecoration_ + ';');

  return style.join("");
};

ClusterIcon.prototype.createCssShadow = function (pos) {
    var style = [];
    if (!this.cluster_.printable_) {
        style.push('background-image:url(' + this.shadow_ + ');');
        style.push('background-position: -4px -4px;');
    }


  /*  if (typeof this.anchor_ === 'object') {
        if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
            this.anchor_[0] < this.height_) {
            style.push('height:' + (this.height_ - this.anchor_[0]) +
                'px; padding-top:' + this.anchor_[0] + 'px;');
        } else {
            style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
                'px;');
        }
        if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
            this.anchor_[1] < this.width_) {
            style.push('width:' + (this.width_ - this.anchor_[1]) +
                'px; padding-left:' + this.anchor_[1] + 'px;');
        } else {
            style.push('width:' + this.width_ + 'px; text-align:center;');
        }
    } else {
        style.push('height:' + this.height_ + 'px; line-height:' +
            this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
    }  */

    style.push('height:' + this.height_ + 'px; width:' + (this.width_ * 1.54).toString() + 'px;');

    style.push('z-index: -1; position: absolute; top:' + pos.y + 'px; left:' +
        pos.x + 'px; ');

    return style.join("");
}

/**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
ClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= this.anchorIcon_[1];
  pos.y -= this.anchorIcon_[0];
  return pos;
};


/**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
function Cluster(mc) {
  this.markerClusterer_ = mc;
  this.map_ = mc.getMap();
  this.gridSize_ = mc.getGridSize();
  this.minClusterSize_ = mc.getMinimumClusterSize();
  this.averageCenter_ = mc.getAverageCenter();
  this.printable_ = mc.getPrintable();
  this.markers_ = [];
  this.center_ = null;
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
}


/**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function () {
  return this.markers_.length;
};


/**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
Cluster.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
Cluster.prototype.getCenter = function () {
  return this.center_;
};


/**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
Cluster.prototype.getMap = function () {
  return this.map_;
};


/**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
Cluster.prototype.getMarkerClusterer = function () {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
Cluster.prototype.getBounds = function () {
  var i;
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster from the map.
 *
 * @ignore
 */
Cluster.prototype.remove = function () {
  this.clusterIcon_.setMap(null);
  this.markers_ = [];
  delete this.markers_;
};


/**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
Cluster.prototype.addMarker = function (marker) {
  var i;
  var mCount;
  var mz;

  if (this.isMarkerAlreadyAdded_(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  mCount = this.markers_.length;
  mz = this.markerClusterer_.getMaxZoom();
  if (mz !== null && this.map_.getZoom() > mz) {
    // Zoomed in past max zoom, so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount < this.minClusterSize_) {
    // Min cluster size not reached so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount === this.minClusterSize_) {
    // Hide the markers that were showing.
    for (i = 0; i < mCount; i++) {
      this.markers_[i].setMap(null);
    }
  } else {
    marker.setMap(null);
  }

  this.updateIcon_();
  return true;
};


/**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
Cluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Calculates the extended bounds of the cluster with the grid.
 */
Cluster.prototype.calculateBounds_ = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Updates the cluster icon.
 */
Cluster.prototype.updateIcon_ = function () {
  var mCount = this.markers_.length;
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz !== null && this.map_.getZoom() > mz) {
    this.clusterIcon_.hide();
    return;
  }

  if (mCount < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.useStyle(sums);

  // use the chart url (if appropriate)
  this.clusterIcon_.updateUrl(this.markers_);

  this.clusterIcon_.show();
};




/**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
Cluster.prototype.isMarkerAlreadyAdded_ = function (marker) {
  var i;
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) !== -1;
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        return true;
      }
    }
  }
  return false;
};


/**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {boolean} [printable=false] Whether to make the cluster icons printable. Do not
 *  set to <code>true</code> if the <code>url</code> fields in the <code>styles</code> array
 *  refer to image sprite files.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR]
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
/**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);

  opt_markers = opt_markers || [];
  opt_options = opt_options || {};

  this.markers_ = [];
  this.clusters_ = [];
  this.listeners_ = [];
  this.activeMap_ = null;
  this.ready_ = false;

  this.gridSize_ = opt_options.gridSize || 60;
  this.minClusterSize_ = opt_options.minimumClusterSize || 2;
  this.maxZoom_ = opt_options.maxZoom || null;
  this.styles_ = opt_options.styles || [];
  this.title_ = opt_options.title || "";
  this.zoomOnClick_ = true;
  if (opt_options.zoomOnClick !== undefined) {
    this.zoomOnClick_ = opt_options.zoomOnClick;
  }
  this.averageCenter_ = false;
  if (opt_options.averageCenter !== undefined) {
    this.averageCenter_ = opt_options.averageCenter;
  }
  this.ignoreHidden_ = false;
  if (opt_options.ignoreHidden !== undefined) {
    this.ignoreHidden_ = opt_options.ignoreHidden;
  }
  this.printable_ = false;
  if (opt_options.printable !== undefined) {
    this.printable_ = opt_options.printable;
  }
  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
  this.clusterClass_ = opt_options.clusterClass || "cluster";

  if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
    // Try to avoid IE timeout when processing a huge number of markers:
    this.batchSize_ = this.batchSizeIE_;
  }

  this.setupStyles_();

  this.addMarkers(opt_markers, true);
  this.setMap(map); // Note: this causes onAdd to be called
}


/**
 * Implementation of the onAdd interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function () {
  var cMarkerClusterer = this;

  this.activeMap_ = this.getMap();
  this.ready_ = true;

  this.repaint();

  // Add the map event listeners
  this.listeners_ = [
    google.maps.event.addListener(this.getMap(), "zoom_changed", function () {
      cMarkerClusterer.resetViewport_(false);
      // Workaround for this Google bug: when map is at level 0 and "-" of
      // zoom slider is clicked, a "zoom_changed" event is fired even though
      // the map doesn't zoom out any further. In this situation, no "idle"
      // event is triggered so the cluster markers that have been removed
      // do not get redrawn. Same goes for a zoom in at maxZoom.
      if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
       //   console.debug("triggering idle call from marker cluster-er");
        google.maps.event.trigger(this, "idle");
      }
    }),
    google.maps.event.addListener(this.getMap(), "idle", function () {
      //  console.debug("idle called from marker cluster-er");
      cMarkerClusterer.redraw_();
    })
  ];
};


/**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
MarkerClusterer.prototype.onRemove = function () {
  var i;

  // Put all the managed markers back on the map:
  for (i = 0; i < this.markers_.length; i++) {
    if (this.markers_[i].getMap() !== this.activeMap_) {
      this.markers_[i].setMap(this.activeMap_);
    }
  }

  // Remove all clusters:
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Remove map event listeners:
  for (i = 0; i < this.listeners_.length; i++) {
    google.maps.event.removeListener(this.listeners_[i]);
  }
  this.listeners_ = [];

  this.activeMap_ = null;
  this.ready_ = false;
};


/**
 * Implementation of the draw interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function () {};


/**
 * Sets up the styles object.
 */
MarkerClusterer.prototype.setupStyles_ = function () {
  var i, size;
  if (this.styles_.length > 0) {
    return;
  }

  for (i = 0; i < this.imageSizes_.length; i++) {
    size = this.imageSizes_[i];
    this.styles_.push({
      url: this.imagePath_ + "/" + ((i * 5) + 35) + "_color_." + this.imageExtension_,
      shadow: this.imagePath_ + "/" + ((i * 5) + 35) + "_shadow." + this.imageExtension_,
      height: size,
      width: size
    });
  }
};


/**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function () {
  var i;
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }

  this.getMap().fitBounds(bounds);
};


/**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function () {
  return this.gridSize_;
};


/**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
MarkerClusterer.prototype.setGridSize = function (gridSize) {
  this.gridSize_ = gridSize;
};


/**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
MarkerClusterer.prototype.getMinimumClusterSize = function () {
  return this.minClusterSize_;
};

/**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
MarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {
  this.minClusterSize_ = minimumClusterSize;
};


/**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function () {
  return this.maxZoom_;
};


/**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function (maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
MarkerClusterer.prototype.getStyles = function () {
  return this.styles_;
};


/**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
MarkerClusterer.prototype.setStyles = function (styles) {
  this.styles_ = styles;
};


/**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
MarkerClusterer.prototype.getTitle = function () {
  return this.title_;
};


/**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
MarkerClusterer.prototype.setTitle = function (title) {
  this.title_ = title;
};


/**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
MarkerClusterer.prototype.getZoomOnClick = function () {
  return this.zoomOnClick_;
};


/**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
MarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {
  this.zoomOnClick_ = zoomOnClick;
};


/**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
MarkerClusterer.prototype.getAverageCenter = function () {
  return this.averageCenter_;
};


/**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
MarkerClusterer.prototype.setAverageCenter = function (averageCenter) {
  this.averageCenter_ = averageCenter;
};


/**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
MarkerClusterer.prototype.getIgnoreHidden = function () {
  return this.ignoreHidden_;
};


/**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
MarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {
  this.ignoreHidden_ = ignoreHidden;
};


/**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
MarkerClusterer.prototype.getImageExtension = function () {
  return this.imageExtension_;
};


/**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
MarkerClusterer.prototype.setImageExtension = function (imageExtension) {
  this.imageExtension_ = imageExtension;
};


/**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
MarkerClusterer.prototype.getImagePath = function () {
  return this.imagePath_;
};


/**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
MarkerClusterer.prototype.setImagePath = function (imagePath) {
  this.imagePath_ = imagePath;
};


/**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
MarkerClusterer.prototype.getImageSizes = function () {
  return this.imageSizes_;
};


/**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
MarkerClusterer.prototype.setImageSizes = function (imageSizes) {
  this.imageSizes_ = imageSizes;
};


/**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
MarkerClusterer.prototype.getCalculator = function () {
  return this.calculator_;
};


/**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
MarkerClusterer.prototype.setCalculator = function (calculator) {
  this.calculator_ = calculator;
};


/**
 * Returns the value of the <code>printable</code> property.
 *
 * @return {boolean} the value of the printable property.
 */
MarkerClusterer.prototype.getPrintable = function () {
  return this.printable_;
};


/**
 * Sets the value of the <code>printable</code> property.
 *
 *  @param {boolean} printable The value of the printable property.
 */
MarkerClusterer.prototype.setPrintable = function (printable) {
  this.printable_ = printable;
};


/**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
MarkerClusterer.prototype.getBatchSizeIE = function () {
  return this.batchSizeIE_;
};


/**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
MarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {
  this.batchSizeIE_ = batchSizeIE;
};


/**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
MarkerClusterer.prototype.getClusterClass = function () {
  return this.clusterClass_;
};


/**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
MarkerClusterer.prototype.setClusterClass = function (clusterClass) {
  this.clusterClass_ = clusterClass;
};


/**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
MarkerClusterer.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function () {
  return this.markers_.length;
};


/**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getClusters = function () {
  return this.clusters_;
};


/**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getTotalClusters = function () {
  return this.clusters_.length;
};


/**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {
  var i;
  for (i = 0; i < markers.length; i++) {
    this.pushMarkerTo_(markers[i]);
  }
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.pushMarkerTo_ = function (marker) {
  // If the marker is draggable add a listener so we can update the clusters on the dragend:
  if (marker.getDraggable()) {
    var cMarkerClusterer = this;
    google.maps.event.addListener(marker, "dragend", function () {
      if (cMarkerClusterer.ready_) {
        this.isAdded = false;
        cMarkerClusterer.repaint();
      }
    });
  }
  marker.isAdded = false;
  this.markers_.push(marker);
};


/**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {
  var i, r;
  var removed = false;

  for (i = 0; i < markers.length; i++) {
    r = this.removeMarker_(markers[i]);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
MarkerClusterer.prototype.removeMarker_ = function (marker) {
  var i;
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        index = i;
        break;
      }
    }
  }

  if (index === -1) {
    // Marker is not in our list of markers, so do nothing:
    return false;
  }

  marker.setMap(null);
  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers
  return true;
};


/**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function () {
  this.resetViewport_(true);
  this.markers_ = [];
};


/**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
MarkerClusterer.prototype.repaint = function () {
  var oldClusters = this.clusters_.slice();
  this.clusters_ = [];
  this.resetViewport_(false);
  this.redraw_();

  // Remove the old clusters.
  // Do it in a timeout to prevent blinking effect.
  setTimeout(function () {
    var i;
    for (i = 0; i < oldClusters.length; i++) {
      oldClusters[i].remove();
    }
  }, 0);
};


/**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
MarkerClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Redraws all the clusters.
 */
MarkerClusterer.prototype.redraw_ = function () {
  this.createClusters_(0);
};


/**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
MarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
  var i, marker;
  // Remove all the clusters
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Reset the markers to not be added and to be removed from the map.
  for (i = 0; i < this.markers_.length; i++) {
    marker = this.markers_[i];
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }
};


/**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {
  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
  var i, d, cluster, center;
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  for (i = 0; i < this.clusters_.length; i++) {
    cluster = this.clusters_[i];
    center = cluster.getCenter();
    if (center) {
      d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
MarkerClusterer.prototype.createClusters_ = function (iFirst) {
  var i, marker;
  var mapBounds;
  var cMarkerClusterer = this;
  if (!this.ready_) {
    return;
  }

  // Cancel previous batch processing if we're working on the first batch:
  if (iFirst === 0) {
    /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringbegin", this);

    if (typeof this.timerRefStatic !== "undefined") {
      clearTimeout(this.timerRefStatic);
      delete this.timerRefStatic;
    }
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  //
  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
  if (this.getMap().getZoom() > 3) {
    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
      this.getMap().getBounds().getNorthEast());
  } else {
    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
  }
  var bounds = this.getExtendedBounds(mapBounds);

  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);

  for (i = iFirst; i < iLast; i++) {
    marker = this.markers_[i];
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
        this.addToClosestCluster_(marker);
      }
    }
  }

  if (iLast < this.markers_.length) {
    this.timerRefStatic = setTimeout(function () {
      cMarkerClusterer.createClusters_(iLast);
    }, 0);
  } else {
    delete this.timerRefStatic;

    /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringend", this);
  }
};


/**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function (obj1, obj2) {
  return (function (object) {
    var property;
    for (property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
MarkerClusterer.CALCULATOR = function (markers, numStyles) {
  var index = 0;
  var title = "";
  var count = markers.length.toString();

  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index,
    title: title
  };
};


/**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE = 2000;


/**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE_IE = 500;


/**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
//MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";


/**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_EXTENSION = "png";


/**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
//MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

MarkerClusterer.IMAGE_PATH = "/cluster_images/solid";
MarkerClusterer.IMAGE_SIZES = [35, 40,45, 50,55, 60, 65 ]; //, 70, 75, 80, 85, 90, 95];
MarkerClusterer.CHART_IMAGE_SIZES = [50,55, 60, 65, 70, 73, 75 ]; //, 80, 85, 90, 95, 100, 105];

MarkerClusterer.CHART_SHADOW_PATH = "/cluster_images/chart";
MarkerClusterer.CHART_SHADOW = "_shadow.png"
// setup the click controls for moving from the multi-select fro the
// description.

// for IE-8
if (!window.console) console = {debug: function(str) {}};

// TODO: comment out the below for non-IE testing (and prod)
var console=console||{"debug":function(){}};


// for IE-8
// add trim where it does not exist, mainly IE 8 and below.
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g,'');
    }
}

    // for IE-8
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(obj, start) {
        for (var i = (start || 0), j = this.length; i < j; i++) {
            if (this[i] === obj) { return i; }
        }
        return -1;
    }
}


function fUNQ24() {

    var noDisplayElement = document.getElementById('noDisplay');
    var toDisplayElement = document.getElementById('toDisplay');

    jQuery('#moveToDisplay').click(function () {



        $('#noDisplay option:selected').each(function () {
            $('#toDisplay').append($(this).clone(true));
            $(this).remove();
        });

        fUNQ25(toDisplayElement)  ;

        fUNQ27();

        //     jQuery('#moveToDisplay').attr("disabled", "disabled");
    });

    jQuery('#removeFromDisplay').click(function () {


        $('#toDisplay option:selected').each(function () {
            $('#noDisplay').append($(this).clone(true));
            $(this).remove();
        });

        fUNQ25(noDisplayElement)  ;

        fUNQ27();
        //     jQuery('#moveToDisplay').removeAttr("disabled");
    });

    jQuery('#moveAllToDisplay').click(function () {


        $('#noDisplay option').each(function () {
            $('#toDisplay').append($(this).clone(true));
            $(this).remove();
        });
        fUNQ25(toDisplayElement)  ;
        fUNQ27();

    });

    jQuery('#removeAllFromDisplay').click(function () {


        $('#toDisplay option').each(function () {
            $('#noDisplay').append($(this).clone(true));
            $(this).remove();
        });
        fUNQ25(noDisplayElement)  ;
        fUNQ27();
    });


}

function fUNQ25(selElem) {
    var tmpAry = [], i;
    for ( i=0;i<selElem.options.length;i++) {
        tmpAry[i] = [];
        tmpAry[i][0] = selElem.options[i].text;
        tmpAry[i][1] = selElem.options[i].value;
    }
   // tmpAry.sort()

    tmpAry.sort(function (a, b) {

        return a[1] - b[1] ;
    });

    while (selElem.options.length > 0) {
        selElem.options[0] = null;
    }
    for ( i=0;i<tmpAry.length;i++) {
        selElem.options[i] = new Option(tmpAry[i][0], tmpAry[i][1]);
    }
}

// This routine is specific to setting the region.
/*
function fUNQ26(selElem) {
    var tmpAry = [], i;
    for ( i=1;i<selElem.options.length;i++) {
        tmpAry[i - 1] = [];
        tmpAry[i - 1][0] = selElem.options[i ].text;
        tmpAry[i - 1][1] = selElem.options[i ].value;
        tmpAry[i - 1][2] = selElem.options[i ].selected;
    }
    // tmpAry.sort()

    tmpAry.sort(function (a, b) {
        return a[0].localeCompare(b[0]);
       // return a[0] - b[0] ;
    });

    while (selElem.options.length > 1) {
        selElem.options[1] = null;
    }
    for ( i=1;i<tmpAry.length;i++) {
        var op = new Option(tmpAry[i - 1][0], tmpAry[i - 1][1]);

        if(tmpAry[i-1][2] == true)
        op.selected =true;

        selElem.options[i] = op;
    }
}
*/

// This is implemented to change when the items to display changes.
function fUNQ27() {


   // var markerDesc = [];

    mObject.headerDisplayOrderIdxs.length = 0;

    var descDisplay ;

    var firstLine = dataLines[0];

    var heightPx = 0;


    $('#toDisplay option').each(function () {



      //  var label = $(this).text();
        var idx = $(this).attr('value');
      //  markerDesc[markerDesc.length] = idx;
        mObject.headerDisplayOrderIdxs[mObject.headerDisplayOrderIdxs.length] = parseFloat(idx);


        heightPx += 30;

    });


   descDisplay = '<div id="innerMarkerDescDiv" >' + fUNQ28(firstLine) + '</div>';
    //descDisplay = '<div>' + fUNQ28(firstLine) + '</div>';
    $('#markerDescriptionDiv').html(descDisplay);

  /*  if(heightPx > 450) {
        heightPx = 450;
    }
    */
   // heightPx = heightPx + "px";

    // TODO ***** use this in more areas!
   // $('#markerDescriptionDiv').css('height', heightPx);


}

// Show the title at the top and have it link to the website if there is a website
//
function fUNQ28(dataItem) {

    var title = "";

    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

        if(fUNQ178(mObject.web)  && dataItem[mObject.web] != "")  {
            title = '<div><a href="'+urlizeUrl(dataItem[mObject.web])+ '" target="_blank">'+ dataItem[mObject.title] + '</a></div>';
        }
        else
            title = dataItem[mObject.title];

    }
    var address ;


        address = fUNQ162(dataItem, "<br>", true);

        if(address != "") {
            address    = '<div>' + address +   '</div>';
            // link the address to something
        }


    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {


                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');


                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }
            }
        }

    }



    var firstHalf = title + address + descDisplay;
   // ; //;+

      //    + descDisplay ;
    firstHalf +=        fUNQ29(dataItem, title)  ;

    return firstHalf;
}


function fUNQ29(dataItem, title) {

    var secondHalf = "";

    var siteImage =  "";
    if(fUNQ178(mObject.image) && dataItem[mObject.image] != "")  {
        siteImage = '<div><img src="' + dataItem[mObject.image] + '"/></div>';
    }

    var email = "";
    if(fUNQ178(mObject.email) && dataItem[mObject.email] != "") {
        email = '<div>e-mail: <a href="mailto:' + dataItem[mObject.email] + '">' +   dataItem[mObject.email] + '</a></div>';

    }
    var website = "";
    if(title == "" && fUNQ178(mObject.web) && dataItem[mObject.web] != "")  {
        website = '<div><a href="' + urlizeUrl(dataItem[mObject.web]) + '" target="_blank">' +   dataItem[mObject.web] + '</a></div>';
    }

    secondHalf += siteImage ;
    secondHalf +=   email ;
    secondHalf +=  website;
    return secondHalf;
}


function fUNQ30(a) {
    return /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/.test(a)             ;
}

function fUNQ31(a) {
    return /^[a-zA-Z0-9_-]+$/.test(a)             ;
}

/*function validateEmailComplex(a) {

     return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,4})+$/.test(a) ;
}        */

function fUNQ32(filterLimit) {

    jQuery('#moveToFilter').click(function () {

        var toFilterSelector =  $('#toFilter');



        $('#noFilter option:selected').each(function () {

            if(filterLimit >  toFilterSelector.children().length) {
                $('#toFilter').append($(this).clone(true));
                $(this).remove();

            }
        });

        if(filterLimit <=  toFilterSelector.children().length) {
            jQuery('#moveToFilter').attr("disabled", "disabled");
        }

    });

    jQuery('#removeFromFilter').click(function () {


        $('#toFilter option:selected').each(function () {
            $('#noFilter').append($(this).clone(true));
            $(this).remove();
        });

        jQuery('#moveToFilter').removeAttr("disabled");
    });

    /*   jQuery('#moveAllToDisplay').click(function () {


     $('#noDisplay option').each(function () {
     $('#toDisplay').append($(this).clone(true));
     $(this).remove();
     });


     });
     */

    jQuery('#removeAllFromFilter').click(function () {


        $('#toFilter option').each(function () {
            $('#noFilter').append($(this).clone(true));
            $(this).remove();
        });

        jQuery('#moveToFilter').removeAttr("disabled");

    });

}


// toItems and from items have the indexes,
// allItems has the index with the name
function fUNQ33(availableFromId, availableToId, toItems, fromItems, allItems) {

    var    availableFromIdSelector =  jQuery("#" + availableFromId),
        availableToIdSelector =    jQuery("#" + availableToId);

    availableFromIdSelector.empty();
    availableToIdSelector.empty();

    var appendFroms = "", idx;

    for (  idx = 0; idx < fromItems.length; idx++) {
        appendFroms += '<option value="' + fromItems[idx] + '">' + allItems[fromItems[idx] ] + '</option>';

    }


    var appendTo = "";
    for ( idx = 0; idx < toItems.length; idx++) {
        appendTo += '<option value="' + toItems[idx] + '">' + allItems[toItems[idx] ] + '</option>';

    }

    if(appendFroms != "")
    {
        availableFromIdSelector.append(appendFroms);
    }


    if(appendTo != "")
    {
        availableToIdSelector.append(appendTo);
    }

}


function fUNQ34(columnHeaderArray, dataLines) {

    var columnIdxs = [];
    $('#toFilter option').each(function () {
        var attrValue = $(this).attr('value');



        columnIdxs.push(attrValue );
    });

    if(columnIdxs.length > 0 ) {
        mObject.filterColumnIdxs =  columnIdxs;
        fUNQ35(columnIdxs, columnHeaderArray, dataLines);
    }
    else if(mObject.filterListNames.length > 0 ) {
        mObject.filterListNames.length = 0;
        mObject.filterListArray.length = 0;
        mObject.filterListSortedKeyHash = {};

    }

}

function fUNQ35(columnHeaderIdxs, columnHeaderArray, dataLines) {

    mObject.filterListNames.length = 0;
    mObject.filterListArray.length = 0;
    mObject.filterListSortedKeyHash = {};


    for(var i = 0; i < columnHeaderIdxs.length; i++) {


        var columnIdx = columnHeaderIdxs[i];

        if(columnIdx >= columnHeaderArray.length ) {
        }

        else {
            var headerName = columnHeaderArray[columnIdx];

            fUNQ36(dataLines, headerName, columnIdx, MAX_FILTER_SIZE);
        }

    }

}


function fUNQ36(allData, filterName, filterIdx, maxFilterSize) {

    var bucketHash = {};  // key is the filter value, value is the index

    var allNumbers = true;
    var allDates = true;
    var bucketSize = 0;
    var bucketKeys = [];  // list of filters (column values) (correctly sorted???)




    for (var i = 0; i < allData.length; i++) {

        var dataLine = allData[i];

        var groupItem = dataLine[filterIdx];

        if(groupItem == null || groupItem.trim().length == 0 || groupItem  == ALL_FILTER)
        {
            continue;
        }


        if (allNumbers) {

            if (!$.isNumeric(fUNQ37(groupItem))) {
                allNumbers = false;
            }
        }

        if (allDates) {

            if (!fUNQ124(groupItem)) {
                allDates = false;
            }
        }
        var bucketLineIndex;

        if (bucketHash.hasOwnProperty(groupItem)) {
             bucketLineIndex = bucketHash[groupItem];
            bucketLineIndex.push(i);

        } else if (bucketSize < maxFilterSize) {
             bucketLineIndex = [];

            bucketLineIndex.push(i);
            bucketHash[groupItem] = bucketLineIndex;
            bucketKeys.push(groupItem);
            bucketSize++;
        }
    }


    if (allNumbers) {
        bucketKeys.sort(function (a, b) {
            return fUNQ37(a) - fUNQ37(b);
        });
    }

    else if (allDates) {
        fUNQ53(bucketKeys);
//        bucketKeys.sort(function (a, b) {
//            a = new Date(a);
//            b = new Date(b);
//            return a < b ? -1 : a > b ? 1 : 0;
//        });
    } else {
        bucketKeys.sort();
    }


    mObject.filterListNames.push(filterName);
    mObject.filterListArray.push( bucketHash);
    mObject.filterListSortedKeyHash[filterName] = bucketKeys;

}

function fUNQ37(v) {

        return parseFloat(v.toString().replace(/\$|\,|\s+|\%/g, "") );

}

function fUNQ38(v) {
    return v.toString().indexOf("%") != -1 ? "%" : ""
}
function fUNQ39(v) {
    return v.toString().indexOf("$") != -1 ? "$" : ""
}

// This was used for testing purposes
/*
function fUNQ40(groups) {


    var tempGroup = [];
    tempGroup.push(ALL_FILTER);
    tempGroup = tempGroup.concat(groups);

    var selStr = fUNQ49(tempGroup, ALL_FILTER, "group_filter", "Group");

    $('#usedGroup').html(selStr );

}
*/

// This is used for testing, on the page to generate maps
// This was used for testing purposes
/*
function fUNQ41() {


//      filterListNames.push(filterName);
//     filterListArray.push( bucketHash);
//     filterListSortedKeyHash[filerName] = bucketKeys;

    var filterDisplay = "";

    if(mObject.filterListNames.length == 0)
        return;

    selectedFilterValues = new Array(mObject.filterListNames.length);

    for(var i = 0; i < mObject.filterListNames.length; i++)
    {

        var tempFilter = [];
        tempFilter.push(ALL_FILTER);
        tempFilter = tempFilter.concat(mObject.filterListSortedKeyHash[mObject.filterListNames[i]]);

        var selStr = fUNQ49(tempFilter, ALL_FILTER, mObject.filterListNames[i] +"_rfilter", mObject.filterListNames[i]);

        filterDisplay = filterDisplay + "<li>" + selStr + "</li>";

        selectedFilterValues[i] = ALL_FILTER;

    }


    filterDisplay = "<ul>" + filterDisplay + "</ul>";

    $('#usedFilters').html(filterDisplay  );

}
*/


// This is used on the map
function fUNQ42() {


    /*  filterListNames.push(filterName);
     filterListArray.push( bucketHash);
     filterListSortedKeyHash[filerName] = bucketKeys;
     */
    var filterDisplay = "", filtersDiv;

    if(mObject.filterListNames.length == 0)   {


        if(userSettings.title != null && userSettings.title.length > 0)  {

             filtersDiv =  $('#filtersDiv');

            if(filtersDiv.length > 0 ) {
                filtersDiv.html('<div id="mapTitle">' + userSettings.title + '</div>');
                filtersDiv.show();
            }
        }

        return ;

    }


    selectedFilterValues = new Array(mObject.filterListNames.length);

    var titleDisplay = "", i;
  //  var filtersDisplay = "";

    for( i = 0; i < mObject.filterListNames.length; i++)
    {

        var tempFilter = [];
        tempFilter.push(ALL_FILTER);
        tempFilter = tempFilter.concat(mObject.filterListSortedKeyHash[mObject.filterListNames[i]]);

        var selStr = fUNQ49(tempFilter, ALL_FILTER, i.toString() +"_rfilter", null );

        titleDisplay = titleDisplay + "<td>" + mObject.filterListNames[i]+ "</td>";

        filterDisplay = filterDisplay + "<td>" + selStr + "</td>";

        selectedFilterValues[i] =            ALL_FILTER;
    }

     var totalTable = "<div><table><tbody><tr>" +  titleDisplay +  "</tr><tr>" +  filterDisplay + "</tr></tbody></table></div>";
   // filterDisplay = "<ul>" + filterDisplay + "</ul>";

    //  only use this for debugging!
   // $('#usedFilters').html(totalTable  );

     filtersDiv =  $('#filtersDiv');

    if(filtersDiv.length > 0 ) {
        filtersDiv.html(totalTable);
        filtersDiv.show();
    }

    //
    for( i = 0; i < mObject.filterListNames.length; i++)
    {
        var currentIdx = i;
        var filterName = i.toString() +"_rfilter";

        fUNQ43(filterName, currentIdx)    ;

     /*   jQuery('#' + filterName).change(function () {

            //    mObject.selectedMapType = this.value;
            selectedFilterValues[currentIdx] = this.value;

            // call function to do stuff with the filters!
            fUNQ164();

        });           */
    }


}

function fUNQ43(filterName, filterIdx) {

    jQuery('#' + filterName).change(function () {

        //    mObject.selectedMapType = this.value;
        selectedFilterValues[filterIdx] = this.value;

        // call function to do stuff with the filters!
        fUNQ164();

    });
}


function fUNQ44(filterName, filterValue) {

    var idx = mObject.filterListNames.indexOf(filterName);

    if(idx == -1)
    {
        return [];
    }

    var bucketHash = mObject.filterListArray[idx];

    if (bucketHash.hasOwnProperty(filterValue)) {
        return  bucketHash[filterValue];
    }


    return [];
}


function fUNQ45(allData) {
    var attrValue = $('#group_sel option:selected').attr('value');


    if(attrValue == "none") {
        // do nothing;
        return;
    }

    fUNQ50(allData, attrValue, MAX_GROUPS);

     if(mObject.sortedGroupKeys.length > 1) {
         fUNQ46(allData.length);
     }

}

function fUNQ46(arraySize) {

    var imageIdxs = new Array(arraySize);

    mObject.groupImageHash = {};

    var imageIdx = 0;
    // for (var groupName in mObject.groupHash) {

    for(var j=0; j < mObject.sortedGroupKeys.length; j++)      {
        var groupName =     mObject.sortedGroupKeys[j];

        if(mObject.groupHash.hasOwnProperty(groupName))  {
            var bucketLineIndex = mObject.groupHash[groupName];

            for(var i = 0; i < bucketLineIndex.length; i++)  {
                imageIdxs[bucketLineIndex[i]]  = imageIdx;
            }

            mObject.groupImageHash[groupName]  = imageIdx;
            imageIdx++;
        }
    }

    if( mObject.sortedGroupKeys.length > 1)
     mObject.markerImageIdx =    imageIdxs;
}

function fUNQ47(groupName) {


    if (mObject.groupHash.hasOwnProperty(groupName)) {
       return  mObject.groupHash[groupName];

    }


    return [];
}


function fUNQ48(selectableItems, selectedItem, selectId)      {

    var dropDown = $('#' + selectId);

    var selStr = "";

    for (var i = 0; i < selectableItems.length; i++) {


        if (selectableItems[i] == selectedItem) {
            selStr = selStr.concat('<option value="'  + selectableItems[i] + '" selected>' +

                selectableItems[i] + '</option>\n');

            //selected_columns[selectId] = selItemsIdx[selItem];


        } else {
            selStr = selStr.concat('<option value="' + selectableItems[i] + '" >' +

                selectableItems[i] + '</option>\n');
        }
    }

    dropDown.html(selStr);

}

// builds the string for the drop down, return the string.
// The resulting string can be added to a div.
// a change select can also be added for this.
function fUNQ49(selectableItems, selectedItem, selectId, labelName, selectWidth) {


    var widthStr = "";

    var defaultWidth = "250";
    if(selectWidth != undefined)
    {
        defaultWidth = selectWidth;

        widthStr = ' style="width: '+ defaultWidth +'px;" ';
    }

    var labelStr = "";

    if(labelName)        {
        labelStr = '<label id="' + selectId + '_label" for="' + selectId + '">' + labelName  + '</label>';
    }



    var selStr = '<select name="' + selectId + '" id="' + selectId + '"' +  widthStr + '>\n';

    for (var i = 0; i < selectableItems.length; i++) {


        if (selectableItems[i] == selectedItem) {
            selStr = selStr.concat('<option value="'  + selectableItems[i] + '" selected>' +

                selectableItems[i] + '</option>\n');

            //selected_columns[selectId] = selItemsIdx[selItem];


        } else {
            selStr = selStr.concat('<option value="' + selectableItems[i] + '" >' +

                selectableItems[i] + '</option>\n');
        }
    }

    selStr = selStr.concat("</select>");

    return labelStr + selStr;

}





// grouping: a hash with the key being the group and the value being an array with indexes of the markers
// allData is the original data, it's an array, so the rows will need to be split based on tab
// maxGroupCount is the groups that will get bucketed

function fUNQ50(allData, groupIdx, bucketSizeLimit) {

    if(groupIdx < 0)
        return;

    var bucketHash ={};


    var allNumbers = true;
    var allDates = true;
    var bucketSize = 0;
    var bucketKeys = [];

    var emptyGroup = [];
    var i;


// used to help grouping
    //var first, last, next, rangeKey, tempIndxs;

    mObject.sortedGroupKeys.length = 0;
    mObject.groupHash = {};

    for ( i = 0; i < allData.length; i++) {

        var dataLine = allData[i];

        if(dataLine == null || dataLine.length == 0)
            continue;

        var groupItem =  dataLine[groupIdx];

        if(groupItem.trim() == "")
        {
            emptyGroup.push(i);
            continue;
        }

        if (allNumbers) {

            if (!$.isNumeric(fUNQ37(groupItem))) {
                allNumbers = false;
            }
        }

        if (allDates) {

            if (!fUNQ124(groupItem)) {
                allDates = false;
            }
        }

        var bucketLineIndex;
        if (bucketHash.hasOwnProperty(groupItem)) {
             bucketLineIndex = bucketHash[groupItem];
            bucketLineIndex.push(i);

        } else {
             bucketLineIndex = [];

            bucketLineIndex.push(i);
            bucketHash[groupItem] = bucketLineIndex;
            bucketKeys.push(groupItem);
            bucketSize++;
        }
    }

    if(emptyGroup.length > 0)
     bucketSizeLimit = bucketSizeLimit -1;

    if(bucketSizeLimit >= bucketSize) {

        if (allNumbers) {
            bucketKeys.sort(function (a, b) {
                return fUNQ37(a) - fUNQ37(b) ;
            });
        }


        else if (allDates) {

            fUNQ53(bucketKeys);

//            // reverse the date and month for non-United States Regions
//            if(mObject.region != null && mObject.region != "us") {
//                for ( i = 0; i < bucketKeys.length; i++) {
//                    bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
//                }
//            }
//
//              bucketKeys.sort(function (a, b) {
//                a = new Date(a);
//                b = new Date(b);
//
//                return a < b ? -1 : a > b ? 1 : 0;
//              });
//
//            // Revert back to the original data/time format for non-us regions
//            if(mObject.region != null && mObject.region != "us") {
//                for ( i = 0; i < bucketKeys.length; i++) {
//                    bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
//                }
//
//            }

        }

        else {
            bucketKeys.sort();
        }

        for ( i = 0; i < bucketKeys.length; i++) {
            mObject.sortedGroupKeys.push(bucketKeys[i]);
            mObject.groupHash[bucketKeys[i]] =  bucketHash[bucketKeys[i]]  ;
        }
    }


    if (bucketSize > bucketSizeLimit) {
      //  var mergeBuckets = Math.ceil(bucketSize / bucketSizeLimit);
       // var remainder = bucketSize % bucketSizeLimit;

       // var tempHash = {};

        if (allNumbers) {
            bucketKeys.sort(function (a, b) {
                return fUNQ37(a) - fUNQ37(b) ;
            });


//             first = parseInt(bucketKeys[0], 10);
//             last = parseInt(bucketKeys[bucketKeys.length - 1], 10);
//            // var rangeSize = (last - first) / bucketSizeLimit;
//
//            // var next = first + rangeSize;
//            // var next = bucketKeys[mergeBuckets]
//            var nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, 0);
//            // want to get the item before nextIdx instead of doing -1 (same for the case below as well)
//             next = parseInt(bucketKeys[nextIdx -1] , 10 ) ;
//
//
//             rangeKey = first + "-" + next;
//
//            if(first == next)
//                rangeKey = first;
//
//             tempIndxs = [];
//            mObject.groupHash[rangeKey] = tempIndxs ;
//
//
//
//            /*      for (var i = 0; i < bucketKeys.length; i++) {
//
//             if ((bucketKeys[i] / 1) > next) {
//             first = next + 1;
//             next = next + rangeSize;
//
//             if (next > last) next = last;
//
//             rangeKey = first + "-" + next;
//             var tempIndxs = [];
//
//             mObject.groupHash[rangeKey] = tempIndxs;
//             }*/
//
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if ( i >= nextIdx   && nextIdx < bucketSize -1) {
//
//                    first = bucketKeys[nextIdx];
//
//                        nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, i);
//                        next = parseInt(bucketKeys[nextIdx - 1] , 10 ) ;
//
//
//                    if(nextIdx == bucketSize -1) {
//                        next =     parseInt(bucketKeys[nextIdx] , 10 ) ;
//                    }
//
//                  //  if(nextIdx == bucketSize -1)
//                   //     next += 1;
//
//                    rangeKey = first + "-" + next;
//
//                    if(first == next)
//                        rangeKey = first;
//
//                    tempIndxs = [];
//
//                    mObject.groupHash[rangeKey] = tempIndxs;
//                }
//
//                mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//                tempIndxs = mObject.groupHash[rangeKey];
//
//                if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
//                    mObject.sortedGroupKeys.push(rangeKey);
//                }
//            }

        }

        else if (allDates) {

            fUNQ53(bucketKeys);

//            bucketKeys.sort(function (a, b) {
//                a = new Date(a);
//                b = new Date(b);
//
//                return a < b ? -1 : a > b ? 1 : 0;
//            });


//             first = bucketKeys[0];
//             last = bucketKeys[bucketKeys.length - 1];
//
//            var firstDate = new Date(first).getTime();
//            var lastDate = new Date(last).getTime();
//
//
//            var rangeSize = (lastDate - firstDate) / bucketSizeLimit;
//
//             next = firstDate + rangeSize;
//             rangeKey = new Date(firstDate).toDateString() + "-" + new Date(next).toDateString();
//             tempIndxs = [];
//            mObject.groupHash[rangeKey] = tempIndx;
//
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if ((new Date(bucketKeys[i]).getTime()) > next) {
//                    first = next + 1;
//                    next = next + rangeSize;
//
//                    if (next > last) next = last;
//
//                    rangeKey = new Date(firstDate).toDateString() + "-" + new Date(next).toDateString();
//                    tempIndxs = [];
//
//                    mObject.groupHash[rangeKey] = tempIndxs;
//                }
//                mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//                tempIndxs = mObject.groupHash[rangeKey];
//
//                if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
//                    mObject.sortedGroupKeys.push(rangeKey);
//                }
//            }



        } else {

            bucketKeys.sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            } );
           // bucketKeys.sort();

//            // take the first x number of  items and group all the rest in the 'Other' bucket
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if (i < bucketSizeLimit - 1 || bucketKeys.length == bucketSizeLImit) {
//                    mObject.groupHash[bucketKeys[i]] = bucketHash[bucketKeys[i]];
//                    mObject.sortedGroupKeys.push(bucketKeys[i]);
//
//                } else {
//                    if (mObject.groupHash.hasOwnProperty('Other')) {
//                         tempIndxs = mObject.groupHash['Other'];
//                        mObject.groupHash['Other'] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//
//                    } else {
//                        mObject.groupHash['Other'] = bucketHash[bucketKeys[i]];
//                    }
//
//                    if(mObject.sortedGroupKeys.indexOf('Other') == -1)
//                        mObject.sortedGroupKeys.push('Other');
//
//                }
//
//            }

        }

        fUNQ51(bucketHash, bucketKeys, bucketSize, bucketSizeLimit);
    }

    if(emptyGroup.length > 0)
    {
        mObject.groupHash['Empty'] = emptyGroup;

        mObject.sortedGroupKeys.push('Empty');
    }

}

function fUNQ51(bucketHash, bucketKeys, bucketSize, bucketSizeLimit) {

    var i;
    var mergeBuckets = Math.ceil(bucketSize / bucketSizeLimit);
    var remainder = bucketSize % bucketSizeLimit;


    var first, /*last,*/ next, rangeKey, tempIndxs;

    first = bucketKeys[0];
  //  last = parseInt(bucketKeys[bucketKeys.length - 1], 10);
    // var rangeSize = (last - first) / bucketSizeLimit;

    // var next = first + rangeSize;
    // var next = bucketKeys[mergeBuckets]
    var nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, 0);
    // want to get the item before nextIdx instead of doing -1 (same for the case below as well)
    next = bucketKeys[nextIdx -1] ;


    rangeKey = first + "-" + next;

    if(first == next)
        rangeKey = first;

    tempIndxs = [];
    mObject.groupHash[rangeKey] = tempIndxs ;



    /*      for (var i = 0; i < bucketKeys.length; i++) {

     if ((bucketKeys[i] / 1) > next) {
     first = next + 1;
     next = next + rangeSize;

     if (next > last) next = last;

     rangeKey = first + "-" + next;
     var tempIndxs = [];

     mObject.groupHash[rangeKey] = tempIndxs;
     }*/

    for ( i = 0; i < bucketKeys.length; i++) {

        if ( i >= nextIdx   && nextIdx < bucketSize -1) {

            first = bucketKeys[nextIdx];

            nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, i);
            next = bucketKeys[nextIdx - 1] ;


            if(nextIdx == bucketSize -1) {
                next =     bucketKeys[nextIdx]  ;
            }

            //  if(nextIdx == bucketSize -1)
            //     next += 1;

            rangeKey = first + "-" + next;

            if(first == next)
                rangeKey = first;

            tempIndxs = [];

            mObject.groupHash[rangeKey] = tempIndxs;
        }

        mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
        tempIndxs = mObject.groupHash[rangeKey];

        if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
            mObject.sortedGroupKeys.push(rangeKey);
        }
    }

}


function fUNQ52(totalItems, ceiling, remainder, currentIdx) {

// 19 / 7 -> 3
// 19 %  7 = 5  -> means 5 get 3 and the others get 1 less

    var increments = 0;
    for(var i = 0; i <= totalItems; i += ceiling)
    {

        if(increments > remainder && remainder != 0) {
            i -= 1;
        }

        if( i > currentIdx)
        {
            if(i >= totalItems)
                return totalItems - 1;
            return i;
        }

        increments++;
    }

    return totalItems - 1;

}

function fUNQ53(bucketKeys) {

    var i;

    // reverse the date and month for non-United States Regions
    if(mObject.regionCode != null && mObject.regionCode.length > 0 && mObject.regionCode != "us") {
        for ( i = 0; i < bucketKeys.length; i++) {
            bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
        }
    }

    bucketKeys.sort(function (a, b) {
        a = new Date(a);
        b = new Date(b);

        return a < b ? -1 : a > b ? 1 : 0;
    });

    // Revert back to the original data/time format for non-us regions
    if(mObject.regionCode != null && mObject.regionCode.length > 0 && mObject.regionCode != "us") {
        for ( i = 0; i < bucketKeys.length; i++) {
            bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
        }

    }
}


function fUNQ54() {

    var str = "", i;

    for(i = 0; i < dataLines.length; i++) {

        if(dataLines[i] == null || dataLines[i].length == 0)
            continue;

        str = str + dataLines[i].join('\t') + "\n";

    }
    return str;
}

function fUNQ55(data) {

    if(data.country_code) {


        var selectedOption = $('#region_sel option[value="' + data.country_code.toLowerCase()  + '"]')     ;

        if(selectedOption.length > 0) {
            selectedOption.prop('selected', true) ;
        }
//        else {
//
//            // add the element
//            var regionSel = document.getElementById("region_sel");
//            var controlOption =  document.createElement('option');
//            controlOption.value=  data.country_code.toLowerCase() ;
//            controlOption.innerHTML = data.country;
//
//            regionSel.appendChild(controlOption);
//            controlOption.selected = true;
//            fUNQ26(regionSel) ;
//
//        }

    }

}

function fUNQ56(ipAddress) {

    $.ajax({
        type: 'GET',
        url: '/location',
        data: { ip_addr: ipAddress },
        dataType: 'json',
        success:function(data, status, result){

            var tmpStatus = "OK";
            if(data.errorMessage) {
                //      alert(data.errorMessage);
                tmpStatus = data.errorMessage;
            }

            if(data.reservedIp != 0) {
                tmpStatus = "Reserved IP";
            }
                fUNQ95(data, tmpStatus, ipAddress);


        },
        error:function(data, status, result){

            var tmpStatus = "Other Error";
            if(data.errorMessage) {
                //   alert(data.errorMessage);
                tmpStatus = data.errorMessage;
            }
            fUNQ95(data, tmpStatus, ipAddress);

            //     $("#resultDiv").html(result);
        }
    });
}

function fUNQ57() {

    $.ajax({
        type: 'GET',
        url: '/location',
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
          //      alert(data.errorMessage);
            }

            if(data.reservedIp == 0) {
                           fUNQ55(data);
            }

        },
        error:function(data, status, result){

            if(data.errorMessage) {
             //   alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);
        }
    });
 }

function fUNQ58(mapId) {

    var kmlData =       fUNQ197();

    $.ajax({
        type: 'POST',
        url: '/savekml',
        data: { kml: kmlData, Id: mapId },
        cache: false,
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
                alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);

            fUNQ59(true, mapId);
        },
        error:function(data, status, result){

            if(data.errorMessage) {
                alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);
            fUNQ59(false);
        }
    });

}


function fUNQ59(success, mapId) {

    var mapSaveStatus     = $('#mapSaveStatus')    ;
    var  mapUrl = $('#mapUrl');


    mapSaveStatus.show();

    if(success ) {

        var saveStatusMsg = "";

        if( savedMapId == null)
        {
            savedMapId = mapId;
        }
        else  {
            saveStatusMsg = "re-";
        }

        fUNQ60(mapSaveStatus, '<h5>Your map was successfully '+ saveStatusMsg + 'saved.</h5>', "success" )    ;


        if(mapId != null && mapUrl.length > 0) {

            userSettings.name = mapId.toString();

            var baseMapUrl = location.protocol + "//" + location.hostname + "/map/";
            var mapFullUrl =   location.protocol + "//" + location.hostname + "/map/"  + mapId.toString();
            mapUrl.html('<pre><p style="margin-bottom: 0px;">The map url is </p><a href="'+ mapFullUrl + '" target="_blank">' + mapFullUrl + '</a></pre>' );

          // new code:
           var str = ' <pre><p style="margin-bottom: 0px;">The map url is </p>' +
              '  <a id="genMapUrl" href="'  + mapFullUrl+ '" target="_blank">' + baseMapUrl + '<span  id="editable-url">' + mapId.toString() +
               '</span></a><span  id="mod-url" style="display: none;"></span> <a onclick="fUNQ130(); return false;"  id="editable_url_btn" class="btn btn-mini btn-primary" href="#">Edit</a>' +
               '<span id="edit-slug-buttons" style="display: none;"><a onclick="fUNQ131(); return false;"  class="btn btn-mini btn-primary" href="#">Save</a> ' +
               '<a onclick="fUNQ132(); return false;" style=" white-space: nowrap; font-size: 11px; margin-right: 10px;" href="#">Cancel</a></span>' +
               '<span id="aliasStatusDiv" style="margin-left: 5px; margin-bottom: 0; padding: 4px; white-space: nowrap;"></span>' +
               '<span id="aliasInstDiv" style="display: none;"><p>Valid characters are numbers, letters, underscores (_) and dashes (-).</p></span></pre>';

            mapUrl.html(str);
        }

        if( typeof EditingMap == 'undefined')
        {
            mapUrl.show();

            $('#mapModalButton').hide();


        }

    }
    else {
        $("#mapModalButton").button('reset') ;
        fUNQ60(mapSaveStatus, '<h5>There was a problem saving the map.</h5>', "error" )    ;
        //    mapSaveStatus.addClass("alert-error");
        //  mapSaveStatus.html('<h5>There was a problem saving the map.</h5>');
    }

}


function fUNQ60(div, message, status)  {

    div.html( message );


    if(!div.hasClass("alert"))
    {
        div.addClass("alert");
    }


    if(status == "error") {

        if(!div.hasClass("alert-error"))
        {
            div.addClass("alert-error");
        }

        if(div.hasClass("alert-success"))
        {
            div.removeClass("alert-success")  ;
        }
    }
    else {
        if(div.hasClass("alert-error"))
        {
            div.removeClass("alert-error");
        }

        if(!div.hasClass("alert-success"))
        {
            div.addClass("alert-success")  ;
        }

    }


}




function fUNQ61(editPage) {

    userSettings.email =  $('#emailInput').val();
    userSettings.title = $('#titleInput').val();
    userSettings.description =  $('#descriptionInput').val();
    userSettings.protectionLevel =  $('input[name=protectionLevel]:checked').val();

    var genKmlInput = $('#genKmlCB');

    if(genKmlInput.length > 0 )
        userSettings.genKML    =    $('#genKmlCB').is(':checked');

    //  userSettings.key = $('#securityKey').val();


    userSettings.autoDelete = true;
    userSettings.dataOnPage = true;

    if(editPage != null && editPage) {
        userSettings.autoDelete = ($('input[name=mapDelete]:checked').val() == "true");


        if( $('input[name=mapLayout]:checked').val() == "mapOnly")
            userSettings.dataOnPage = false;
    }

    return !(userSettings.email.length > 0 && !fUNQ30(userSettings.email))  ;
  //   return false;

   // return true;

}

function fUNQ62() {

    if( removedMarkers.length > 0 ) {

        fUNQ63 ();

        // should regenerate the groups and filters!
        fUNQ50(dataLines, mObject.group, MAX_GROUPS);

        // maybe this should be called by the map instead of here
        if(mObject.sortedGroupKeys.length > 1) {
            fUNQ46(dataLines.length  );
        }

        fUNQ35(mObject.filterColumnIdxs, mObject.columnHeaderArray, dataLines);

    }

}

function fUNQ63() {
    var i;
    for( i = removedMarkers.length - 1; i >= 0; i--)
    {
        dataLines.splice(removedMarkers[i], 1);
        gMapMarkers.splice(removedMarkers[i], 1);
    }

    // reset the marker idx'es
    for( i = 0; i < gMapMarkers.length; i++)
        gMapMarkers[i].idx = i;

}


function fUNQ64() {

    fUNQ62();

    var str = fUNQ54();
    var config = JSON.stringify(mObject)     ;
    var mDetails = JSON.stringify(userSettings);

    var oldMapId = "";

    if(savedMapId   != null)
        oldMapId =     savedMapId;

    /*  $.ajax({url:"/php/saveData.php",success:function(result){
     $("#resultDiv").html(result);
     }});
     */
    $.ajax({
        type: 'POST',
        url: '/savedata',
        data: ({ usercontent: str, configContent: config, mapDetails: mDetails, mapType: mObject.mapType, existingId: oldMapId }),
        cache: false,
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
          //      alert(data.errorMessage);
            }

       //     $("#resultDiv").html(result);

            if(userSettings.genKML != null && userSettings.genKML == true)  {

                fUNQ58(data.uid);
            }
            else {
                fUNQ59(true, data.uid);
            }


        },
        error:function(data, status, result){

            if(data.errorMessage) {
            //    alert(data.errorMessage);
            }

            fUNQ59(false);

       //     $("#resultDiv").html(result);
        }
    });


}


function fUNQ65(possibleFunction) {
    return (typeof(possibleFunction) == typeof(Function));
}


// returns true if one items is in the other array
function fUNQ66(a1, a2) {

    for (var item in a1) {
        if (fUNQ67(a1[item], a2)) {
            return true;
        }
    }
    return false;
}

function fUNQ67(item, a1) {

    return (a1.indexOf(item) >= 0);
}

function fUNQ68(a1, a2) {

    var result =[];

    for (var i = 0; i < a1.length; i++) {
        if (a2.indexOf(a1[i]) !== -1) {
            result.push(a1[i]);
        }
    }

    return result;
}
// holds marker idx tha have been removed during the edit process
var removedMarkers = [];

var gMapMarkers = [];

var gMap = null;

var openMarker = null;
var openWindow = null;
//var directionInfoW = null;

var ignorePagingEvent = false;

// markers at the same position as others for info window
var samePosMarkers = [];

// holds the indexes of groups not to be displayed
var groupsOff = [];

// the markers to display either for a search, grouping, or the filters.
var selectedMarkers = [];
var selectedMarkerSet =false;

var markerCluster = null;

// corresponding google map options:
var googleMapOptions = [] ;
//var markerNumbers = [1, 2, 3, 4, 5, 6, 7,8, 9];

// teh number of items that can be displayed below the map
var DISPLAYABLE_ITEMS_PER_PAGE = 50;

var CLUSTER_ZOOM_LEVEL = 12;

// used for marker paging
var ITEMS_PER_PAGE = 5;
var currentPageMarkerNum = 1;
var nextPageMarkerNum = 1 + ITEMS_PER_PAGE;
var previousPageMarkerNum = 1;

// key is the search term, value is an array of indexes that match this (the array corresponds to the markers.
var searchTermHash = {};

var mobileDevice = false;
var tabletDevice = false;
var inIframe = false;
var showDirections = true;

var directionsService = null;
var directionsDisplay = null;

// only fill this in if displayDataOnPage is true
var markerDescriptions = [];


var showMoreOptions = false;

var mapGeocoder = null;

// Used with the nearby filter
var circle = null;
var circleFilter = false;
var showDistance = false;
var circleRadius = 0;

// number of the active dir text box, must be greater than 1 for one of them to be active (1 or 2 currently)
var activeDirTextBox = 0;

function initMap(mapDiv, mapTypeIdx) {

    if(mObject.showLabels == null)
        mObject.showLabels = true;

    if(mObject.showMoreOptions != null && mObject.showMoreOptions)
        showMoreOptions = true;

    if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))
        || (  (navigator.userAgent.match(/mobile/i))  &&  (navigator.userAgent.match(/Android/i))  ) ||
        (navigator.userAgent.match(/blackberry/i)) || (navigator.userAgent.match(/windows phone/i))   ) {
        mobileDevice = true;
    }
    if( !mobileDevice &&   ((navigator.userAgent.match(/Android/i))  ||  (navigator.userAgent.match(/iPad/i))  )  )  {
        tabletDevice = true;
    }

    if (window.location != window.parent.location)
    {
        inIframe = true;

        $('body').html( fUNQ141() );
    }
    else {
    }

    //if(true) {
    if(!inIframe && tabletDevice && showMoreOptions) {
        $('#left').html( fUNQ140()  );

    }


    googleMapOptions = [google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.TERRAIN, google.maps.MapTypeId.SATELLITE,
        google.maps.MapTypeId.HYBRID];

    var mapType =      googleMapOptions[mapTypeIdx];

    if(gMap != null)
        return;

    var sWheel = false;

    if(mObject.scrollWheel != null && mObject.scrollWheel == true)
        sWheel = true;

    var gMapOptions = {
        zoom: 4,
        center: new google.maps.LatLng(39.8282, -98.5795),     // center of us.
        mapTypeControl: false,
        scaleControl: true,
        scrollwheel: sWheel,
        minZoom: 1,
        panControlOptions : {
            position: google.maps.ControlPosition.LEFT_TOP
        },
        zoomControlOptions : {
            position: google.maps.ControlPosition.LEFT_TOP
        }
    };

    gMap = new google.maps.Map(document.getElementById('map'), gMapOptions);

    gMap.setMapTypeId(mapType);

//gMap.setMapTypeId(google.maps.MapTypeId.ROADMAP);

    // TODO: only do this is the user set it as well!
    // only add this for pc and tablets
    if (!mobileDevice && showMoreOptions) {
        var moreOptionsControl = document.createElement('div');
        moreOptionsControl.innerHTML = '<img id="moreOptionsBlank" src="/img/more_options_blank.png" style="display: none;"><img id="moreOptions" src="/img/more_options.png" onclick="fUNQ134()">';
        moreOptionsControl.index = 1;
        gMap.controls[google.maps.ControlPosition.TOP_LEFT].push(moreOptionsControl);
    }

    var homeControlDiv = document.createElement('div');
    fUNQ144(homeControlDiv, gMap, myMapOptions, mapType, googleMapOptions);

    homeControlDiv.index = 1;
    gMap.controls[google.maps.ControlPosition.TOP_RIGHT].push(homeControlDiv);


    /*            var point = new google.maps.LatLng(35.177648,-84.863288);
     var marker = new google.maps.Marker({        position: point,        map: gMap     });
     marker.setTitle('CPE 517178');
     */
    /* directionInfoW = new google.maps.InfoWindow({
     //  content: message,
     size: new google.maps.Size(50, 50)
     });
     */


    google.maps.event.addListener(gMap, 'click', function() {
        if(openWindow != null )
            openWindow.close();
        //   if(directionInfoW != null)
        //     directionInfoW.close();
    });

    addMarkers(mObject.lat, mObject.lng,   dataLines);

    fUNQ163();

    // don't show filters on mobile devices for now
    if(!mobileDevice) {
        fUNQ42();
        fUNQ189();

        if( !inIframe && mObject.displayDataOnPage && !tabletDevice )      {
            // TODO: this is only here as a test
            fUNQ180();
        }

        if(inIframe) {

            var mapHeaderDir = $('#mapHeader');

            $('#map').css('top', mapHeaderDir.outerHeight());


            if(showMoreOptions) {
                $('#left').css('top', mapHeaderDir.outerHeight());
            }

            var descDiv  = $('#descriptionDiv');
            var descHeight = 0;

            if(descDiv.length > 0) {
                descHeight += descDiv.outerHeight();
            }

            var groupsCheckDiv = $('#groupChecksDiv');
            if(groupsCheckDiv.length > 0 && groupsCheckDiv.is(':visible')) {

                // for some strange reason, adding 6 pixels seems to help since the bottom can get chopped off otherwise
                $('#map').css('bottom', groupsCheckDiv.outerHeight() + descHeight );

                if(showMoreOptions) {
                    $('#left').css('bottom', groupsCheckDiv.outerHeight() + descHeight + 6);
                }

                if(descHeight > 0) {
                    groupsCheckDiv.css('bottom', descHeight);
                }

            }
            else if (descHeight > 0) {

                $('#map').css('bottom',  descHeight);

                if(showMoreOptions) {
                    $('#left').css('bottom',  descHeight );
                }
            }

            if(showMoreOptions && inIframe) {
                $('#dirTextDiv').css('height', $('#map').outerHeight() - 137);


            }

        }

        // if(true) {
        if(showMoreOptions && !inIframe && tabletDevice) {

            var topTemp = 0;

            if( $('#mapHeader').length > 0)
                topTemp =  $('#mapHeader').outerHeight();

            $('#dirTextDiv').css('height', 250 - topTemp);
            $('#left').css('height', 400 - topTemp);

        }


    }

    if(dataLines.length >=  500 && !mObject.clustering) {
        google.maps.event.addListener(gMap, 'idle', showMarkers);
    }


    if(showMoreOptions) {
        fUNQ133();
    }

}


// TODO: move this code somewhere else
function fUNQ133() {

    if($("#mapWindowData").length == 0) {

        var displayDistance = $('#displayDistance');
        if(displayDistance.length > 0)
            displayDistance.hide();
    }

    $('#dirTabDisplay').click(function() {
        fUNQ135();
//        $('#leftDirDisplay').show();
//        $('#leftNearbyDisplay').hide();
//
//        var dirTab = $('#dirTabDisplay');
//        if(!dirTab.hasClass("activeDirHeader"))
//        {
//            dirTab.addClass("activeDirHeader");
//        }
//
//        $('#nearbyTabDisplay').removeClass("activeDirHeader");

    });


    $('#clearDirSubmit').click(function() {


        $('#dirAddress1').val("");
        $('#dirAddress2').val("");
        $('#dirError').hide();
        activeDirTextBox = 0;

        if(directionsDisplay != null) {
            directionsDisplay.setPanel(null);
            directionsDisplay.setMap(null);
        }

    });

    $('#directionSubmit').click(function() {

        var dirErrorDiv = $('#dirError');

        var addr1 = $('#dirAddress1').val();
        var addr2 = $('#dirAddress2').val();
        dirErrorDiv.hide();

        if(addr1.trim().length == 0 ){
            dirErrorDiv.show();
            dirErrorDiv.html("invalid start address");
            return;
        }
        else if(addr2.trim().length == 0) {
            dirErrorDiv.show();
            dirErrorDiv.html("invalid end address");
            return;
        }



        fUNQ138(addr1, addr2);
    });

    // hide options
    $('#hideOptions').click(function() {
        var moreOptionsBlank = $('#moreOptionsBlank');
        $('#left').hide();
        $('#moreOptions').show();
        moreOptionsBlank.hide();



        if(inIframe || tabletDevice) {

            $('#map').css('left', 0);

        }
        else {
            var div = $('#mapContainer');

            if(div.hasClass("padLeft"))
            {
                div.removeClass("padLeft");
            }
        }

        google.maps.event.trigger(gMap, 'resize');

        activeDirTextBox  = 0;
    });

    // show options:




    $('#nearbyTabDisplay').click(function() {

        $('#leftDirDisplay').hide();
        $('#leftNearbyDisplay').show();
        activeDirTextBox = 0;


        var dirTab = $('#nearbyTabDisplay');
        if(!dirTab.hasClass("activeDirHeader"))
        {
            dirTab.addClass("activeDirHeader");
        }

        $('#dirTabDisplay').removeClass("activeDirHeader");

    });

    $('#clearNearbySubmit').click(function() {

        $('#nearAddress').val("");
        $('#nearRadius').val("");
        $('#nearbyError').hide();

        if(circle != null) {
            circle.setMap(null);

        }

        if(circleFilter) {
            showDistance = false;
            circleFilter = false;
            fUNQ164();
        }
    });

    $('#nearbySubmit').click(function() {

        // circleFilter = false;
        var message = "";
        var radius = $('#nearRadius').val();
        var units = $('input[name=distType]:checked').val();
        var showCircle  = $('#showCircle').is(':checked');
         showDistance = $('#showDistance').is(':checked');
        var location = $('#nearAddress').val();
        var displayUnits = "KM";

        var nearByError = $('#nearbyError');

        if(!$.isNumeric(radius) || radius <= 0)
        {
             message = "Invalid radius: " + radius;
            nearByError.html(message);
            nearByError.show();
            return;
        }

        if(location.trim().length == 0) {
             message = "Error: Blank location.";
            nearByError.html(message);
            nearByError.show();
            return;
        }

        if(units == "mi") {
            radius *= 1.6093;
            displayUnits = "miles";

        }
        // get the radius in meters
        radius *= 1000;



        if(mapGeocoder == null)
            mapGeocoder = new google.maps.Geocoder();

        var geoSuccess = true;

        mapGeocoder.geocode({
            'address': location
        }, function (results, status) {


            if(status == google.maps.GeocoderStatus.OK) {

                var circleCenter = results[0].geometry.location;
                gMap.setCenter(results[0].geometry.location);

                if(circle != null) {
                    circle.setMap(null);
                }

                circle = new google.maps.Circle({
                    clickable: false,
                    draggable : false,
                    editable : false,
                    fillColor : "blue",
                    fillOpacity : 0.2,
                    strokeColor : "blue",
                    strokeOpacity : 0.4,
                    radius: radius,  // distance in meters
                    map: gMap,
                    center:  circleCenter,
                    visible: showCircle
                });


                gMap.fitBounds(circle.getBounds());

                circleFilter = true;
                circleRadius = radius;

                for(var i = 0; i < gMapMarkers.length; i++) {

                    if(gMapMarkers[i] != null) {

                        if(circle.getBounds().contains(gMapMarkers[i].getPosition()) ) {

                            gMapMarkers[i].distanceM = google.maps.geometry.spherical.computeDistanceBetween(circleCenter, gMapMarkers[i].getPosition());

                            if(showDistance) {

                                if(units == "mi")
                                    gMapMarkers[i].displayDistance = gMapMarkers[i].distanceM * .00062137;
                                else
                                    gMapMarkers[i].displayDistance = gMapMarkers[i].distanceM * .001;


                                // fix the decimal display : 3 decimals for less than 1, 2 for up to 100, and 0 otherwise
                                if(  gMapMarkers[i].displayDistance < 1)
                                {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed(3);
                                }
                                else if(gMapMarkers[i].displayDistance < 100) {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed(2);
                                }
                                else {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed();
                                }

                                gMapMarkers[i].displayDistance += " " + displayUnits;

                            }

                        }

                    }

                }

                fUNQ164();

            }
            else {
                geoSuccess = false;
            }

        });



        if(geoSuccess)
            nearByError.hide();
        else {
            nearByError.html("Problem find the location: " + location);
            nearByError.show();
        }




    });


    $('#dirAddress1').click(function() {
        activeDirTextBox = 1;
    });

    $('#dirAddress2').click(function() {
        activeDirTextBox = 2;
    });


}

function fUNQ134() {
    $('#left').show();
    $('#moreOptionsBlank').show();
    $('#moreOptions').hide();


    if(inIframe || tabletDevice) {

        $('#map').css('left', 300);

    }

    else {
        var div = $('#mapContainer');

        if(!div.hasClass("padLeft"))
        {
            div.addClass("padLeft");
        }
    }
    google.maps.event.trigger(gMap, 'resize');

}


function fUNQ135() {


    $('#leftDirDisplay').show();
    $('#leftNearbyDisplay').hide();

    var dirTab = $('#dirTabDisplay');
    if(!dirTab.hasClass("activeDirHeader"))
    {
        dirTab.addClass("activeDirHeader");
    }

    $('#nearbyTabDisplay').removeClass("activeDirHeader");
}

function fUNQ136(markerM) {

    fUNQ134();
    fUNQ135();


    activeDirTextBox = 1;
    fUNQ137(markerM);


    activeDirTextBox = 2;
    $('#dirAddress2').val("");

}

function fUNQ137(markerM) {

    if(showMoreOptions && activeDirTextBox > 0 && $('#dirTabDisplay').is(':visible')) {

        var startLocation = "Marker " + markerM.idx + 1;
        var markerAddr = fUNQ162(dataLines[markerM.idx], " ", true);

        if(markerAddr.length > 0)
            startLocation = markerAddr;
        else if (fUNQ178(mObject.title) && dataLines[markerM.idx][mObject.title] != "")
        {
            startLocation =  dataLines[markerM.idx][mObject.title];
        }

        $('#dirAddress' + activeDirTextBox).val(startLocation);

    }


}


function fUNQ138(start, end) {

    if( directionsService == null )
        directionsService = new google.maps.DirectionsService();

    if( directionsDisplay == null )           {
        directionsDisplay = new google.maps.DirectionsRenderer({suppressMarkers: true, suppressInfoWindows: true});
        directionsDisplay.setMap(gMap);

    }

    if(start && end) {

        var request = {
            origin:start,
            destination:end,
            travelMode: google.maps.TravelMode.DRIVING
        };

        directionsService.route(request, function(result, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setMap(gMap);
                directionsDisplay.setPanel(document.getElementById('dirTextDiv'));
                directionsDisplay.setDirections(result);
            }
            else {
               // ignorePagingEvent = true;
                var dirError =  $('#dirError');
                dirError.html('Could not get directions: ' + status);
                dirError.show();
            }
        });

    }

}

function fUNQ139(resultArr, status) {


}

function fUNQ140() {

    // This is the same as the show more options html with the "left" div removed!
    return             '   <div id="left_header" class="dirHeader"> ' +
        '       <a id="dirTabDisplay" style="margin-left: 5px;" class="activeDirHeader">Directions</a> ' +
        '       <a id="nearbyTabDisplay">Nearby</a> ' +
        '       <img id="hideOptions" src="/img/hide_options.png" style="float: right; margin-right: 10px;  cursor: pointer;"> ' +
        '   </div> ' +
        '   <div id="leftDirDisplay" class="leftDiv" style="background-color: white;"> ' +
        '       <p> <label id="dirAddress1_label" for="dirAddress1" class="optionLabel">Start: </label><input id="dirAddress1"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '       <p> <label id="dirAddress2_label" for="dirAddress2" class="optionLabel">End: </label> <input id="dirAddress2"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '     <!--  <p><a href="#">add location</a></p> --> ' +

        '       <p style="text-align: right; margin-right: 50px;"><INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /> ' +
        '       <INPUT id="clearDirSubmit" value="Clear" TYPE="SUBMIT" /> </p>  ' +
        '       <div id="dirError" style="display: none; "></div>  ' +
        '       <div id="dirTextDiv" style="padding: 10px; height: 445px; overflow: auto;"></div>  ' +

        '   </div>  ' +
        '   <div id="leftNearbyDisplay" class="leftDiv" style="display: none;">  ' +
        '       <p><label id="nearAddress_label" for="nearAddress" class="optionLabel">Location: </label><input id="nearAddress"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '       <p> <label id="nearRadius_label" for="nearRadius" class="optionLabel">Radius: </label><input id="nearRadius"  type="text"  SIZE=3 MAXLENGTH=3 style="text-align: right;" autocomplete="off"> ' +
        '           <label class="radio" style=" text-align: left;"><input type="radio" name="distType" value="mi" id="distMi" checked  autocomplete="off">miles  </label> ' +
        '           <label class="radio" style="width: 400px;  text-align: left;"><input type="radio" name="distType" value="km"  id="distKM" > km </label></p> ' +
        '       <p><label class="checkboxText"><input type="checkbox" name="showCircle" value="false"  id="showCircle"   class="checkLabel" >show circle</label></p> ' +
        //      '      <p><label  class="checkboxText" ><input type="checkbox" name="showDistance" value="false"  id="showDistance""  class="checkLabel"><span class="checkboxText">show distance</span></label></p> ' +

        '       <p style="text-align: right; margin-right: 50px;"><INPUT id="nearbySubmit" value="Find Nearby" TYPE="SUBMIT" /> ' +
        '          <INPUT id="clearNearbySubmit" value="Clear" TYPE="SUBMIT" /> </p> ' +
        '      <div id="nearbyError" style="display: none; "></div> ' +
        '  </div> ' ;

}

function fUNQ141() {

    var descriptionDiv = "";

    if(userSettings.description != null && userSettings.description.length > 0) {
        descriptionDiv += '<div id="descriptionDiv"  style="position:fixed;left:0;right:0; bottom:0px; font-size: .8em;"> ' +  userSettings.description + '</div>'
    }

    var showOptionsHtml = "";

    if(showMoreOptions) {
        showOptionsHtml =                 '<div id="left" class="column" style="background-color: white; width: 300px; display: none; margin-left: 0; "> ' +
            '   <div id="left_header" class="dirHeader"> ' +
            '       <a id="dirTabDisplay" style="margin-left: 5px;" class="activeDirHeader">Directions</a> ' +
            '       <a id="nearbyTabDisplay">Nearby</a> ' +
            '       <img id="hideOptions" src="/img/hide_options.png" style="float: right; margin-right: 10px;  cursor: pointer;"> ' +
            '   </div> ' +
            '   <div id="leftDirDisplay" class="leftDiv" style="background-color: white;"> ' +
            '       <p> <label id="dirAddress1_label" for="dirAddress1" class="optionLabel">Start: </label><input id="dirAddress1"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '       <p> <label id="dirAddress2_label" for="dirAddress2" class="optionLabel">End: </label> <input id="dirAddress2"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '     <!--  <p><a href="#">add location</a></p> --> ' +

            '       <p style="text-align: right; margin-right: 50px;"><INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /> ' +
            '       <INPUT id="clearDirSubmit" value="Clear" TYPE="SUBMIT" /> </p>  ' +
            '       <div id="dirError" style="display: none; "></div>  ' +
            '       <div id="dirTextDiv" style="padding: 10px; height: 445px; overflow: auto;"></div>  ' +

            '   </div>  ' +
            '   <div id="leftNearbyDisplay" class="leftDiv" style="display: none;">  ' +
            '       <p><label id="nearAddress_label" for="nearAddress" class="optionLabel">Location: </label><input id="nearAddress"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '       <p> <label id="nearRadius_label" for="nearRadius" class="optionLabel">Radius: </label><input id="nearRadius"  type="text"  SIZE=3 MAXLENGTH=3 style="text-align: right;" autocomplete="off"> ' +
            '           <label class="radio" style=" text-align: left;"><input type="radio" name="distType" value="mi" id="distMi" checked  autocomplete="off">miles  </label> ' +
        '           <label class="radio" style="width: 400px;  text-align: left;"><input type="radio" name="distType" value="km"  id="distKM" > km </label></p> ' +
        '       <p><label class="checkboxText"><input type="checkbox" name="showCircle" value="false"  id="showCircle"   class="checkLabel" >show circle</label></p> ' +
  //      '      <p><label  class="checkboxText" ><input type="checkbox" name="showDistance" value="false"  id="showDistance""  class="checkLabel"><span class="checkboxText">show distance</span></label></p> ' +

            '       <p style="text-align: right; margin-right: 50px;"><INPUT id="nearbySubmit" value="Find Nearby" TYPE="SUBMIT" /> ' +
            '          <INPUT id="clearNearbySubmit" value="Clear" TYPE="SUBMIT" /> </p> ' +
            '      <div id="nearbyError" style="display: none; "></div> ' +
            '  </div> ' +

        ' </div> ';

    }


   return '<div id="mapHeader" style="left:0;right:0; z-index:100; top:0px; position: fixed; min-height: 45px;"> ' +
       ' <div id="searchDiv" class="search-query"> ' +
       '      <input id="searchBox" class="search-query span2" type="text" placeholder="Search"  onkeypress="return handleSearchSubmit(event)" value=""><img class="search-query" src="/img/search.png" onclick="fUNQ190();"> ' +
       '     <a href="http://www.easymapmaker.com" target="_blank"><img class="search-query" src="/img/small_logo2.png" Title="Map made with EasyMapMaker.com" onclick="fUNQ190();"></a> ' +

       ' </div> ' +

       ' <div id="filtersDiv" ></div> ' +

       '</div> ' +

       '<div id="mapContainer" style="position:absolute;left:0;right:0; top:0px;bottom:0px;"> ' +
       '    <div id="map" ' +
       '        style="position:absolute;left:0;right:0; top:0px;bottom:0px;"></div> ' +
       showOptionsHtml +
       '   <div id="groupsOverDiv" style="  text-align: center;     width: 100%; -webkit-text-size-adjust: none;"> ' +
       '       <div id="groupChecksDiv" class="groupsDivPC" style="left:0;right:0; z-index:100; bottom:0px; position: fixed; display: inline-block;"> ' +

       '        </div> ' +
       '   </div> ' + descriptionDiv +



       '</div> ' ;


}


// should probably only do this for more than 100 markers.
function fUNQ142() {


    if(gMapMarkers.length < 500)
        return;


    var bounds = gMap.getBounds();

    // Call you server with ajax passing it the bounds

    // In the ajax callback delete the current markers and add new markers

    //
    // make this work for grouping/clusting by keeping an index of the visible markers and have a boolean
    // indicating whether all the markers are visible


    var i;

  //  if(mObject.clustering)
   //     markerCluster.clearMarkers();

    // TODO: also, do the paging thing for this as well

    if(selectedMarkers.length > 0 || selectedMarkerSet) {


        for( i = 0; i < selectedMarkers.length; i++) {

            if(selectedMarkers[i] < gMapMarkers.length) {

                if(gMapMarkers[selectedMarkers[i]] == null )
                    continue;

                if(  bounds.contains(gMapMarkers[selectedMarkers[i]].getPosition() && gMapMarkers[selectedMarkers[i]].getMap() == null ))       {

                        gMapMarkers[selectedMarkers[i]].setMap(gMap);

                }
                else if(  gMapMarkers[selectedMarkers[i]].getMap() != null){
                    gMapMarkers[selectedMarkers[i]].setMap(null);

                  //  if(mObject.clustering)
                  //      hideClusterMarkers.push(gMapMarkers[selectedMarkers[i]]);
                }
            }

        }


    }
    else {

        for( i = 0; i < gMapMarkers.length; i++) {


            if(gMapMarkers[i] == null )
                continue;

            if(  bounds.contains(gMapMarkers[i].getPosition()) && gMapMarkers[i].getMap() == null)   {

                    gMapMarkers[i].setMap(gMap);
            }
            else if ( gMapMarkers[i].getMap() != null ){

                // TODO: verify what this is supposed to do, probably something with the open window
                if(openWindow != null && openMarker.idx == i)
                    continue;

                gMapMarkers[i].setMap(null);

            }
        }


    }


}

// TODO: zoom into the markers that are visible on a search change, filter change or group change
// This assumes that the markers that don't match the result are already hidden!
function fUNQ143(markerList) {

    var preZoom = gMap.getZoom();


    var latLngBounds = null;

    var extendedBoundsCount = 0;

    var showClusterMarkers = [];

    if(openWindow != null      )
    {
        openWindow.close();
        openWindow = null;
        openMarker = null;
    }

    if(mObject.clustering) {

        markerCluster.clearMarkers();
    }

    // no markers, so leave the zoom level as is and
    // clear other stuff from the page.
    if(markerList.length==0)       {

//        if(mObject.clustering) {
//
//            clusterer.clearMarkers();
//        }

        fUNQ179();

        return;
    }


    for(var i = 0; i < markerList.length; i++) {

        var idx = markerList[i];

        if(idx < gMapMarkers.length) {

            if(gMapMarkers[idx] == null )  {
                continue;
            }


             if(latLngBounds == null){

                 latLngBounds = new google.maps.LatLngBounds(gMapMarkers[idx].getPosition(), gMapMarkers[idx].getPosition());
             }
            else {

                 latLngBounds.extend(gMapMarkers[idx].getPosition());
                 extendedBoundsCount++;
             }

            if(mObject.clustering) {
                showClusterMarkers.push(gMapMarkers[idx])  ;
            }

        }

    }


    // don't adjust the map when there is a circle filter, let the user change the map if they want
    // only change it if there is 1 item (as in the code below)
    if(!circleFilter) {

        gMap.fitBounds(latLngBounds);

        gMap.setCenter(latLngBounds.getCenter());
    }



    //    (17 looks like a good level!)
    if(extendedBoundsCount == 0 ) {

        // without this, the map would zoom to 21 (right on a building, yikes).

        if(preZoom < 17)
         gMap.setZoom(17);
        else {
            gMap.setZoom(preZoom );
        }
    }



    if(mObject.clustering) {

     //   markerCluster.clearMarkers();
        markerCluster.addMarkers(showClusterMarkers);
    }


    fUNQ180();
}

function fUNQ144(controlDiv, map, optionsArray, selectedOption, googleOptionType) {

    controlDiv.style.padding = '5px';

    var controlUI = document.createElement('div');
    controlUI.align = 'center';

    controlDiv.appendChild(controlUI);


    // Set CSS for the control interior.
    var controlSelect = document.createElement('select');
    controlSelect.name = 'MapStyle';
    controlSelect.id = 'MapStyle';
    controlUI.appendChild(controlSelect);

    for (var i = 0; i < optionsArray.length; i++) {

        var controlOption = document.createElement('option');
        controlOption.value = optionsArray[i];
        controlOption.innerHTML = optionsArray[i];

        if (selectedOption.toLowerCase() == optionsArray[i].toLowerCase()) {
            controlOption.selected = 'selected';
        }

        controlSelect.appendChild(controlOption);

    }

    // Setup the click event listeners: simply set the map to Chicago.
    google.maps.event.addDomListener(controlSelect, 'change', function () {

        for (var i = 0; i < optionsArray.length; i++) {
            if (this.value == optionsArray[i]) {
                map.setMapTypeId(googleOptionType[i]);
            }
        }


    });


}


function addMarkers(latIdx, lngIdx,  dataLines) {

  if(dataLines.length == 0)
    return;

  //var clustering = true;

  var latLng = new google.maps.LatLng(dataLines[0][latIdx],dataLines[0][lngIdx]);

  var latLngBounds =  new google.maps.LatLngBounds(latLng, latLng);


  for(var i = 0; i < dataLines.length; i++) {

     latLng = new google.maps.LatLng(dataLines[i][latIdx],dataLines[i][lngIdx]);

        var color = IMG_LIST[0];
        var hexColor = IMG_HEX_COLORS[0];

        var iconUrl =  '/marker_images/image.png';

        if(mObject.markerImageIdx != undefined  && mObject.markerImageIdx.length >= i &&
            mObject.markerImageIdx[i] >=0 &&  mObject.markerImageIdx[i] != null) {

            if( mObject.markerImageIdx.length > 0  && mObject.markerImageIdx[i] < IMG_LIST.length)            {

                iconUrl =       IMAGE_PATH + IMG_LIST[mObject.markerImageIdx[i]] + IMG_FILE_ENDING;
                //  marker.setIcon( IMAGE_PATH + IMG_LIST[mObject.markerImageIdx[i]] + IMG_FILE_ENDING );
              color =  IMG_LIST[mObject.markerImageIdx[i]];
                hexColor =   IMG_HEX_COLORS[mObject.markerImageIdx[i]];
            }
            // otherwise, use the default icon

            // marker.setIcon( IMAGE_PATH + IMG_LIST[i] + IMG_FILE_ENDING );

        }

        var image = {
           url: iconUrl,
            size: new google.maps.Size(20,34),
            origin: new google.maps.Point(0,0),
            anchor: new google.maps.Point(10,34)
        };

        var shadow = {
            url: '/marker_images/shadow.png',
            size: new google.maps.Size(40,34),
            origin: new google.maps.Point(0,0),
            anchor: new google.maps.Point(10,34)
        };


    var marker = new google.maps.Marker({  position:  latLng,
                                map: gMap ,
                        icon: image,
                        shadow: shadow,
                        shape: DEFAULT_SHAPE,
                        zIndex: dataLines.length - i    });


        // TODO: tooltip for title, see http://googlemapapitutorial.com/customizedtooltip.jsp
      /*  if(fUNQ178(mObject.title))
        {
            marker.setTitle(dataLines[i][mObject.title]);
        }
        */
    
    latLngBounds.extend(latLng);

    marker.idx = i;
        marker.color = color;
        marker.hexColor = hexColor;


    if(editMap) {
      marker.setDraggable(true);    
    }

    fUNQ145(marker, i, dataLines[i]);

    gMapMarkers.push(marker);

    if(editMap) {
      google.maps.event.addListener(marker, "dragend", function() {
        fUNQ160(this, latIdx, lngIdx);  

      } );
    }
  }

    // TODO: in the future, use some calculation for the grid size and zoom level based on marker density
    if(mObject.clustering)   {
        markerCluster = new MarkerClusterer(gMap, gMapMarkers,
         {
             calculator:  myCalculator,
             maxZoom: CLUSTER_ZOOM_LEVEL,
             averageCenter: true,
             gridSize: 65
         }
     );
    }

  gMap.fitBounds(latLngBounds);

  gMap.setCenter(latLngBounds.getCenter());

}



function fUNQ145(markerM, markerIdx, dataItems) {
    "use strict";
    var message = fUNQ158( dataItems);


    if(mObject.displayDataOnPage && !mobileDevice && !inIframe && !tabletDevice)  {

        var simpleMessage = fUNQ157(dataItems);

        markerDescriptions[markerDescriptions.length] = {message: simpleMessage, markerIdx: markerIdx};
    }

// TODO: look at adjusting the top on parent div to 26 pixels (should look at other browsers for this as well!)
    message = '<div id="markerDiv" class ="markerDescriptionReg">' + message ;

  if(mobileDevice) {

      message = '<div id="markerDiv" style="overflow-y:scroll; font-size:10pt; top: 26px; font-family:arial; font-weight:bold;">' + message ;

  }


// old width: width: 450px;

    if(editMap) {

        message = message + '<a id="removeMarker">Remove Pin</a> ' ;
    }

    message = message + '</div>';

    var infowindow = new google.maps.InfoWindow({
        content: message,
        size: new google.maps.Size(50, 50)  
    });

    // openWindow.setContent(message);

  if(mobileDevice) {
//    infowindow.setOptions({maxWidth : 150 });
  }
    else {

      //  infowindow.setOptions({maxWidth : 400 });
    }


    google.maps.event.addListener(markerM, "click", function () {



        if (openWindow != null && openWindow != infowindow) {
            openWindow.close();
        }

        if(mObject.clustering && markerM.getMap() !== gMap )
        {
            gMap.setZoom(15);
            markerCluster.repaint();
        }

        samePosMarkers.length = 0;
        for(var i = 0; i < dataLines.length && i < gMapMarkers.length ; i++ ) {

            if( gMapMarkers[i] == null)
                continue;

            if(i != markerM.idx && dataLines[i].length  && gMapMarkers[i].idx >= 0 &&  gMapMarkers[i].getMap() != null &&
                fUNQ183(dataLines[markerM.idx][mObject.lat], dataLines[markerM.idx][mObject.lng],dataLines[i][mObject.lat], dataLines[i][mObject.lng] ))   {
                samePosMarkers[samePosMarkers.length]  =  gMapMarkers[i].idx;
            }

        }
        if(samePosMarkers.length > 0) {
            samePosMarkers.unshift(markerM.idx);

             currentPageMarkerNum = 1;
             nextPageMarkerNum = 1 + ITEMS_PER_PAGE;
             previousPageMarkerNum = 1;

        }

        // set the messageback to what it was if it changed.
        if(showDirections || samePosMarkers.length > 0) {
            infowindow.setContent(message);
        }

        ignorePagingEvent = false;

        openMarker = markerM;
        infowindow.open(gMap, markerM);
        openWindow = infowindow;

        // set the address for the direction text box
        fUNQ137(markerM);

        if(editMap || samePosMarkers.length > 0  || showDirections) {
            google.maps.event.addListenerOnce(infowindow, 'domready', function () {

                //jQuery code here

                if(samePosMarkers.length > 0 && !ignorePagingEvent) {
                    fUNQ149() ;
                }

               if(showDirections) {

                    fUNQ153(markerM, openWindow) ;
                }

                if(editMap) {


                    fUNQ146(markerM, openWindow)    ;
                }   //   end  if(editMap)
            });

        } // end  if(editMap || samePosMarkers.length > 0
    });



    google.maps.event.addListener(infowindow, "closeclick", function () {
        if (openWindow == infowindow) {
            openWindow = null;
        }
    });


}

function fUNQ146(markerM , infowindow) {

    $('#removeMarker').click(function () {

        // confirmation that the user wants to remove the marker.


        var confRes = confirm("Remove the marker?");


        if(confRes == false)
            return;


        if(samePosMarkers.length > 0) {
            markerM =  gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;

        }

        infowindow.close();
        markerM.setVisible(false); // to do, should remove the marker from other places as well

        markerM.setMap(null);

        removedMarkers.push(markerM.idx);
        dataLines[markerM.idx].length = 0;

        gMapMarkers[markerM.idx] = null;

    });

}


function fUNQ147() {

    openMarker =   gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;
    var markerTemp = gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;

   // var message = fUNQ158(mObject.headerDisplayOrderIdxs, dataLines[markerTemp.idx], mObject.columnHeaderArray);

    var message = fUNQ158(dataLines[markerTemp.idx]);

    message = '<div id="markerDiv" class="markerDescriptionReg">' + message + '</div>.';

   // TO DO: look at adjusting the top on parent div to 26 pixels (should look at other browsers for this as well!)
 //   message = '<div id="markerDiv" style="width: 450px; font-size:10pt; top: 26px; font-family:arial; font-weight:bold;">' + message ;

    if(editMap) {

        message = message + '<a id="removeMarker">Remove Pin</a> ' ;
        // removed the javascript:void0); from the href=""
        // the removal works.

        // TODO: may need to do something to support the call to remove markers when paging (like for handle directions)
        // may need to add something to handle teh
    }

  //  message = message + '</div>';
  //  $('#markerDiv').html(message);
    ignorePagingEvent = true;
    openWindow.setContent(message);

    fUNQ153(openMarker, openWindow) ;


}


function fUNQ148() {

    var pagingMarker = $('#markerPaging');
    if(pagingMarker.length > 0 ){
        pagingMarker.remove();
    }
}

function fUNQ149() {

    var pagingDiv = $('#markerDiv').parent().parent().parent();
    var pagingMarker = $('#markerPaging');

    var pageDisplay =            fUNQ152();
    var pageHtml = '<div id="markerPaging" class="pagination marker-pagination-centered">' + pageDisplay +
        '</div>';


    if(pagingMarker.length > 0 ){

        pagingMarker.html(pageDisplay);
    }
    else {
        pagingDiv.prepend(pageHtml);
    }

    fUNQ150() ;


}

function fUNQ150() {


    $('#markerPaging li').click ( function() {
        var elementId = $(this).attr('id');

        if( $(this).text() != currentPageMarkerNum) {

            $('#markerPaging li').unbind('click');

            fUNQ151(elementId, $(this).text());
        }
    } );

}

function fUNQ151(markerId, markerNumber) {

    if(markerId == "pgPrevLI") {
        currentPageMarkerNum = previousPageMarkerNum;

        nextPageMarkerNum = currentPageMarkerNum + 1;
    }

    else if(markerId == "pgNextLI") {
        currentPageMarkerNum = nextPageMarkerNum;

        previousPageMarkerNum = currentPageMarkerNum -1;
    }
    else {
        currentPageMarkerNum = markerNumber;
    }

    fUNQ147();

    $('#markerPaging').html(fUNQ152());

    fUNQ150() ;
}

function fUNQ152() {

    var lis = "";
    var endLis = "";

    if(samePosMarkers.length > ITEMS_PER_PAGE && currentPageMarkerNum > ITEMS_PER_PAGE) {
        lis = '<li id="pgPrevLI">&lt;</li>';
    }

    if(samePosMarkers.length > ITEMS_PER_PAGE && nextPageMarkerNum > currentPageMarkerNum ) {
        endLis = '<li id="pgNextLI">&gt;</li>';
    }

    var startingMarker = ITEMS_PER_PAGE * Math.floor( (currentPageMarkerNum -1) / ITEMS_PER_PAGE);

    for (var i = startingMarker; i < startingMarker + ITEMS_PER_PAGE && i < samePosMarkers.length; i++)
    {

        var displayNumber = i + 1;

        if(displayNumber  == currentPageMarkerNum) {
            lis = lis + '<li id="pgli' + displayNumber + '" class="active">'+ displayNumber  +'</li>'     ;
        }
        else {
            lis = lis + '<li id="pgli' + displayNumber + '">' + displayNumber  +'</li>';
        }

    }

    lis = lis + endLis ;
    return '<ul>' + lis + '</ul>';
}

function fUNQ153 (markerM, infoW) {

   // var startMarkerExists = true;
    /*

     from_htmls[i] = html + '<br>Directions: <a href="javascript:tohere(' + i + ')">To here<\/a> - <b>From here<\/b>' +
     '<br>End address:<form action="javascript:getDirections()">' +
     '<input type="text" SIZE=40 MAXLENGTH=40 name="daddr" id="daddr" value="" /><br>' +
     '<INPUT value="Get Directions" TYPE="SUBMIT"><br>' +
     'Walk <input type="checkbox" name="walk" id="walk" /> &nbsp; Avoid Highways <input type="checkbox" name="highways" id="highways" />' +
     '<input type="hidden" id="saddr" value="'+name+"@"+ point.lat() + ',' + point.lng() +
     '"/>';

     */


    $('#toDir').click( function(){


        // handle the directions in the more options window
        if (!mobileDevice && showMoreOptions) {

            fUNQ136(openMarker);

            return;
        }



        var description = fUNQ154();

    ignorePagingEvent = true;
    //   infoW.close();
    // openDirectionWindow(markerM, desc)      ;
        fUNQ148();
    infoW.setContent(description);
    fUNQ155(openMarker, infoW);

    }    );


}

function fUNQ154()
{

    var markerM = openMarker;


    var startLocation = "Here";

    var markerAddr = fUNQ162(dataLines[markerM.idx], " ", true);

    if(markerAddr.length > 0)
        startLocation = markerAddr;
    else if (fUNQ178(mObject.title) && dataLines[markerM.idx][mObject.title] != "")
    {
        startLocation =  dataLines[markerM.idx][mObject.title];
    }

    var description = '<div id="directions"><table>' +
        '<tr>'    +
        '<td><label>Start</label></td>  ' +
        ' <td><input type="text" SIZE=30 MAXLENGTH=200 name="startAddr" id="startAddr" value="' + startLocation + '" readonly />  ' +
        ' <INPUT type="hidden" id="markerStart" value="' + markerM.idx + '" /></td> ' +
        '<td rowspan="2"><img src="/img/reverse_img.png" Title="Get Reverse Directions" onclick="fUNQ159();"></td> ' +
        '</tr> ' +
        '<tr>' +
        '<td align="right"><label>End</label></td>' +
        '<td><input type="text" SIZE=30 MAXLENGTH=200 name="endAddr" id="endAddr" value="" />' +
        '   <INPUT type="hidden" id="markerEnd" value="" /></td>' +
        '</tr>' +
        ' <tr>' +
        '     <td colspan="2" align="right"> <INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /></td><td></td>' +
        ' </tr>' +
        '</table>' +
        '<div id="dirError"></div></div>' ;

    return description;

}

function fUNQ155(markerM, infoW)    {


    $('#directionSubmit').click( function(){


        if( directionsService == null )
            directionsService = new google.maps.DirectionsService();

        if( directionsDisplay == null )           {
            directionsDisplay = new google.maps.DirectionsRenderer({suppressMarkers: true});
            directionsDisplay.setMap(gMap);

        }

        var start = "";
        var end = "";
        var markerStartSelector = $('#markerStart');
        var markerEndSelector =   $('#markerEnd');


        if(markerStartSelector.length > 0 && markerStartSelector.val() && parseInt(markerStartSelector.val(), 10) == markerM.idx ) {
            start =    markerM.getPosition();
            end =         $('#endAddr').val();

        }
        else if(markerEndSelector.length > 0 && markerEndSelector.val() && parseInt(markerEndSelector.val(), 10) == markerM.idx ) {
            start =     $('#startAddr').val();
            end =       markerM.getPosition();

        }

        if(start && end) {

            var request = {
                origin:start,
                destination:end,
                travelMode: google.maps.TravelMode.DRIVING
            };

            directionsService.route(request, function(result, status) {
                if (status == google.maps.DirectionsStatus.OK) {
                    infoW.close();
                    openWindow = null;
                   // fUNQ156( result, status, startMarkerExists,markerM );
                   directionsDisplay.setDirections(result);
                }
                else {
                    ignorePagingEvent = true;
                    $('#directions').html('Could not get directions: ' + status);
                }
            });

        }

    }  );
}

/*
function fUNQ156(response, status, startMarkerExists, markerM) {

    var bounds = new google.maps.LatLngBounds();
    var route = response.routes[0];
 //   var summaryPanel = document.getElementById("directions_panel");
 //   var detailsPanel = document.getElementById("direction_details");
    startLocation = new Object();
    endLocation = new Object();

    var polyline = new google.maps.Polyline({
        path: []
    });

    var path = response.routes[0].overview_path;
    var legs = response.routes[0].legs;
    for (i=0;i<legs.length;i++) {
        if (i == 0  && !startMarkerExists) {
            startLocation.latlng = legs[i].start_location;
            startLocation.address = legs[i].start_address;
       //     startLocation.marker = createMarker(legs[i].start_location,"start",legs[i].start_address,"green");
        }
        endLocation.latlng = legs[i].end_location;
        endLocation.address = legs[i].end_address;


        var steps = legs[i].steps;
        for (j=0;j<steps.length;j++) {
            var nextSegment = steps[j].path;
//            detailsPanel.innerHTML += "<li>"+steps[j].instructions;
//            var dist_dur = "";
//            if (steps[j].distance && steps[j].distance.text) dist_dur += "&nbsp;"+steps[j].distance.text;
//            if (steps[j].duration && steps[j].duration.text) dist_dur += "&nbsp;"+steps[j].duration.text;
//            if (dist_dur != "") {
//                detailsPanel.innerHTML += "("+dist_dur+")<br /></li>";
//            } else {
//                detailsPanel.innerHTML += "</li>";
//
//            }

            for (k=0;k<nextSegment.length;k++) {
                polyline.getPath().push(nextSegment[k]);
                bounds.extend(nextSegment[k]);



            }
        }
    }

    polyline.setMap(gMap);
    gMap.fitBounds(bounds);
    if(!startMarkerExists) {
        // TODO: do something with this!!!
      //  endLocation.marker = createMarker(endLocation.latlng,"end",endLocation.address,"red");
    }

}
*/

function fUNQ157(dataItem) {


    var distanceDisplay = '';

    if(showMoreOptions) {
        distanceDisplay = ' <span class="noDistDisplay">&nbsp; (##dist##)</span>'
    }

    var title = "";
    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

            title = '<div><b>' + dataItem[mObject.title]+  distanceDisplay +  '</b></div>';

    }

    if(title.length > 0)
        distanceDisplay = '';

    var address = fUNQ162(dataItem, distanceDisplay + "<br>", true);


    if(address != "") {
        if(title.length == 0)
        {
            address = '<b>'+address + '</b>';
        }

            address    = '<div>' + address +   '</div>';
    }


    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {

                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;

                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }

            }
        }

    }


    var firstHalf = title + address + descDisplay;

    firstHalf += fUNQ29(dataItem, title)  ;

    return firstHalf;
}

function fUNQ158(dataItem) {

    var title = "";
    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

        if(fUNQ178(mObject.web)  && dataItem[mObject.web] != "")  {
            title = '<div><a href="'+urlizeUrl(dataItem[mObject.web])+ '" target="_blank">'+ dataItem[mObject.title] + '</a></div>';
        }
        else
            title = dataItem[mObject.title];

    }
    var address = fUNQ162(dataItem, "<br>", true);

    if(address != "") {

        if(showDirections) {
            address    = '<div><a id="toDir" >' + address +   '</a></div>';
        }
        else {
        address    = '<div>' + address +   '</div>';

        }
    }
    else if(showDirections) {
        address = '<div><a id="toDir" >Directions</a></div>';
    }

    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {


                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }
            }
        }

    }


    var firstHalf = title + address + descDisplay;


    firstHalf +=        fUNQ29(dataItem, title)  ;
    return firstHalf;
}




function fUNQ159() {

    var myDirs = $('#directions');

    if($this.length > 0) {

        var markerEndId = myDirs.find('#markerEnd');
        var markerStartId = myDirs.find('#markerStart');
        var startAddr = myDirs.find('#startAddr');
        var endAddr = myDirs.find('#endAddr');

        var tempEndId = "";
        var tempEndAddr = "";

        if(markerEndId.length > 0) {
            tempEndId = markerEndId.val();
        }
        if(endAddr.length > 0) {
            tempEndAddr = endAddr.val();
        }


        if(startAddr.prop("readonly"))
        {
            startAddr.prop("readonly",  false);
            endAddr.prop("readonly",  true);
        }
        else if(endAddr.prop("readonly")) {
            startAddr.prop("readonly",  true);
            endAddr.prop("readonly",  false);
        }



        markerEndId.val(markerStartId.val());
        endAddr.val(startAddr.val());

        markerStartId.val(tempEndId);
        startAddr.val(tempEndAddr);
    }

}



function fUNQ160(markerM, latIdx, lngIdx) {
  dataLines[markerM.idx][latIdx] = markerM.getPosition().lat().toFixed(6);
  dataLines[markerM.idx][lngIdx] = markerM.getPosition().lng().toFixed(6);

    fUNQ161();

}

function fUNQ161() {

   if( fUNQ65 (redrawTextArea) )
   {
       redrawTextArea() ;
   }

}

// do stuff with the address, city, state, zip
function fUNQ162(line, addrLineBreak, display) {


    var addr = fUNQ177(line, mObject.address, "", display) ,
        city =  fUNQ177(line, mObject.city, "", display) ,
        state =  fUNQ177(line, mObject.state, "", display) ,
        zip =    fUNQ177(line, mObject.zip, "", display) ,
        country = fUNQ177(line, mObject.country, "", display) ;


    // this holds line 2; addr holds line 1
    var retAddr ;

    retAddr = (city.length > 0) ? city : "";
    retAddr +=   ((city.length >  0 && state.length > 0 ) ? ", " + state : state );
    retAddr += ((retAddr.length > 0 && zip.length >  0) ? " " + zip : zip );
    retAddr += ((retAddr.length > 0 && country.length >  0) ? " " + country : country );


    if(addrLineBreak != undefined && addr.length > 0 && retAddr.length > 0)
        return addr + addrLineBreak + retAddr;

    if(addr.length > 0 && retAddr.length > 0)
        return addr + " " + retAddr;

    return (addr.length > 0 ? addr : retAddr);

}

function fUNQ163() {

    var groupDiv =  $('#groupChecksDiv');

    // don't do anything if there are not at least 2 groups
       if(mObject.sortedGroupKeys.length < 2)         {

           if(groupDiv.length > 0 ) {

               groupDiv.hide();
           }

           return;
       }


    var groupLabel = mObject.columnHeaderArray[ mObject.group] + ": " ;

    var allGroupBoxes = "";

    for(var groupName in mObject.groupImageHash)    {

        if(mObject.groupImageHash.hasOwnProperty(groupName))  {

            var imageIdx = parseInt( mObject.groupImageHash[groupName], 10);
            var imageUrl =   IMAGE_PATH +  SMALL_IMAGE +   IMG_LIST[imageIdx] +  IMG_FILE_ENDING;

            var imageIdxStr = imageIdx.toString();

            var toggleCheckBox = ' <li class="groupItem"><img src="'+ imageUrl +'"><input type="checkbox" id="groupToggle' + imageIdxStr+ '"  onclick="fUNQ170('+ imageIdxStr +');" CHECKED/><span class="middleGroupText">' + groupName +'</span></li>';

            allGroupBoxes = allGroupBoxes +  toggleCheckBox;

        }
    }

    allGroupBoxes = '<ul class="groupList"><li class="groupItem">' +  groupLabel + '</li> ' +  allGroupBoxes + '</ul>';



    if(groupDiv.length > 0 ) {
        groupDiv.html(allGroupBoxes);
        groupDiv.show();
    }

}


// This is called after a selected filter has changed.
//
// The basic idea is to get a 2-d array of items that can be displayed, take the array
// with the fewest items, put it in a hash and see what items are in every array by doing a count
// the items with the same count as the number of arrays get displayed, others get 'erased'
function fUNQ164() {


     // this will contain the idx's of the markers that get displayed
     var displayedMarkers = [];

     // first get the items displayed by the groups:
     var displayedGroupIdxs = [];

     var i;

     for( i = 0; i < mObject.sortedGroupKeys.length; i++) {
         var groupName = mObject.sortedGroupKeys[i];

         if(groupsOff.indexOf(i) < 0) {
             var markerIdxs = fUNQ47(groupName)  ;

             displayedGroupIdxs.push.apply(displayedGroupIdxs, markerIdxs)  ;
         }
     }

     var allSelectArrays = [];

     for( i = 0; i < selectedFilterValues.length; i++) {

         if(selectedFilterValues[i] && selectedFilterValues[i] != ALL_FILTER) {

             var tempArray = fUNQ44( mObject.filterListNames[i], selectedFilterValues[i])    ;

             if(tempArray.length > 0 ) {
                 allSelectArrays[allSelectArrays.length] =   tempArray;

             }
         }
     }


    if(allSelectArrays.length == 0 && mObject.sortedGroupKeys.length == 0)
    {
        // TODO: some optimization with the screen so markers can be seen
        for( i = 0; i < gMapMarkers.length;  i++) {

            if(gMapMarkers[i] == null )
                continue;

            if(fUNQ165(gMapMarkers[i]) ) {
                displayedMarkers.push(gMapMarkers[i].idx);

                fUNQ168(gMapMarkers[i]) ;
            }
            else {
                fUNQ169(gMapMarkers[i]);
            }
            //  if(!mObject.clustering && gMapMarkers[i].getMap() == null)
            //     gMapMarkers[i].setMap(gMap);
        }

         selectedMarkerSet = true;
         selectedMarkers =   displayedMarkers;

         // TODO: add an option for displaying dynamic filters and change this based on that value
         // TODO: test the line below:
        if(mObject.disAbleDynamicFilters == null || mObject.disAbleDynamicFilters == false)
         fUNQ166();

         fUNQ143(displayedMarkers);

         return;
     }


     if(mObject.sortedGroupKeys.length > 0)
         allSelectArrays[allSelectArrays.length] = displayedGroupIdxs;

     var smallestArray =  allSelectArrays[0];


     for( i = 0; i < allSelectArrays.length;  i++){

         if(allSelectArrays[i].length < smallestArray)
            smallestArray = allSelectArrays[i];
     }

     // now put the smallest array into a hash
     var uniqueMarkerIdxs = {};
     for( i = 0; i < smallestArray.length; i++) {
         uniqueMarkerIdxs[smallestArray[i].toString()] = 0;
     }

     // now count how many arrays match the items in the hash!
     for( i = 0; i < allSelectArrays.length; i++) {

         for(var j = 0; j< allSelectArrays[i].length; j++)  {

             if(uniqueMarkerIdxs.hasOwnProperty(allSelectArrays[i][j].toString()))    {
                 uniqueMarkerIdxs[allSelectArrays[i][j].toString()] = parseInt(uniqueMarkerIdxs[allSelectArrays[i][j].toString()], 10 )+ 1;
             }
         }
     }

     // remove the items that don't match all filters/groups
     for(var itemIdx in uniqueMarkerIdxs)      {
         if(uniqueMarkerIdxs[itemIdx] != allSelectArrays.length) {
             delete  uniqueMarkerIdxs[itemIdx];
         }
     }



     for( i = 0; i < gMapMarkers.length;  i++) {
         if(gMapMarkers[i] == null)
            continue;

         if(uniqueMarkerIdxs.hasOwnProperty(gMapMarkers[i].idx.toString()) && fUNQ165(gMapMarkers[i]))    {

             fUNQ168(gMapMarkers[i]);
             //gMapMarkers[i].setMap(gMap);
             displayedMarkers.push(gMapMarkers[i].idx)  ;

         }
         else {
             fUNQ169(gMapMarkers[i]) ;
             //gMapMarkers[i].setMap(null);
         }

     }

     //  take into account only displaying the items that are visible in the current map view & moving/zooming to items so they will
     // be visible if nothing is visible.
     // DONE: below!!!

     selectedMarkerSet = true;
     selectedMarkers =     displayedMarkers;

    // TODO: add an option for displaying dynamic filters and change this based on that value
    // TODO: test the line below:
    if(mObject.disAbleDynamicFilters == null || mObject.disAbleDynamicFilters == false) {
        fUNQ166();
    }


     fUNQ143(displayedMarkers);
 }


// return true if there is not a circle filter or there is a circle filter and it is in the circle
function fUNQ165(gMapMarker) {

    if(!circleFilter)
        return true;


    if(circle.getBounds().contains(gMapMarker.getPosition()) &&  gMapMarker.distanceM <= circleRadius ) {

        return true;
    }

    return false;

}

// can exclude items from other filters, but not from the selected one
function fUNQ166() {

    for(var i = 0; i <  mObject.filterListNames.length; i++) {

        var allSelectArrays = [];

        for( var j = 0; j < selectedFilterValues.length; j++ )
        {
            if(j == i || (selectedFilterValues[j] && selectedFilterValues[j] == ALL_FILTER)) {
                continue;
            }

            var tempArray = fUNQ44( mObject.filterListNames[j], selectedFilterValues[j])    ;

            if(tempArray.length > 0 ) {
              //  allSelectArrays.push.apply(allSelectArrays, tempArray);

                if(allSelectArrays.length == 0)
                    allSelectArrays.push.apply(allSelectArrays, tempArray);
                else
                    allSelectArrays = fUNQ68(allSelectArrays, tempArray) ;

            }

        }

        fUNQ167(i,  allSelectArrays, selectedFilterValues[i]);

    }

}

function fUNQ167(filterIdx,  allAvailableValues, selectedValue) {


    var tempFilter = [];
    tempFilter.push(ALL_FILTER);


    var bucketKeys = mObject.filterListSortedKeyHash[mObject.filterListNames[filterIdx]];


    for(var i = 0; i < bucketKeys.length; i++)
    {
        var filterValIdxs =   fUNQ44( mObject.filterListNames[filterIdx], bucketKeys[i])    ;

        if( allAvailableValues.length == 0 || selectedValue ==  bucketKeys[i] ||  fUNQ66(filterValIdxs, allAvailableValues) )
        {

            tempFilter.push(bucketKeys[i]);
        }


    }

    fUNQ48(tempFilter, selectedValue, filterIdx.toString() +"_rfilter")

}


function fUNQ168(marker) {

    if(!mObject.clustering && marker.getMap() == null)
        marker.setMap(gMap);

}

function fUNQ169(marker) {

    if(!mObject.clustering && marker.getMap() != null)
        marker.setMap(null);
}

// have the option to either:
// 1) display this group and none of the others
// 2) turn this group on/off
function fUNQ170(groupId) {

    var groupIdAsInt = parseInt(groupId, 10)    ;

    // if set to true, only show one group
    // if set to false turn on/off individual groups
  //  var oneGroup = true;
    var oneGroup = false;
    var offGroupIdx = groupsOff.indexOf(groupId);

    if(offGroupIdx > -1 )      {


        if(oneGroup) {
            groupsOff.length = 0;
                 // show all groups
            fUNQ164();
        }
        else {
            // show this group again
            groupsOff.splice(offGroupIdx, 1)    ;
          //  fUNQ172(groupIdAsInt, true);
            fUNQ164();
        }

    }
    else {
        if(oneGroup) {
            groupsOff =  mObject.sortedGroupKeys;
            groupsOff.splice(offGroupIdx, 1)    ;
            fUNQ164();
            // show only this group

         //   fUNQ171(false);
         //   fUNQ172(groupIdAsInt, true);
         //   fUNQ164();
        }
        else {
            groupsOff[groupsOff.length] = groupIdAsInt;

            // hide this group
          //  fUNQ172(groupIdAsInt, false);
            fUNQ164();
        }

    }

}

   // This really isn't used, but if it were, it would need to be fixed to work with clustering and filtering.
function fUNQ171(turnOn) {
    for(var i = 0;  i< gMapMarkers.length ; i++)  {

        if( gMapMarkers [i] != null   ) {

            if(turnOn) {
                fUNQ168(gMapMarkers [i]);
            }
            else {
                fUNQ169(gMapMarkers);
            }
        }
    }
}

// display selected markers should take care of everything this does
/*
// TODO: need to take into account whether or not the groups are in the current view
function fUNQ172(groupIdx, turnOn) {

    var groupName = mObject.sortedGroupKeys[groupIdx];

    var markerIdxs = fUNQ47(groupName)  ;


       for(var i = 0; i < markerIdxs.length; i++)      {
          if( markerIdxs[i] < gMapMarkers.length && gMapMarkers [markerIdxs[i]] != null)  {

              if(turnOn)
                  gMapMarkers[markerIdxs[i]].setMap(gMap);
              else
                  gMapMarkers[markerIdxs[i]].setMap(null);
          }


       }

}
*/

// call this after a search to reset the filters and groups!
function fUNQ173 () {
    fUNQ174();

    fUNQ175();
}

// checks all the groups
function fUNQ174() {


    var groupDiv =  $('#groupChecksDiv');

    if(groupDiv.length == 0)
        return;

    groupDiv.find(':checkbox').each(function(){

        $(this).prop('checked',true);

    });

    groupsOff.length = 0;
    //  $('#clusterCB').prop('checked', mObject.clustering );

}

// sets all the filters to 'All'
function fUNQ175() {

    var filterDiv =  $('#filtersDiv');

    if(filterDiv.length == 0)
        return;

    filterDiv.find('select option').each(function(){

        $(this).filter(function() {
            //may want to use $.trim in here
            return $(this).text() == ALL_FILTER;
        }).prop('selected', true);

    });

    for(var i = 0; i < selectedFilterValues.length; i++)
        selectedFilterValues[i] = ALL_FILTER;

    //  $('#clusterCB').prop('checked', mObject.clustering );

}


function fUNQ176() {

    return (fUNQ178(mObject.address) || fUNQ178( mObject.city) || fUNQ178(mObject.state) ||
        fUNQ178(mObject.zip) || fUNQ178(mObject.country) );


}

 // gets a data item from the line
function fUNQ177(line, mObjField, defaultVal, display) {

    if(display == false || fUNQ178(mObjField) == false )
        return defaultVal;

   return (( mObjField != null && (mObjField < line.length  && mObjField > -1) && line[mObjField].trim() != ""  ) ? line[mObjField].trim() : defaultVal );
}

function fUNQ178(mObjField) {

    var num = parseInt(mObjField, 10) ;


    return  ( mObjField != null &&  mObject.headerDisplayOrderIdxs.indexOf( num) > -1 );

}

// This is for when there are not any markers to display
function fUNQ179() {

    var windowData = $("#mapWindowData");

    if(windowData.length == 0 || inIframe)
        return;

    windowData.html("");

    fUNQ181(undefined, 0)   ;
}

//
function fUNQ180(pageNumber) {

    var windowData = $("#mapWindowData");

    if(windowData.length == 0 || inIframe)
        return;


    // will likely need to do some paging

    var allRows = "";
    var startPageIdx = 0;
    var i, markerIdx;

    if(pageNumber != undefined) {
            startPageIdx = (pageNumber -1 ) * DISPLAYABLE_ITEMS_PER_PAGE;

    }

    var tempMessage = '';

    if(selectedMarkers.length > 0 || selectedMarkerSet) {

        if(showMoreOptions && showDistance) {

            selectedMarkers.sort(function (a, b) {

                return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
            });

        }

        for( i = startPageIdx; i< selectedMarkers.length &&  selectedMarkers[i] < markerDescriptions.length && i < startPageIdx + DISPLAYABLE_ITEMS_PER_PAGE; i++) {

             markerIdx =  markerDescriptions[selectedMarkers[i]].markerIdx;

            // if adding a right div, put it directly under the windowRowLeft and have it float right

            allRows +=  '<div class="windowRowRight" onclick="fUNQ182(' + markerIdx.toString() + ')">' + (i +1).toString() + '</div>';

            //TODO: add code similar to below for showing the distance (or put a div next to the first line in the message and
            // do some stuff to search replace (also the message will have to be copied)
            // to add distance: allRows+= <div style="float:right;" class="showDistance">(25 miles)</div>

            tempMessage = markerDescriptions[selectedMarkers[i]].message;

            if(showMoreOptions && showDistance) {
                tempMessage = tempMessage.replace("noDistDisplay", "distDisplay").replace("##dist##", gMapMarkers[markerIdx].displayDistance );
            }

            allRows +=       '<div id="m' + markerIdx.toString() + '" class="windowRowLeft" onclick="fUNQ182(' + markerIdx.toString() + ')">' +tempMessage + '</div>';


        }


        // setup paging:
        fUNQ181(pageNumber, selectedMarkers.length)   ;

    }
    else {

        // TODO: copy the array, then sort it by distance
        var simpleSelected = [];
        for(var m = 0; m < markerDescriptions.length; m++)
        {
            simpleSelected[m] = m;
        }
        if(showMoreOptions && showDistance) {
            simpleSelected.sort(function (a, b) {

            return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
            });
        }


        /*  if(showMoreOptions && showDistance) {

              selectedMarkers.sort(function (a, b) {

                  return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
              });

          }
          */
        for( i = startPageIdx; i < simpleSelected.length && i < startPageIdx + DISPLAYABLE_ITEMS_PER_PAGE; i++) {

             markerIdx =  markerDescriptions[simpleSelected[i]].markerIdx;

            // if adding a right div, put it directly under the windowRowLeft and have it float right
            allRows +=  '<div class="windowRowRight" onclick="fUNQ182(' + markerIdx.toString() + ')">' + (i +1).toString() + '</div>';

            tempMessage = markerDescriptions[simpleSelected[i]].message;

            if(showMoreOptions && showDistance) {
                tempMessage = tempMessage.replace("noDistDisplay", "distDisplay").replace("##dist##", gMapMarkers[markerIdx].displayDistance );
            }

            allRows +=       '<div id="m' + markerIdx.toString() + '" class="windowRowLeft" onclick="fUNQ182(' + markerIdx.toString() + ')">' + tempMessage + '</div>';


        }

        // setup paging:
        fUNQ181(pageNumber, markerDescriptions.length)   ;

    }
    windowData.html(allRows);

}


function fUNQ181(pageNumber, itemCount) {

    // setup paging:
    // paging is showing
    if(pageNumber != undefined) {

        if(itemCount < DISPLAYABLE_ITEMS_PER_PAGE)
        {
            $('#compact-pagination').pagination('destroy');
        }

    }
    else { // paging is not showing

        if(itemCount > DISPLAYABLE_ITEMS_PER_PAGE)  {
            $('#compact-pagination').pagination({
                items: itemCount,
                itemsOnPage:   DISPLAYABLE_ITEMS_PER_PAGE,
                cssStyle: 'compact-theme',
                displayedPages: 7,
                onPageClick: changePage
            });
        }
        else if(gMapMarkers.length > DISPLAYABLE_ITEMS_PER_PAGE){
            // hide paging if it is showing
            $('#compact-pagination').pagination('destroy');
        }

    }


}

function changePage(pageNumber) {
    fUNQ180(pageNumber) ;

}

function fUNQ182(idx) {

    // trigger the info window to be opened for idx

    if(gMapMarkers[idx] == null)
        return;

    if(gMapMarkers[idx].getMap() == null)
    {
        gMapMarkers[idx].setMap(gMap);
    }

        if(gMap.getZoom() < CLUSTER_ZOOM_LEVEL) {
            gMap.setZoom(CLUSTER_ZOOM_LEVEL);
        }


    google.maps.event.trigger(gMapMarkers[idx], "click");


}


// .00011 is around 40 feet; an average block is close to 250 feet.
// for a small lot (1600 sqft), the markers would be on the same spot.
// one issue with this is a point can be 2 close to 2 points at opposite ends (such as being in the middle of a 50 foot straight line)
function fUNQ183(lat1,lon1,lat2,lon2) {

  if(lat1 == lat2 && lon1 == lon2)
    return true;

  if(Math.abs(lat1-lat2) <= .0001 && Math.abs(lon1 - lon2) <= .0001)
  {

    return ( Math.sqrt(  (Math.pow(lat1 - lat2, 2) + Math.pow(lon1 - lon2, 2) ) ) < .00011 )
  }

  return false;

}

// Returns a straight line type of distance
function fUNQ184(lat1,lon1,lat2,lon2)
{
    if(lat1 == lat2 && lon1 == lon2)
        return 0;

    return  Math.sqrt(  (Math.pow(lat1 - lat2, 2) + Math.pow(lon1 - lon2, 2) ) );
}

function fUNQ185(lat1,lon1,lat2,lon2) {
  var R = 6371; // Radius of the earth in km
  var mileR = 3959; // radius of the earth in miles
  var dLat = fUNQ186(lat2-lat1);  // fUNQ186 below
  var dLon = fUNQ186(lon2-lon1); 
  var a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(fUNQ186(lat1)) * Math.cos(fUNQ186(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2)
    ; 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return d = R * c; // Distance in km

}

function fUNQ186(deg) {
  return deg * (Math.PI/180)
}


function fUNQ187(lat, lng) {

    if ($.isNumeric(lat) && $.isNumeric(lng)  ) {

        return (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) ;

    }
    return false;
}

function fUNQ188() {

    // use all the components of the address, header information, email address, title
    // don't use image or website urls



    for(var i = 0; i < dataLines.length; i++) {

        if(dataLines[i] == null || dataLines[i].length == 0 )
            continue;

        for(var j = 0; j < mObject.headerDisplayOrderIdxs.length && mObject.headerDisplayOrderIdxs[j] < dataLines[i].length; j++) {

            if(!isIgnoreSearchColumn(j) &&  dataLines[i][mObject.headerDisplayOrderIdxs[j]].length > 0)
            {
                var key = dataLines[i][mObject.headerDisplayOrderIdxs[j] ] ;
                if (searchTermHash.hasOwnProperty(dataLines[i][mObject.headerDisplayOrderIdxs[j]])) {
                    searchTermHash[key].push(i);
                }
                else {
                    var bucketLineIndex = [];

                    bucketLineIndex.push(i);
                    searchTermHash[key] = bucketLineIndex;
                }

            }

        }
    }


}



function fUNQ189 () {


    var searchBoxDiv = $("#searchBox" )      ;

    if(searchBoxDiv.length == 0)
        return ;

    fUNQ188();

    var availableTerms = fUNQ196(searchTermHash);

    //  set the available tags to the search terms
    searchBoxDiv.autocomplete({
        source: availableTerms,
        minLength: 3,

        select: function(event, ui) {

            fUNQ191( ui.item.value );
        }

    });

    // TODO: this might be wrong, but should work with the ipad
    if( mobileDevice || tabletDevice )         {

        $('#searchBox').blur  (function() {

            fUNQ190();

        }  );
    }

}



function fUNQ190() {

 //  alert("running search: " + $('#searchBox').val() );

    fUNQ191(  $('#searchBox').val() );
}

function handleSearchSubmit(e) {
    if (e.keyCode == 13) {

        fUNQ191(  $('#searchBox').val() );
        return false;

    }
}

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};



function fUNQ191(searchTerm) {

    if(searchTerm.trim().length == 0)
        return;

    //alert(Object.size(searchTermHash));

    if (searchTermHash.hasOwnProperty( searchTerm )) {

         var idxs =    searchTermHash[searchTerm];
        fUNQ192(idxs);
    }
    else {
        // try to geocode the value

        fUNQ193(searchTerm, mObject.regionCode, geoResultCallbackSearchBox);
    }

}


function fUNQ192(displayIdxs) {

    var uniqueMarkerIdxs = [], i;

    for( i = 0; i < displayIdxs.length; i++) {
        uniqueMarkerIdxs[displayIdxs[i]] = 1;
    }

    for( i = 0; i < gMapMarkers.length;  i++) {

        if(gMapMarkers[i] == null)
            continue;

        if(uniqueMarkerIdxs.hasOwnProperty(gMapMarkers[i].idx))     {
            gMapMarkers[i].setMap(gMap);
        }
        else {
            gMapMarkers[i].setMap(null);
        }

    }
    selectedMarkerSet = true;
    selectedMarkers =   displayIdxs;
    fUNQ173();

    fUNQ143(displayIdxs);

}

function fUNQ193(address, country, callback) {

    //var address = generateAddress(locObject);



    if (address.length == 0) {

        return;
    }



    if(mapGeocoder == null)
        mapGeocoder = new google.maps.Geocoder();


    if(country != undefined && country.length > 0) {
      //  alert("calling the geo-coder1: " + address);
        mapGeocoder.geocode({
            'address': address,
            'region': country
        }, function (results, status) {

            callback(results, status);
        });

    }
    else {

        mapGeocoder.geocode({
            'address': address
        }, function (results, status) {

            callback(results, status);
        });

    }

}


function fUNQ194(resultArr, status) {
   // alert("geo-coder results: " + status.toString());
    if (status == google.maps.GeocoderStatus.OK) {


        //locObject.lat = resultArr[0].geometry.location.lat();
        //locObject.long = resultArr[0].geometry.location.lng();

      /*  if (resultArr[0].partial_match != null) {
        }*/

        fUNQ195(resultArr[0].geometry.location.lat().toFixed(6), resultArr[0].geometry.location.lng().toFixed(6));

    }
    /*
    else if (status == google.maps.GeocoderStatus.ZERO_RESULTS) {
    } else if (status == google.maps.GeocoderStatus.REQUEST_DENIED) {
    } else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
    } else if (status == google.maps.GeocoderStatus.INVALID_REQUEST) {
    } else if (status == google.maps.GeocoderStatus.UNKNOWN_ERROR) {
    }
                      */



    /*

     if (status == google.maps.GeocoderStatus.OK) {
     map.setCenter(results[0].geometry.location);
     var marker = new google.maps.Marker({
     map: map,
     position: results[0].geometry.location
     });
     */


}

function fUNQ195(lat, lng) {


    var currentDistance = 10000;
    var currentMarkerIdx = -1;

    for(var i = 0; i < gMapMarkers.length; i++)  {
        if(gMapMarkers[i] != null)       {
            var markerDistance = fUNQ184(lat, lng, gMapMarkers[i].getPosition().lat().toFixed(6), gMapMarkers[i].getPosition().lng().toFixed(6))   ;

            if(markerDistance < currentDistance)   {

                currentDistance = markerDistance;
                currentMarkerIdx = i;
            }

        }
    }


    if(currentMarkerIdx >= 0) {

        gMapMarkers[currentMarkerIdx].setMap(gMap);
        // TODO: verify the zoom levels are good      ; possibly hide the other markers

        var zoomLevel = gMap.getZoom();

        if(zoomLevel < 12)
            zoomLevel = 14;
        else if(zoomLevel < 16)
            zoomLevel = 15;

        gMap.panTo(gMapMarkers[currentMarkerIdx].getPosition())   ;
        gMap.setZoom(zoomLevel);

        // TODO: don't show the other items!

    }

}



function fUNQ196(termsHash) {

    var termList = [];
    for(var item in termsHash)   {

        termList.push(item);
    }

    termList.sort();

    return termList;
}

function fUNQ197() {

       var i;
    var kml = '<?xml version="1.0" ?>'      ;
    kml += '<kml xmlns="http://www.opengis.net/kml/2.2">';


    // validates against xsd!

    kml += '<Document>\n'  ;

    if(userSettings.title != null && userSettings.title.length > 0)  {
        kml += '<name><![CDATA[' + userSettings.title + ']]></name>\n';
    }
    else {
        kml += '<name><![CDATA[ Auto-generated KML by EasyMapMaker ]]></name>\n';
    }

    if(userSettings.description != null && userSettings.description.length > 0)  {
        kml += '<description><![CDATA[' + userSettings.description + ']]></description>\n';
    }
    else {
        kml += '<description><![CDATA[ Auto-generated KML by EasyMapMaker ]></description>\n';

    }


    // generate the styles:

    /*
     <Style id="downArrowIcon">
     <IconStyle>
     <Icon>
     <href>http://maps.google.com/mapfiles/kml/pal4/icon28.png</href>
     </Icon>
     </IconStyle>
     </Style>      */

    //IMG_LIST[mObject.markerImageIdx[i]]


    var balloonStyle = '<BalloonStyle><text><![CDATA[';

    if(fUNQ178(mObject.title))
    {
        balloonStyle += '<b>$[name]</b><br /> '     ;
    }
    if(fUNQ176()) {
        balloonStyle += '$[address]<br /> '     ;
    }
    balloonStyle +=    '$[description]<br/>$[geDirections] ';
    balloonStyle +=     ']]></text></BalloonStyle>';

    var multipleImages = false;
    var singleImg =     IMG_LIST[0] ;
    if( mObject.markerImageIdx.length > 0 ) {

        for( i = 0; i < IMG_LIST.length; i++)
        {
            kml += '<Style id="' + IMG_LIST[i] +  '">' +
                '<IconStyle>'   +
                '<scale>1</scale> ' +
                '<Icon> '     +
                '<href>' + BASE_IMAGE_URL + IMAGE_PATH + IMG_LIST[i] + IMG_FILE_ENDING + '</href>'        +
                '</Icon>'     +
                ' <hotSpot x="0.5"  y="0.5"  xunits="fraction" yunits="fraction"/> '  +
                '</IconStyle>'     +
                balloonStyle +
                '</Style>\n';

        }
        multipleImages = true;

    }
    else {
        kml += '<Style id="' + IMG_LIST[0] +  '">' +
            '<IconStyle>'   +
            '<scale>1</scale> ' +
            '<Icon> '     +
            '<href>' + IMAGE_PATH + IMG_LIST[0] + IMG_FILE_ENDING + '</href>'        +
            '</Icon>'     +
            ' <hotSpot x="0.5"  y="0.5"  xunits="fraction" yunits="fraction"/> '  +
            '</IconStyle>'     +
            balloonStyle +
            '</Style>\n';
    }


    for( i = 0; i < dataLines.length && i < gMapMarkers.length; i++)           {

        if(gMapMarkers[i] == null)
            continue;

        var title = "";
        if(fUNQ178(mObject.title) && dataLines[i][mObject.title] != "")   {
            title = dataLines[i][mObject.title]  ;
        }
        var address= fUNQ162(dataLines[i], " ",  true);
        var desc =   fUNQ198(dataLines[i]);



        kml += '<Placemark>' ;
        //<![CDATA[ ]]>
        if(title.length > 0)
            kml += '<name><![CDATA[' + title + ']]></name>\n';

        if(address.length > 0)
            kml += '<address><![CDATA[' + address + ']]></address>\n';

        if(desc.length > 0)
            kml += '<description><![CDATA[' + desc + ']]></description>\n';


        var styleImg = singleImg;

        if(    multipleImages      )
            styleImg =   gMapMarkers[i].color;

        kml +=  '<styleUrl>#' + styleImg +'</styleUrl>\n';

        var lngLat = gMapMarkers[i].getPosition().lng().toFixed(6).toString() + ',' +   gMapMarkers[i].getPosition().lat().toFixed(6).toString()   ;

        kml +=  '<Point> '    +
            '<coordinates>' +lngLat + ',0</coordinates>\n'  +
            '</Point> \n' ;


        kml += '</Placemark>\n';

    }

    kml += '</Document>\n'   ;
    kml += '</kml>'    ;


    return kml;

}



function fUNQ198(dataItem) {

    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {

                 gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div>' + label + ': '+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div>'+ gDataItem + '</div>' ;

                }
            }
        }

    }

    var siteImage =  "";
    if(fUNQ178(mObject.image) && dataItem[mObject.image] != "")  {
        siteImage = '<img src="' + dataItem[mObject.image] + '"/>';
    }

    var email = "";
    if(fUNQ178(mObject.email) && dataItem[mObject.email] != "") {
        email = 'e-mail: <a href="mailto:' + dataItem[mObject.email] + '">' +   dataItem[mObject.email] + '</a>';

    }
    var website = "";
    if(fUNQ178(mObject.web) && dataItem[mObject.web] != "")  {
        website = '<a href="' + urlizeUrl(dataItem[mObject.web]) + '" target="_blank">' +   dataItem[mObject.web] + '</a>';
    }

    var firstHalf = descDisplay;

    firstHalf = firstHalf + siteImage ;
    firstHalf = firstHalf +   email ;
    firstHalf = firstHalf +  website;
    return firstHalf;


}


function myCalculator(markers, numStyles) {
    var index = 0;
    var title = "";
    var count = markers.length.toString();

    var dv = count;
    while (dv !== 0) {
        dv = parseInt(dv / 3, 10);
        index++;
    }

    index = Math.min(index, numStyles);
    return {
        text: count,
        index: index,
        title: title
    };
}


// good stuff:

/*

 google.maps.event.addListener(map, "rightclick", function(event) {
 var lat = event.latLng.lat();
 var lng = event.latLng.lng();
 // populate yor box/field with lat, lng
 alert("Lat=" + lat + "; Lng=" + lng);
 });

 */

// suppress markers on directions:

/*
 // Map and directions objects
 var map = new google.maps.Map( element, options );
 var service = new google.maps.DirectionsService();
 var directions = new google.maps.DirectionsRenderer({suppressMarkers: true});

 // Start/Finish icons
 var icons = {
 start: new google.maps.MarkerImage(
 // URL
 'start.png',
 // (width,height)
 new google.maps.Size( 44, 32 ),
 // The origin point (x,y)
 new google.maps.Point( 0, 0 ),
 // The anchor point (x,y)
 new google.maps.Point( 22, 32 )
 ),
 end: new google.maps.MarkerImage(
 // URL
 'end.png',
 // (width,height)
 new google.maps.Size( 44, 32 ),
 // The origin point (x,y)
 new google.maps.Point( 0, 0 ),
 // The anchor point (x,y)
 new google.maps.Point( 22, 32 )
 )
 };

 service.route( { origin: origin, destination: destination }, function( response, status ) {
 if ( status == google.maps.DirectionsStatus.OK ) {
 display.setDirections( response );
 var leg = response.routes[ 0 ].legs[ 0 ];
 makeMarker( leg.start_location, icons.start, "title" );
 makeMarker( leg.end_location, icons.end, 'title' );
 }
 });
 function makeMarker( position, icon, title ) {
 new google.maps.Marker({
 position: position,
 map: map,
 icon: icon,
 title: title
 });
 }
*/


// for IE-8
if (!window.console) console = {debug: function(str) {}};

// TODO: comment out the below for non-IE testing (and prod)
var console=console||{"debug":function(){}};

var advancedMap = false;


var MAX_LINE_MESSAGE = "Only first 100 rows shown, but all data processed."  ;

var MAX_ERROR_LINE_MESSAGE = "Only the first 100 errors are shown.";

var ADDRESS_LIMIT = 250;

// change this to 40,000 for debugging, 4,000 otherwise
var GEO_CODE_SLOWNESS = 6000;

var columnHeaderHash = {}; // or just {}
//var columnHeaderArray = [];  // the index corresponds to a name (the header)

//var groupHash = {};  // maps group names to index values in the lines/ array for Markers
//var sortedGroupKeys = [];  // the keys of the above array in sorted order!


//var locationHeaderIdx = [];       // used when determining the headers; this is used so certain items won't use any of the location columns

//var headerDisplayOrderIdxs = [];  // has the headers in the order from the display marker

var dataLines = [];   // the data for each line, minus the header, post split (this is an array that contains arrays)

//var groupImageHash = {};  // maps the group name to the image value (location).

//var filterListNames = [];  // contains the names of the filters
//var filterListArray = [];  //  the value is a hash with the names
//var filterListSortedKeyHash = {};  // the key is the filter name,
// the value is a list of keys (the key into the values for the filterListArray

var selectFilterMatch = {};  // the key is the name match (address_sel or city_sel), the values are indexes (or names) from the columnHeaderHash

var labelNames = ["Address", "City",  "State / Province", "Zip Code", "Country", "Latitude", "Longitude",
    "Marker Title", "Url (website)", "(website) Image", "(website) E-mail", "Group"
];

var prettyMatchNames = ["address", "city",  "state", "zip", "country", "lat", "long",
    "title", "url", "image", "email", "group" ];

// These are the names of the selects / groups-filters
var matchNames = ["address_sel", "city_sel",  "state_sel", "zip_sel", "country_sel", "lat_sel", "long_sel",
    "title_sel", "url_sel", "image_sel", "email_sel", "group_sel"
];

// disable these when the map is being processed
var miscIds =  ["region_sel", "clusterCB", "showLabelCB", "scrollWheelCB",  "noDisplay", "toDisplay", "noFilter", "toFilter", "mapType", "moveAllToDisplay",
    "removeAllFromDisplay", "removeAllFromFilter", "showMoreOptionsCB", "dynamicFiltersCB" ];

// values to match email, city, address, etc
var addressMatch = ["address", "addresses", "street", "streets"];
var negAddressMatch = ["email", "e-mail"];
var cityMatch = ["city", "cities", "town", "towns"];
var zipMatch = ["zip", "zipcode", "postcode", "zip code", "post code", "postalcode"];

var stateMatch = ["state", "region", "province"];
var titleMatch = ["title", "name", "company", "label"];
var urlMatch = ["url", "website", "link"];
var imageMatch = ["img", "image", "picture", "photo"];
var emailMatch = ["email", "e-mail"];

var latMatch = ["latitude", "lat", "lt", "emm_lat"];
var longMatch = ["longitude", "ln", "lng", "lon", "long" , "emm_lng"];
var countryMatch = ["country"];

var groupMatch = ["group", "category"];

//var iconMatch = ["pin", "marker", "icon"];

var reservedMatches = ["emm_lat", "emm_lng", "emm_acc"];


var savedMapId = null;

// don't filter on any of the above, except for group!

// maps  the select box name to the index value in the header.
var selected_columns = {};

//var geoLookupIdx = 0;

var editMap = true;

// variables for the text area
var clickMessage = '<h2>Click here to paste data</h2>';

var dataPresentMessage = '<h2>Click here to copy/paste data</h2>';
var textAreaDataLength = 0; 

var textAreaChanged = false;
//var mouseOutTextArea = true;
//var pollingTextArea = false;

// if geo-coding, ignore changes to the data
//var geoCoding = false;

var geoCoder;
var defaultGeoCodeTimeout = 600;

// key is the address, value is the lat/lng
var geoCodeHash = {};

var geoCodeStats = {};
geoCodeStats.init = false;
geoCodeStats.geoCoding = false;

// end GeoCode info

// keep track of the processing errors (line number, address, and probably the google error code translated should be good)
//var geoCodingErrors = [];

var tabletDevice = false, mobileDevice = false;

var overTableMessageFocus = false;

// a placeholder for google maps.
var google;

// some divs
// text area with user data
var mainTextArea = null;
var overTableMessageDiv = null;
var outerOverTableDiv = null;
var displayTableDiv = null;
var reProcessData = false;


// ----------------------------------------------------------
// If you're not in IE (or IE version is less than 5) then:
// ie === undefined
// If you're in IE (>=5) then you can determine which version:
// ie === 7; // IE7
// Thus, to detect IE:
// if (ie) {}
// And to detect the version:
// ie === 6 // IE6
// ie > 7 // IE8, IE9, IE10 ...
// ie < 9 // Anything less than IE9
// ----------------------------------------------------------
var ie = (function(){
    var undef,rv = -1; // Return value assumes failure.
    if (navigator.appName == 'Microsoft Internet Explorer')
    {
        var ua = navigator.userAgent;
        var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
        if (re.exec(ua) != null)
            rv = parseFloat( RegExp.$1 );
    }

    return ((rv > -1) ? rv : undef);
}());


function init() {

    if (!window.console) console = {debug: function() {}};

    if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))
        || (  (navigator.userAgent.match(/mobile/i))  &&  (navigator.userAgent.match(/Android/i))  ) ||
        (navigator.userAgent.match(/blackberry/i)) || (navigator.userAgent.match(/windows phone/i))   ) {
        mobileDevice = true;
    }
    if( !mobileDevice &&   ((navigator.userAgent.match(/Android/i))  ||  (navigator.userAgent.match(/iPad/i))  )  )  {
        tabletDevice = true;
    }

    advancedMap = fUNQ129()       ;

    if(advancedMap) {
        $('#easyMaps').toggleClass('active');
        $('#advancedMaps').toggleClass('active');
    }

/*
  handle text area change.
*/
    mainTextArea =  $('#sourceData');
    overTableMessageDiv =    $('#overTableMessage');
    outerOverTableDiv = $('#outerOverTable');
    displayTableDiv = $('#displayTable');


    var textAreaContainer = document.getElementById ("sourceData");

if ( textAreaContainer.addEventListener) {
   textAreaContainer.addEventListener('input', function() {
    // event handling code for sane browsers
       processTextChange();

  }, false);
} else if ( textAreaContainer.attachEvent) {
   textAreaContainer.attachEvent('onpropertychange', function() {
    // IE-specific event handling code
       processTextChange();
  });
}

    function processTextChange() {

        textAreaChanged = true;
        reProcessData = true;

        textAreaDataLength = mainTextArea.val().length ;


        if (textAreaDataLength == 0) {
            overTableMessageDiv.html(clickMessage);

            if (!displayTableDiv.hasClass('light-gray')) {
                displayTableDiv.toggleClass('light-gray');
            }

        }

    }

    $('#errorButton').click(function() {

          fUNQ73();
    });


    if( typeof EditingMap != 'undefined' && EditingMap)
    {

        fUNQ0();
    }


    // use sample data 1
  $('#useSample1').click(function() {
      fUNQ70( $('#sample1_data').text());
  })  ;

    // use sample data 2
    $('#useSample2').click(function() {

        fUNQ70( $('#sample2_data').text());
    }) ;


    $('#optionButton').click(function() {

        var mapOptionsSelector = $('#mapOptions');

        if( mapOptionsSelector.css('display') == 'none' || reProcessData)
        {
            // call a method to set the data
            if (fUNQ115() > 1) {
                fUNQ72();
                reProcessData = false;

                mapOptionsSelector.show();
            }
        }

    } );


    $('#makeMapButton').click( function() {

        // user did not click to process data, so process the data anyway.
        if( (dataLines.length == 0  || reProcessData )&& mainTextArea.val().length > 0)
        {

           fUNQ115();
           fUNQ72();
            reProcessData = false;
        }

        var ready =  fUNQ78();

        if(!ready)
        {
            alert("Location options are not set.");
            return ;
        }

        if(!fUNQ77()) {
            alert("Data is not present.");
            return ;
        }

        if(!geoCodeStats.geoCoding && !$(this).hasClass('btn-danger')) {

            fUNQ74() ;
            // do the geo-code thing
            mapPrep() ;
        }
        else if( /*geoCodeStats.geoCoding && */ $(this).hasClass('btn-danger') )
        {
            // user is stopping geoCoding
            fUNQ75();
            geoCodeStats.geoCoding = false;
        }

    })  ;

    /*
 $('#saveMapButton').click(function() {
    $('#myModal').show();
  //$('#myModal').modal('show');
    });
*/


    $("#mapModal").modal({backdrop:'static',   keyboard: false, show: false});

    $("#mapModalButton").click(function() {

       $("#mapModalButton").button('loading') ;
       $("#mapModal").modal('show'); //.show();

    });

    $("#mapSaveButton").click(function() {

        if(fUNQ108() ) {
         $("#mapModal").modal('hide'); //.show();
        }

    });

    function textHasData() {

        //  check to see if there is text in the text area
        return  (mainTextArea.val().trim().length   > 0 );
    }


    overTableMessageDiv.blur(function() {

        if(mobileDevice || tabletDevice       )
        {
            overTableMessageFocus = false;
            //  if (textHasData()) {
           // alert("inner overtable lost focus!");
            //   }
        }

    })  ;

    // This likely is not used
    outerOverTableDiv.blur(function() {

        if(mobileDevice || tabletDevice       )
        {

            if( $('#overTableMessage').css('display') == 'none'     )
            {

            }
            else {
                 // TODO: should probably do what is done for a mouse out.
                      // alert("blur out");

                if (textHasData()) {
                    overTableMessageDiv.hide();
                }

            }
        }

    })  ;

    outerOverTableDiv.mouseenter(function () {

    if($(this).css('display') == 'none')
      return;

        // don't let user modify data while geo-coding!
        if(geoCodeStats.geoCoding )
            return;

        if(mobileDevice || tabletDevice    )
        {

            if( overTableMessageDiv.css('display') == 'none'     )
            {
                overTableMessageFocus = true;
            }
            else {
                overTableMessageFocus = false;
                outerOverTableDiv.focus();
                   return;
            }

        }


        displayOverTableMessage();

        //  if there is not text in the textarea, do nothing

      //  $('#outerOverTable').show();
     //   alert("entered outer over table")                      ;
        //  $('#prettyTable').hide();

    });


    function displayOverTableMessage() {

        if (textHasData()) {

            displayTableDiv = $('#displayTable');

            if (!displayTableDiv.hasClass('light-gray')) {
                displayTableDiv.toggleClass('light-gray');

            }

            overTableMessageDiv.html(dataPresentMessage);

            //$('#tableText').hide();
        }
        else {
            overTableMessageDiv.html(clickMessage);
        }

        //$('#outerOverTable').show();
            overTableMessageDiv.fadeIn('medium');
    }

    // this fired in IE, but overall, it does not appear to be needed
    /*
    $('#toggleDiv').blur(function()     {
         //      alert("toggle div lost focus");
    }) ;
    */

    mainTextArea.blur(function() {

        if (textHasData() ) {

            if(textAreaChanged) {

                fUNQ81();
            }
            //    alert('displaying dark table');
            fUNQ69();

            if(mobileDevice || tabletDevice) {
                handleMouseLeave();
            }
        }

    });

    $('#toggleDiv').mouseleave(function () {

        handleMouseLeave();

    });


    function handleMouseLeave() {

        if (textHasData()  && !geoCodeStats.geoCoding ) {

            if (displayTableDiv.hasClass('light-gray')) {
                displayTableDiv.removeClass('light-gray');
            }

            //  $('#outerOverTable').hide('medium');

                overTableMessageDiv.fadeOut('medium');


            //$('#tableText').hide();
        }
    }



    function initTableDisplay() {

        textAreaDataLength  = mainTextArea.val().length ;

        if (textAreaDataLength  > 0 ) {
            fUNQ81();
            fUNQ69();
        } else {

            overTableMessageDiv.html(clickMessage);

            $('#tableText').hide();
        }

        $('#displayTable').addClass('light-gray');

    }


    // IE is picky, so add more handlers for it.
  if(ie != null ) {
      $('#prettyTable').click(function () {

          if(geoCodeStats.geoCoding)
              return;


          //  alert("called the click!");

          handlePrettyTableClick();
      });


      overTableMessageDiv.click(function () {

          if(geoCodeStats.geoCoding)
              return;


          //  alert("called the click!");

          handlePrettyTableClick();
      });

  }

    outerOverTableDiv.click(function () {

        if(geoCodeStats.geoCoding)
            return;


        //  alert("called the click!");

        handlePrettyTableClick();
    });


    function handlePrettyTableClick() {
        textAreaChanged = false;

        $('#tableText').show();

        // highlight the data when the user clicks.
        var $this = mainTextArea;
        $this.show();
        $this.select();

        // Work around Chrome's little problem
        $this.mouseup(function () {
            // Prevent further mouseup intervention
            $this.unbind("mouseup");
            return false;
        });


        $('#prettyTable').hide();
        outerOverTableDiv.hide();

    }

    fUNQ57();
    initTableDisplay();

    $("[rel=tooltip]").tooltip();


}  // end init function


function fUNQ69() {

    $('#prettyTable').show();

    displayTableDiv.removeClass('light-gray');

    overTableMessageDiv.html(dataPresentMessage);

    outerOverTableDiv.show();

    $('#tableText').hide();

}


function fUNQ70(sampleData) {
    textAreaChanged = true;
    mainTextArea.val( sampleData);
    textAreaDataLength = mainTextArea.val().length ;
    fUNQ81();
    overTableMessageDiv.html(clickMessage);
    overTableMessageDiv.hide();
    fUNQ69();

}

// load google maps api
function fUNQ71(callBackFunc) {
    var script = document.createElement("script");
    script.type = "text/javascript";
 //   script.src = "//maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&callback=" + callBackFunc;
         script.src = "//maps.googleapis.com/maps/api/js?v=3.12&key=AIzaSyArK9pT5ZBrngT8I_rzobA64CW5l_mJLTo&sensor=false&callback=" + callBackFunc;
    document.body.appendChild(script);
}


function fUNQ72() {

  if(dataLines.length == 0) {

    return;
  }

    if(typeof EditingMap != 'undefined' && EditingMap)
        return;


  selectFilterMatch = {};

  fUNQ118(columnHeaderHash);

    fUNQ88();

    fUNQ90();

    fUNQ127();
  // show the map type options and the checkbox

    fUNQ114('selectorData');

    fUNQ86('selectorData');

    fUNQ85();

    fUNQ91('selectorData');

    fUNQ87('selectorData');

    fUNQ89('selectorData');

    fUNQ79();

  fUNQ80();

    fUNQ27();

    fUNQ76();

    var headerInstr = $('#headerInst');

      if( headerInstr.length > 0)
      {
          if(fUNQ78())  {
              headerInstr.hide();
          }
          else
          {
              headerInstr.show();
          }
      }

    if(advancedMap) {

        $('#outerFilterSelects').show();

        $('#outerMarkerDisplaySelects').show();
    }

}


function fUNQ73() {

    var errorButton = $('#errorButton');
    var errorDisplay = $('#prettyErrorTable');

    if(errorButton.text() == "Show Errors") {

        errorButton.text("Hide Errors");
        errorDisplay.show();
    }
    else {

        errorButton.text("Show Errors");
        errorDisplay.hide();
    }

}

 // called when the user clicks and wants to get his processing on.
function fUNQ74() {


    var mapButton = $('#makeMapButton');

    if(  mapButton.hasClass('btn-caution') )  {

        mapButton.toggleClass('btn-caution btn-danger');
        mapButton.text("Stop Mapping");
    }
    else if( mapButton.hasClass('btn-success')   ) {
        mapButton.toggleClass('btn-success btn-danger');
       // mapButton.
        mapButton.text("Stop Mapping");
    }

    return true;
}

function fUNQ75() {

    var ready =  fUNQ78();

    var mapButton = $('#makeMapButton');

    if( mapButton.hasClass('btn-danger')  )       {

        if(ready  )
        {
            mapButton.toggleClass('btn-success btn-danger');
        }
        else {
            mapButton.toggleClass('btn-caution btn-danger');
        }
        mapButton.text("Make Map");

        if( typeof EditingMap != 'undefined' && EditingMap)
        {

            mapButton.text("Re-Map");
        }
    }


}


// toggles the color between yellow and green
function fUNQ76() {

    var ready =  fUNQ78();

    var mapButton = $('#makeMapButton');


    if(ready && mapButton.hasClass('btn-caution') )     {
        mapButton.toggleClass('btn-caution btn-success');

    }

    else if(!ready && mapButton.hasClass('btn-success') )     {
        mapButton.toggleClass('btn-caution btn-success');

    }

}


function fUNQ77() {

    return (dataLines != null && dataLines.length > 0)   ;
}


// this checks to see if an address has been set (either lat/long)
// or address, city, state, zip, or country
function fUNQ78() {



    return ((  mObject.lat  != null && mObject.lat > -1 &&  mObject.lng != null && mObject.lng > -1 ) ||
        (  mObject.address != null && mObject.address > -1 ) ||
        ( mObject.city != null && mObject.city > -1 ) ||
        ( mObject.state != null && mObject.state > -1 )||
        ( mObject.zip != null && mObject.zip > -1) ||
        ( mObject.country != null && mObject.country > -1 )
        )    ;

}



function fUNQ79() {

    // The values for this need to change, such that we would not want to display the lat/long be default

    var displayItems = [];
    var noDisplayItems = [];
    mObject.headerDisplayOrderIdxs.length = 0;

    for (var i = 0; i < mObject.columnHeaderArray.length; i++) {

        if(reservedMatches.indexOf(mObject.columnHeaderArray[i] ) >= 0)
            continue;

        if (i == mObject.lat || i == mObject.lng) {
            continue;
            // noDisplayItems.push(i);

        }
        else {
            displayItems.push(i);
        }

        mObject.headerDisplayOrderIdxs[mObject.headerDisplayOrderIdxs.length] = i;

    }

     if($('#markerDisplaySelects').length == 0)
        return;



    fUNQ33('noDisplay', 'toDisplay', displayItems, noDisplayItems, mObject.columnHeaderArray);

    fUNQ24();
}


function fUNQ80() {

    if($('#filterSelects').length == 0)
        return;



    var noDisplayItems = [];

    for(var i = 0; i < mObject.columnHeaderArray.length; i++) {

        if(reservedMatches.indexOf(mObject.columnHeaderArray[i] ) >= 0)
         continue;

        if (i == mObject.lat || i == mObject.lng) {
            continue;
        }

        // don't filter on location information
        //if (!isSelectedColumn(i)) {

        noDisplayItems.push(i);
        //}
    }



    //TODO: The values for this need to change, such that we would not want to filter on the lat/long
    // really need to look at some of the data and determine what should not be filtered, such
    // as urls and images.

    fUNQ33('noFilter', 'toFilter', [], noDisplayItems, mObject.columnHeaderArray);

    fUNQ32(MAX_FILTERS);

}


// moved!
function fUNQ81() {

    var str = fUNQ82(mainTextArea.val());

    var lines = str.split("\n");

    var headersSet = false;


    var tableData = "";

    var textLine = "";

    var lineCount = 0;
    var columnCount = 0;

    for(var i = 0; i < lines.length; i++)
    {
        // ignore '#' and blank lines
        if(lines[i].trim().indexOf("#") == 0 || lines[i].trim() == "") {
            continue;
        }

        textLine = "";

        lineCount++;

        var itemArray    =    lines[i].trim().split(" ");

        if(!headersSet) {
            lines[i] = lines[i].trim()      ;


            columnCount =  itemArray.length;
        }


        for (var j = 0; j < columnCount && j < itemArray.length; j++) {

            //itemArray[item]
            if(!headersSet) {
                textLine += "<th>" + fUNQ84(itemArray[j].fulltrim(), 25)  + "</th>";
            }
            else {
                textLine += "<td>" + fUNQ84(itemArray[j].fulltrim(), 25) + "</td>";
            }
        }
        tableData += "<tr>" + textLine + "</tr>";


        if(lineCount > 100 && lineCount > 0) {

            tableData  += '<tr><td colspan="' + columnCount + '">' + MAX_LINE_MESSAGE + '</td></tr>';
            break;
        }

        headersSet = true;

    }


    $("#outerDisplayTable").html('<table id="displayTable" class="table table-bordered table-condensed" style="width: 100%">' + tableData + '</table>');

}



// use this to modify data in the text area
function redrawTextArea() {

      var headerData = fUNQ83(  mObject.columnHeaderArray.join('\t'))       ;
      var mainData = fUNQ83(fUNQ54());

      if(headerData.length > 0&& mainData.length > 0)           {
          mainTextArea.val(headerData + '\n' + mainData);
      }

  }


// replaces reserved html characters with their respective encodings
function fUNQ82(str) {
       return str.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/'/, "&apos;");
   }

// removes html reserved characters and replaces them with their initial value.
function fUNQ83(str) {
    return str.replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, "\"").replace(/&apos;/, "'");
}


 
function fUNQ84(str, maxLen) {

     if(str == null)     {
         return "";
     }

    if (typeof str !== 'string') {
         str = str.toString();
     }

  if(str.trim().length > maxLen) {
    return str.substring(0, maxLen - 5) + "...";
  }
  
  return str;
 
 }

// good for english, probably not other languages
String.prototype.fulltrim = function () {


   // if(this.indexOf('\xC2')   > 0  ) {
   // }

    return this.replace( /[\xC2]*/g, '').trim()  ;

    //   return this.replace( /([^\x00-\x7F])*$/, '').replace( /^([^\x00-\x7F])*/, '' ).trim()  ;
};


// enables clustering for more than 200 items
function fUNQ85()  {

    if(dataLines.length >= 150 )
        $('#clusterCB').prop('checked',true );
}

// adds the cluster check box
function fUNQ86(divId)
{

    if(  $('#clusterCB').length > 0 ) {
        return;
    }

    var str =   '<p><label id="clusterCB_label" for="clusterCB">enable clustering ' +
        '<a id="cbToolTip" data-toggle="tooltip" title="Combine dense markers together, improves map performance."><i class="icon-question-sign"></i></a> ' +
        '</label>  ' +
        '<input id="clusterCB" type="checkbox" name="cluster" value="Cluster"> </p>';

    $('#' + divId).append(str);

    $('#cbToolTip').tooltip({
        placement : 'right'
    });


    // to see if the check box is checked:
    // see if the checkbox is checked
//    var checked = $('#clusterCB').is(':checked');
//



    // to automatically check the box:
    // $('#clusterCB').attr('checked', true);

}


// adds the cluster check box
function fUNQ87(divId)
{

    if(  $('#scrollWheelCB').length > 0 ) {
        return;
    }

    var str =   '<p><label id="scrollWheelCB_label" for="scrollWheelCB">Mouse Scrollwheel ' +
        '<a id="swToolTip" data-toggle="tooltip" title="Allow the mouse wheel to resize the map."><i class="icon-question-sign"></i></a> ' +
        '</label>  ' +
        '<input id="scrollWheelCB" type="checkbox" name="scrollWheel" value="ScrollWheel"> </p>';

    $('#' + divId).append(str);

    $('#swToolTip').tooltip({
        placement : 'right'
    });


    // to see if the check box is checked:
    // see if the checkbox is checked
//    var checked = $('#clusterCB').is(':checked');
//



    // to automatically check the box:
    // $('#clusterCB').attr('checked', true);

}


function fUNQ88()
{

    var groupHelpMsg = ' <a id="groupToolTip" data-toggle="tooltip" title="Allows filtering on up to ' + MAX_GROUPS.toString() +  ' different marker colors"><i class="icon-question-sign"></i></a>';

    var groupLabelId =  $('#group_sel_label');

    var groupToolTipId =  $('#groupToolTip');

    if( groupLabelId.length == 0 ||  groupToolTipId.length > 0) {
        return;
    }
    else {
        groupLabelId.append(groupHelpMsg);
        $('#groupToolTip').tooltip({
            placement : 'right'
        });
    }


}


// adds the show label check box
function fUNQ89(divId)
{


    if( !advancedMap ||  $('#showMoreOptionsCB').length > 0) {
        return;
    }

    var str =   '<p><label id="showMoreOptionsCB_label" for="showMoreOptionsCB">directions ' +
        '<a id="showMoreOptionsToolTip" data-toggle="tooltip" title="Enable a left panel for directions and a radius search"><i class="icon-question-sign"></i></a> ' +
        '</label>  ' +
        '<input id="showMoreOptionsCB" type="checkbox" name="showMoreOptions" value="directions panel" > </p>';


    $('#' + divId).append(str);

    $('#showMoreOptionsToolTip').tooltip({
        placement : 'right'
    });

    $('#showMoreOptionsCB').change( function () {
        mObject.showMoreOptions = this.checked;

    }   );

}


function fUNQ90() {

    if( !advancedMap ) {
        return;
    }


    $('#dynamicFiltersToolTip').tooltip({
        placement : 'right'
    });

    $('#dynamicFiltersCB').change( function () {
        mObject.disAbleDynamicFilters = this.checked;

    }   );
}

// adds the show label check box
function fUNQ91(divId)
{

    var showLabelDiv = $('#showLabelCB');

    if( !advancedMap ||  showLabelDiv.length > 0) {
        return;
    }

    var str =   '<p><label id="showLabelCB_label" for="showLabelCB_CB">show labels ' +
        '<a id="showLabelsToolTip" data-toggle="tooltip" title="Show labels in marker descriptions."><i class="icon-question-sign"></i></a> ' +
        '</label>  ' +
        '<input id="showLabelCB" type="checkbox" name="showLabels" value="Show Labels" checked> </p>';

    $('#' + divId).append(str);

    $('#showLabelsToolTip').tooltip({
        placement : 'right'
    });

    $('#showLabelCB').change( function () {
         mObject.showLabels = this.checked;
       fUNQ27();

   }   );

}

// geo-code the data if necessary, if there is already a lat/long then load the map
function mapPrep() {

    if ( google == undefined ||  google.maps == undefined) {
        fUNQ71('mapPrep');
        return;
    }


    if(mObject.lat > -1 && mObject.lng > -1  &&
        mObject.lat < dataLines[0].length && mObject.lng < dataLines[0].length
        && mObject.lat != mObject.lng ) {


        if(fUNQ187 (dataLines[0][mObject.lat], dataLines[0][mObject.lng ]) ) {

            if( (mObject.emm_lat == -1 && mObject.emm_lng == -1 ) || (mObject.emm_lat != mObject.lat) ||   (mObject.emm_lng != mObject.lng) ) {
                mObject.emm_lat = mObject.lat;
                mObject.emm_lng = mObject.lng;
            }


             var allValidCords = true;
            for(var i = 1; i < dataLines.length; i++) {

                if(!fUNQ187( dataLines[i][mObject.lat ], dataLines[i][mObject.lng ] ))
                {
                    allValidCords = false;
                    break;
                }

            }

            // all the coordinates are valid, so map the data
              if(allValidCords && dataLines.length > 0) {

                  mObject.emm_lat = mObject.lat;
                  mObject.emm_lng = mObject.lng;

                  $('#lineCount').html('<strong> Mapping ' + dataLines.length.toString() + ' items.</strong>');

                  fUNQ75();

                  fUNQ104();

                  return;
              }
        }

    }

     var linesToGeoCode = fUNQ112();


    if(linesToGeoCode > 0) {

      //   TODO: (maybe) display this message in a div
      //  var  preGeoCodedMessage = "Need to geo-code " + linesToGeoCode.toString() + " out of " +  dataLines.length  + " lines.";

        fUNQ92(linesToGeoCode)    ;

        geoCodeStats.geoCoding = true;
        geoCodeStats.StartTime = new Date().getTime();

        fUNQ94();
    }


}


function fUNQ92(linesToGeoCode) {

    // get geo-coding!
    geoCodeStats.linesToGeoCode =  linesToGeoCode;

    if(geoCodeStats.init == true)
    {
        geoCodeStats.linesToGeoCode += geoCodeStats.linesGeoCoded;

        if(geoCodeStats.linesToGeoCode > dataLines.length)
            geoCodeStats.linesToGeoCode = dataLines.length;

        return;
    }

    geoCodeStats.init = true;
    geoCodeStats.allDone = false;
    geoCodeStats.linesGeoCoded = 0;
   // geoCodeStats.geoCoding = true;
    geoCodeStats.geoCodingIdx = 0;
    geoCodeStats.defaultGeoCodeTimeout   =     defaultGeoCodeTimeout;
    geoCodeStats.errors = [];
   // geoCodeStats.errorAddresses = [];
    geoCodeStats.consecutiveTimeouts = 0;
    geoCodeStats.consecutiveErrors = 0;
   // geoCodeStats.StartTime = new Date.getTime();
    geoCodeStats.totalTime = 0;


    geoCodeStats.lastFiveTimes = [0,0,0,0, 0];


    $('#outerProgressDiv').show();
    fUNQ128(0);

    if(geoCodeStats.linesToGeoCode < 20) {
        geoCodeStats.defaultGeoCodeTimeout = 200;
    }
    if(geoCodeStats.linesToGeoCode > 200) {
        geoCodeStats.defaultGeoCodeTimeout = 1000;
    }

    geoCodeStats.lastProcessingTime = 1000 ; //geoCodeStats.defaultGeoCodeTimeout + 100;

    //   var temp = $('#region_sel');


    geoCodeStats.regionCode =  $('#region_sel option:selected').attr('value') ;
    mObject.regionCode = geoCodeStats.regionCode;

}


function fUNQ93() {

      var totalTime = 0;
    var itemsFound = 0;
    for(var i = 0; i < geoCodeStats.lastFiveTimes.length; i++ )
    {
        if(geoCodeStats.lastFiveTimes[i] == 0)
            continue;

        itemsFound++;
        totalTime += geoCodeStats.lastFiveTimes[i];
    }

    if(itemsFound == 0 )
        return   geoCodeStats.lastProcessingTime;

    return Math.ceil(totalTime / itemsFound);
}


function fUNQ94() {

    if(!geoCodeStats.geoCoding   )
        return;

    var address = "";

 /*   if(dataLines.length == geoCodeStats.linesToGeoCode)
    {
        address =  fUNQ162(dataLines[geoCodeStats.geoCodingIdx])  ;
    }
    else {
         */
        var allCached = true;

        for(var i = geoCodeStats.geoCodingIdx; i < dataLines.length; i++)
        {
            if(!fUNQ187(dataLines[i][mObject.emm_lat], dataLines[i][mObject.emm_lng ]))
            {
                geoCodeStats.geoCodingIdx = i;
                address =  fUNQ162(dataLines[geoCodeStats.geoCodingIdx])  ;

                // technically an empty address is cached :-)
                 if(address.trim() == "") {

                     geoCodeStats.errors[ geoCodeStats.errors.length ] = { message: "Empty Address", address: address, lineNumber:  geoCodeStats.geoCodingIdx +1 };
                     continue;
                 }
                if(!geoCodeHash.hasOwnProperty(address))
                {


                    allCached = false;
                    break;
                }
                else {


                    geoCodeStats.linesGeoCoded++;
                    if(mObject.emm_lat > 0 && mObject.emm_lat <= dataLines[i].length)
                        dataLines[i][mObject.emm_lat]  = geoCodeHash[address].emm_lat;

                    if(mObject.emm_lng > 0 && mObject.emm_lng <= dataLines[i].length)
                        dataLines[i][mObject.emm_lng ] =  geoCodeHash[address].emm_lng;

                    if(mObject.emm_acc > 0 && mObject.emm_acc <= dataLines[i].length)
                        dataLines[i][mObject.emm_acc] =  geoCodeHash[address].emm_acc ;
                }
            }
        }

  //  }

    if(allCached) {
        geoCodeStats.geoCodingIdx = dataLines.length;
        fUNQ101();
        // show map
        return;
    }

    if(fUNQ110(address)) {

        fUNQ56(address);
    }
    else {



        // uncomment this for real life.
        if(geoCoder == null )
        {
            geoCoder = new google.maps.Geocoder();

        }


        //  show the line being processed, use the address and show (15 of 20).
        $('#lineVal').html("Processing: " + address + " (" +  (geoCodeStats.linesGeoCoded + 1).toString() + " of " + geoCodeStats.linesToGeoCode.toString() +  ")");


      //      (geoCodeStats.linesToGeoCode - geoCodeStats.linesGeoCoded  ).toString() );
        fUNQ111 ("Estimated time remaining: ", fUNQ93()  * (geoCodeStats.linesToGeoCode - geoCodeStats.linesGeoCoded )  );

        //  return;

        if(geoCodeStats.regionCode.length > 0) {
            geoCoder.geocode({
                'address': address,
                'region': geoCodeStats.regionCode
            }, function (results, status) {

                fUNQ98(results, status, address);
            });
        }
        else {
            geoCoder.geocode({
                'address': address
            }, function (results, status) {

                fUNQ98(results, status, address);
            });
        }

    }

}

function fUNQ95(result, status, address) {

    fUNQ96();

    if (status == "OK") {

        fUNQ97( address, result.latitude, result.longitude , "APPROXIMATE");
    }
    else {
        fUNQ109(status , address)      ;
    }

    fUNQ101();
}


function fUNQ96() {
    geoCodeStats.lastProcessingTime =    (new Date().getTime())  -  geoCodeStats.StartTime;

    geoCodeStats.lastFiveTimes[geoCodeStats.geoCodingIdx % 5]  =     geoCodeStats.lastProcessingTime;

    geoCodeStats.totalTime +=  geoCodeStats.lastProcessingTime ;
    geoCodeStats.StartTime =     new Date().getTime();

}

function fUNQ97(address, lat, lng, type) {

    dataLines[geoCodeStats.geoCodingIdx][mObject.emm_lat] =     lat;
    dataLines[geoCodeStats.geoCodingIdx][mObject.emm_lng] =    lng;
    dataLines[geoCodeStats.geoCodingIdx][mObject.emm_acc] =     type;

    geoCodeHash[address] = {};

    geoCodeHash[address].emm_lat =  lat;
    geoCodeHash[address].emm_lng = lng;
    geoCodeHash[address].emm_acc =  type;



    geoCodeStats.geoCodingIdx++;
    geoCodeStats.linesGeoCoded++;

    geoCodeStats.consecutiveTimeouts = 0;
    geoCodeStats.consecutiveErrors = 0;
}

function fUNQ98(resultArr, status, address) {

    fUNQ96();

    /*
    geoCodeStats.lastProcessingTime =    (new Date().getTime())  -  geoCodeStats.StartTime;

    geoCodeStats.lastFiveTimes[geoCodeStats.geoCodingIdx % 5]  =     geoCodeStats.lastProcessingTime;

    geoCodeStats.totalTime +=  geoCodeStats.lastProcessingTime ;
    geoCodeStats.StartTime =     new Date().getTime();
*/

    if (status == google.maps.GeocoderStatus.OK) {

        fUNQ97(address, resultArr[0].geometry.location.lat().toFixed(6),
            resultArr[0].geometry.location.lng().toFixed(6),  resultArr[0].geometry.location_type);



        // moved to: setSuccessGeo
        /*
        dataLines[geoCodeStats.geoCodingIdx][mObject.emm_lat] =     resultArr[0].geometry.location.lat().toFixed(6);
        dataLines[geoCodeStats.geoCodingIdx][mObject.emm_lng] =     resultArr[0].geometry.location.lat().toFixed(6);
        dataLines[geoCodeStats.geoCodingIdx][mObject.emm_acc] =     resultArr[0].geometry.location_type;

        geoCodeHash[address] = {};

        geoCodeHash[address].emm_lat =  resultArr[0].geometry.location.lat().toFixed(6);
        geoCodeHash[address].emm_lng =  resultArr[0].geometry.location.lng().toFixed(6);
        geoCodeHash[address].emm_acc =  resultArr[0].geometry.location_type;

*/
        //locObject.lat = resultArr[0].geometry.location.lat();
        //locObject.long = resultArr[0].geometry.location.lng();

       /* if (resultArr[0].partial_match != null) {
        }
*/
           /*
        geoCodeStats.geoCodingIdx++;
        geoCodeStats.linesGeoCoded++;

        geoCodeStats.consecutiveTimeouts = 0;
        geoCodeStats.consecutiveErrors = 0;
                                                     */

    } else if (status == google.maps.GeocoderStatus.ZERO_RESULTS) {


        dataLines[geoCodeStats.geoCodingIdx][mObject.emm_acc] =     "No Results";

        fUNQ109("No Results" , address)      ;

        geoCodeStats.consecutiveErrors = 0;

    } else if (status == google.maps.GeocoderStatus.REQUEST_DENIED) {

        fUNQ109("Request Denied" , address)      ;


    } else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {

        geoCodeStats.consecutiveTimeouts++;

        // stop geo-coding due to slowness
         if(geoCodeStats.defaultGeoCodeTimeout >= GEO_CODE_SLOWNESS && geoCodeStats.consecutiveTimeouts > 2) {

         /*   fUNQ75();

             fUNQ103();

             geoCodeStats.geoCoding = false;

              if( geoCodeStats.linesGeoCoded > 0 ) {
                    fUNQ102("Stopped geo-coding due to slowness, do you want to map the geo-coded addresses?");
                }
             else {
                  alert("Stopping geo-coding due to excessive slowness.");

              }

             fUNQ117() ;
             */

             fUNQ100();

            return;
         }

        if( (geoCodeStats.defaultGeoCodeTimeout * 2) < 2000)
            geoCodeStats.defaultGeoCodeTimeout *= 2    ;
        else
            geoCodeStats.defaultGeoCodeTimeout += 1000;


    } else if (status == google.maps.GeocoderStatus.INVALID_REQUEST) {
        fUNQ109("Invalid Request" , address)      ;


    } else if (status == google.maps.GeocoderStatus.UNKNOWN_ERROR) {
        fUNQ109("Unknown Error" , address)      ;

    }

    if( fUNQ93() > GEO_CODE_SLOWNESS) {
        fUNQ100();
        return;
    }

    if(geoCodeStats.linesGeoCoded >= ADDRESS_LIMIT) {
        fUNQ99();
        return;
    }

    fUNQ101();

}

function fUNQ99() {

    fUNQ75();

    fUNQ103();

    geoCodeStats.geoCoding = false;

   fUNQ102("Google slows down geo-coding after " + ADDRESS_LIMIT.toString() + " addresses, would you like to map the completed addresses?");

    if( geoCodeStats.linesGeoCoded > 0) {
        fUNQ111("Finished processing " +  geoCodeStats.linesGeoCoded.toString() + " items in ", geoCodeStats.totalTime );
    }

    fUNQ117() ;


}

function fUNQ100() {

    fUNQ75();

    fUNQ103();

    geoCodeStats.geoCoding = false;

    if( geoCodeStats.linesGeoCoded > 0 ) {
        fUNQ102("Stopped geo-coding due to slowness, do you want to map the geo-coded addresses?");
    }
    else {
        alert("Stopping geo-coding due to excessive slowness.");

    }

    fUNQ117() ;

}


function fUNQ101() {



    fUNQ128 ( (geoCodeStats.linesGeoCoded * 100) / geoCodeStats.linesToGeoCode )      ;


    if(geoCodeStats.errors.length >= 5 && geoCodeStats.linesGeoCoded < 10) {

        fUNQ75();
        geoCodeStats.geoCoding = false;

        alert("Stopping geo-coding due to too many errors, please verify the addresses with errors and try again.");

        fUNQ117();
        fUNQ103();

        return;
    }

    if(dataLines.length == geoCodeStats.geoCodingIdx) {

        fUNQ75();
        geoCodeStats.geoCoding = false;

        // finished geo-coding (yippee!)
        geoCodeStats.allDone = true;

        fUNQ103();

        fUNQ117();

        //  store the start time, and show the total time it took.
        //  $('#timeRemaining').html("Finished " +  geoCodeStats.linesGeoCoded.toString() + " in ");

        if( geoCodeStats.linesGeoCoded > 0) {
            fUNQ111("Finished processing " +  geoCodeStats.linesGeoCoded.toString() + " items in ", geoCodeStats.totalTime );
        }


        if(geoCodeStats.errors.length > 0) {
            $('#lineVal').html("There were " + geoCodeStats.errors.length.toString() + " errors.");

            fUNQ102("Not all addresses can be mapped, do you want to map the addresses without errors?");
        }
        else {
            $('#lineVal').hide();
            fUNQ104();
        }

        return;
    }

    if(geoCodeStats.geoCoding ) {

        setTimeout(function () {
            fUNQ94();
        }, geoCodeStats.defaultGeoCodeTimeout);
    }

    if(geoCodeStats.consecutiveTimeouts == 0) {

        fUNQ103();
    }


}


// the program has stopped geo-coding
function fUNQ102(message) {


    // "Not all addresses can be mapped, do you want to map the addresses without errors?"

    // show a confirmation message if the user wants to show the items on the map if at least 1 successfully geo-coded.
    var confRes = confirm(message);


    if(confRes) {
        fUNQ104();
    }

}


function fUNQ103() {

    if(geoCodeStats.geoCodingIdx < 101  ) {
        fUNQ116()       ;
        // redraw the table for the user

    }
    redrawTextArea() ;
}

 //  need to test this!
// This works!
function fUNQ104() {

    // remove items that don't have a lat/lng since they can't go on the map;
    // also set mObject.lat and mObject.lng

    if(mObject.emm_lat != -1 && mObject.lat!=   mObject.emm_lat   )
        mObject.lat =  mObject.emm_lat;

    if(mObject.emm_lng != -1 && mObject.lng !=   mObject.emm_lng   )
        mObject.lng =  mObject.emm_lng;

    for(var i = dataLines.length -1; i >= 0; i--)
    {
        if(!fUNQ187(dataLines[i][mObject.lat], dataLines[i][mObject.lng] ))
        {
            dataLines.splice(i, 1);
        }

    }


    if(dataLines.length == 0)
    {
        alert("Cannot map the data; no data found with latitude and longitude coordinates.");
        return;
    }

    // disable the options and make map button
    $('#makeMapButton').prop('disabled', 'disabled');
    $('#optionButton').prop('disabled', 'disabled');
    fUNQ105(false);

    //make groups and filters if relevant
    fUNQ34(mObject.columnHeaderArray, dataLines);

    fUNQ45(dataLines) ;

    var mapType =  myMapOptions.indexOf(mObject.selectedMapType)   ;
    mObject.clustering = $('#clusterCB').is(':checked');
    mObject.scrollWheel = $('#scrollWheelCB').is(':checked');

    $('#outerMap').show();
    $('#saveMapDiv').show();

    initMap('map', mapType);

  //  var groupsDiv = $('#groupChecksDiv');
   // var filterDiv =  $('#filtersDiv');



    // move to the map anchor!
    location.hash = "#map";

}


// TODO: might want to allow clustering to able to be toggled
// false -> disables controls
// true -> enables controls.
function fUNQ105(enabled) {


    var tempArray = [];

    // append one array onto the end of another
    tempArray.push.apply(tempArray, matchNames);
    tempArray.push.apply(tempArray, miscIds);

    // all the select boxes:
        for(var i = 0; i < tempArray.length; i++) {

            var selId = $('#' + tempArray[i]) ;

            if(selId.length == 0)
                continue;

            if(enabled == false) {
                selId.attr("disabled", "disabled");
            }
            else {
                selId.removeAttr('disabled');
            }

        }



}

// use this for some type of reset options
function fUNQ106() {

    for(var i = 0; i < matchNames.length; i++) {

        var selId = $('#' + matchNames[i]) ;

        if(selId.length == 0)
            continue;

        selId.remove();

    }


}

  // remove map select and cluster as well
// clear the display and filter selects
function fUNQ107() {

  //  "clusterCB", "noDisplay", "toDisplay", "noFilter", "toFilter", "mapType"

    var tempArray =      ["clusterCB", "scrollWheelCB", "mapType"];
    var i;
    for( i = 0; i < tempArray.length; i++) {

        var selId = $('#' + tempArray[i]) ;

        if(selId.length == 0)
            continue;

        selId.remove();
    }

    tempArray = ["noDisplay", "toDisplay", "noFilter", "toFilter"];

    for( i = 0; i < tempArray.length; i++) {

        var selId = $('#' + tempArray[i]) ;

        if(selId.length == 0)
            continue;

        selId.empty();
    }


}

// TODO: need to test this
function fUNQ108() {

    if(!fUNQ61()) {
        alert("The email address is not valid.");
        return false;
    }

    fUNQ64();

    return true;

}

function fUNQ109(errorMessage, address) {

    geoCodeStats.geoCodingIdx++;

    geoCodeStats.consecutiveTimeouts = 0;
    geoCodeStats.consecutiveErrors++;
    geoCodeStats.linesGeoCoded++;


    geoCodeStats.errors[ geoCodeStats.errors.length ] = { message: errorMessage, address: address, lineNumber:  geoCodeStats.geoCodingIdx +1 };
   // geoCodeStats.errorAddresses[geoCodeStats.errorAddresses.length ] = address;


}

function fUNQ110(potentialIp) {

    var matches = potentialIp.split(".");

    if(matches.length == 4) {

        for(var i = 0; i < matches.length; i++) {

           var potInt =  parseInt(matches[i], 10);

            if(! (potInt >=0 && potInt <= 255))
            {
                return false;
            }
        }

        return true;
    }

    return false;
}

function fUNQ111(msg, timeInMilliseconds) {

    var seconds =   Math.ceil( timeInMilliseconds / 1000);

    var usedSeconds = seconds % 60;

    var minutes = Math.floor(seconds / 60 ) % 60;

    var hours = Math.floor( seconds /  (3600) );

    var resultTime = "";

    if(hours > 0)                                 {
        resultTime = hours.toString() + " hours " + minutes.toString() + " minutes ";
    }
    else if(minutes > 0){

        resultTime =  minutes.toString() + " minutes " + usedSeconds.toString() + " seconds";
    }
    else {
        if (usedSeconds >= 1) {
            resultTime =  usedSeconds.toString() + " seconds";
        }
        else {
            resultTime = "less than 1 second.";
        }
    }

    $('#timeRemaining').html(msg + resultTime);


}

// add headers and columns to the dataLines
function fUNQ112() {

    if(dataLines.length == 0)
        return -1;

    if(dataLines[0].length != mObject.columnHeaderArray.length)
    {
        alert('There is a data mismatch between headers and data');
        return -1;
    }

    var columnsToAdd = 0;
    var totalColumns = mObject.columnHeaderArray.length;
    var geoCodeAllLines = false;
    var linesToGeoCode = 0;

    if(mObject.columnHeaderArray.indexOf('emm_lat') == -1   ) {
        mObject.emm_lat =       mObject.columnHeaderArray.length;
        mObject.columnHeaderArray.push('emm_lat');
        geoCodeAllLines = true  ;
        columnsToAdd++;
    }

    if(mObject.columnHeaderArray.indexOf('emm_lng') == -1  ) {
        mObject.emm_lng =       mObject.columnHeaderArray.length;
        mObject.columnHeaderArray.push('emm_lng');

        geoCodeAllLines = true  ;

        columnsToAdd++;
    }
    if(mObject.columnHeaderArray.indexOf('emm_acc') == -1 ) {
        mObject.emm_acc =       mObject.columnHeaderArray.length;
        mObject.columnHeaderArray.push('emm_acc');

        columnsToAdd++;
    }
  /*  if(mObject.columnHeaderArray.indexOf('emm_other') == -1 && mObject.emm_other == -1) {
        mObject.emm_other =       mObject.columnHeaderArray.length;
        mObject.columnHeaderArray.push('emm_other');

        columnsToAdd++;
    }
    */

    if(columnsToAdd > 0) {
        totalColumns+= columnsToAdd;
        fUNQ113( totalColumns);

    }



    if(geoCodeAllLines )
        return dataLines.length;
    else {


        for(var i = 0; i < dataLines.length; i++) {

            if(!fUNQ187( dataLines[i][mObject.emm_lat ], dataLines[i][mObject.emm_lng ] ))
                linesToGeoCode++;
        }
    }

    return linesToGeoCode;

}

function fUNQ113(totalColumns) {


    for(var i = 0; i < dataLines.length; i++)
    {

        while(dataLines[i].length < totalColumns)
            dataLines[i][dataLines[i].length] = "";

    }


}

function fUNQ114(divId) {

//  var mapOptions = ['Map', 'Terrain', 'Satellite', 'Hybrid'];

    if(  $('#mapType').length > 0 ) {
        return;
    }


    var selStr = fUNQ49(myMapOptions, mObject.selectedMapType, 'mapType', "default map display type");

    selStr = '<p>' +    selStr +   '</p>';

    $('#' + divId).append(selStr);

    jQuery('#mapType').change(function () {

        mObject.selectedMapType = this.value;
    });
}


function fUNQ115() {


    // TODO: might not want fulltrim in the future, might want to trim the individual items.
    var str = mainTextArea.val().fulltrim();

    var lines = str.split("\n");

    var headersSet = false;

    columnHeaderHash = {};
    dataLines.length = 0;


    var totalCount = 0, j;

    for(var i = 0; i < lines.length; i++)
    {
        // ignore '#' and blank lines
        if(lines[i].trim().indexOf("#") == 0 || lines[i].trim() == "") {
            continue;
        }

        var itemArray = lines[i].split("  ");

        if(!headersSet) {
            headersSet = true;

            var itemIdx = 0;

            mObject.headerDisplayOrderIdxs.length = 0;
            mObject.columnHeaderArray.length = 0;


            for ( j = 0; j < itemArray.length; j++) {
                columnHeaderHash[itemArray[j]] = itemIdx;
                mObject.columnHeaderArray.push(itemArray[j].trim());
                mObject.headerDisplayOrderIdxs[mObject.headerDisplayOrderIdxs.length] = itemIdx;
                itemIdx++;
            }

        }
        else {

            for( j = 0; j < itemArray.length; j++)
                itemArray[j] = itemArray[j].trim();

            while (itemArray.length < mObject.columnHeaderArray.length)
                itemArray[itemArray.length] = "";

            dataLines.push(itemArray);
        }
        totalCount++;

    }

    if(totalCount < 2) {
        $('#lineCount').html('<strong>Make sure headers and data are present.</strong>');
    }
    else {
    $('#lineCount').html('<strong>Found ' + totalCount.toString() + ' lines including headers.</strong>');
    }

    return totalCount;

}
//Use this to re-draw the pretty table after an item has been geo-coded!
function fUNQ116() {

     var tableData = "";

    var i ;

     var textLine = "";
     // spit out the header first:
     for( i = 0; i < mObject.columnHeaderArray.length; i++) {
         textLine = textLine + "<th>" + fUNQ84(mObject.columnHeaderArray[i], 25) + "</th>";

     }

     textLine = "<tr>" + textLine + "</tr>";

     tableData += textLine;

     for( i = 0; i < dataLines.length && i < 100; i++) {


         textLine = "";

         for(var j = 0; j < dataLines[i].length; j++)
         {
             textLine += "<td>" + fUNQ84(dataLines[i][j], 25) + "</td>";

         }

         tableData  += "<tr>" + textLine + "</tr>";

     }

     if(dataLines.length > 100 && dataLines.length > 0) {

         tableData  += '<tr><td colspan="' + dataLines[0].length + '">' + MAX_LINE_MESSAGE + '</td></tr>';
     }

     $("#outerDisplayTable").html('<table id="displayTable" class="table table-bordered table-condensed" style="width: 100%;">' + tableData + '</table>');


 }


function fUNQ117() {

    var tableData = "";

    if( geoCodeStats.errors.length  == 0)   {

        $('#errorStuff').hide();

        return;

    }
    else {
        $('#errorStuff').show();
    }



    var textLine = "";
    // spit out the header first:

        textLine = textLine + "<th>Line Number</th><th>Address</th><th>Error Message</th>";



    textLine = "<tr>" + textLine + "</tr>";

    tableData += textLine;

    for(var i = 0; i < geoCodeStats.errors.length && i < 100; i++) {

        textLine = "";

        textLine += "<td>" +geoCodeStats.errors[i].lineNumber + "</td><td>" + geoCodeStats.errors[i].address + "</td><td>" + geoCodeStats.errors[i].message+ "</td>";

        tableData  += "<tr>" + textLine + "</tr>";
    }

    if(geoCodeStats.errors.length > 100 && geoCodeStats.errors.length > 0) {

        tableData  += '<tr><td colspan="3"></td>' + MAX_ERROR_LINE_MESSAGE + '</tr>';
    }

    $("#prettyErrorTable").html('<table id="errorTable" class="table table-bordered table-condensed" style="width: 100%">' + tableData + '</table>');


}


//  the next large section is code to match the headers!


//function saveColumnSettings

function fUNQ118(columnHeaders) {



    fUNQ123(columnHeaders, addressMatch, negAddressMatch , matchNames[0]);

    fUNQ123(columnHeaders, cityMatch, [] , matchNames[1]);
    fUNQ123(columnHeaders, stateMatch, [] , matchNames[2]);
    fUNQ123(columnHeaders, zipMatch, [] , matchNames[3]);
    fUNQ123(columnHeaders, countryMatch, [] , matchNames[4]);
    fUNQ123(columnHeaders, latMatch, [] , matchNames[5]);
    fUNQ123(columnHeaders, longMatch, [] , matchNames[6]);
    fUNQ123(columnHeaders, titleMatch, [] , matchNames[7]);
    fUNQ123(columnHeaders, urlMatch, [] , matchNames[8]);
    fUNQ123(columnHeaders, imageMatch, [] , matchNames[9]);
    fUNQ123(columnHeaders, emailMatch, [] , matchNames[10]);
    fUNQ123(columnHeaders, groupMatch, [] , matchNames[11]);
  //  fUNQ123(columnHeaders, iconMatch, [] , matchNames[11]);

    for(var i = 0 ; i < matchNames.length && i < labelNames.length; i++)
    {
        fUNQ120(matchNames[i], labelNames[i]);
        /*  if(i < 7) {
         fUNQ119(matchNames[i], labelNames[i]);
         }
         else {
         fUNQ120(matchNames[i], labelNames[i]);
         }
         */
    }

}

// don't allow anymore data into any of the location columns
/*
function fUNQ119(matchName, labelName) {

    // don't add anything to the drop down besides what was matched

    var matchingColumnsIds = ["-1"];
    var matchingColumns = ["none"];
    var selectedColumn = "none";

    var matchingIdxs = selectFilterMatch[matchName] ;

    if(matchingIdxs != null && matchingIdxs.length > 0) {

        for(var i = 0; i < matchingIdxs.length; i++) {

            if(matchingIdxs[i] < mObject.columnHeaderArray.length)
            {
                matchingColumnsIds.push(matchingIdxs[i]);
                matchingColumns.push(mObject.columnHeaderArray[matchingIdxs[i]]);

                if(selectedColumn == "none")
                {
                    selectedColumn = mObject.columnHeaderArray[matchingIdxs[i]];

                    // ignore the 'preferred location header idx
                    locationHeaderIdx.push(matchingIdxs[i]);
                }
            }
            else
            {
            }

        }

    }

    fUNQ121(matchingColumns, matchingColumnsIds, selectedColumn, matchName, labelName);
}
*/

// look at the data items for urls, email, etc to verify they fit (or just be lazy)
function fUNQ120(matchName, labelName) {

    var matchingColumnsIds = ["-1"];
    var matchingColumns = ["none"];
    var selectedColumn = "none";

    var matchingIdxs = selectFilterMatch[matchName] ;

    if(matchingIdxs != null && matchingIdxs.length > 0 &&  matchingIdxs[0] < mObject.columnHeaderArray.length )
    {
        selectedColumn =   mObject.columnHeaderArray[matchingIdxs[0]];
    }

    for(var i = 0; i < mObject.columnHeaderArray.length; i++  )        {

        // don't allow the reserved items to be selected, unless it is a match
        if(reservedMatches.indexOf(mObject.columnHeaderArray ) >= 0 &&   reservedMatches.indexOf( selectedColumn) < 0)
            continue;

        matchingColumns.push(mObject.columnHeaderArray[i]);
        matchingColumnsIds.push(i);
    }

    fUNQ121(matchingColumns, matchingColumnsIds, selectedColumn, matchName, labelName);

}


function fUNQ121(selectableItems, selItemsIdx, selectedItem, selectId, labelName) {


    var labelStr = '<label id="' + selectId + '_label" for="' + selectId + '">' + labelName  + '</label>';
    var selStr = '<select name="' + selectId + '" id="' + selectId + '"> \n';

    var selOptions = "";

    for (var i = 0; i < selectableItems.length; i++) {

        if (selectableItems[i] == selectedItem) {
            selOptions += '<option value="' + selItemsIdx[i] + '" selected>' +

                selectableItems[i] + '</option>\n';

            selected_columns[selectId] = selItemsIdx[i];


        } else {
            selOptions += '<option value="' + selItemsIdx[i] + '" >' +

                selectableItems[i] + '</option>\n';
        }
    }

    selStr = selStr.concat(selOptions + '</select>');


    var selectorId =     $('#' + selectId);

    if( selectorId.length > 0 ) {
        selectorId.html(selOptions);
    }
    else {

        var appendStr = '<p>' + labelStr + selStr + '</p>';

        $('#selectorData').append(appendStr);
        // $('#selectorData').append(selStr);


        jQuery("#" + selectId).change(function () {


            selected_columns[selectId] = parseInt(this.value, 10) ;

            fUNQ122();
        });

    }
}

function fUNQ122() {

    fUNQ127();
    fUNQ27();

    fUNQ76();
    // likely want to do something else as well, such as with the marker display.
}



// puts the indexes of the column headers in the selectFilterMatch hash with the key being the name of the selector
function fUNQ123(columnHeaders, matchArray, negArray, matchName) {

    for (var key in columnHeaders) {

        if (columnHeaders.hasOwnProperty(key)) {

            var headerIdx = columnHeaders[key];

            var splitHeader = key.toLowerCase().split(" ");

            if (fUNQ66(splitHeader, matchArray)) {

                if (negArray == null || negArray.length == 0 || !fUNQ66(splitHeader, negArray)) {


                    var matchingIdxs ;
                    if (selectFilterMatch.hasOwnProperty(matchName)) {
                        matchingIdxs = selectFilterMatch[matchName];
                        matchingIdxs.push(headerIdx);
                    } else {
                         matchingIdxs = [];
                        matchingIdxs.push(headerIdx);
                        selectFilterMatch[matchName] = matchingIdxs;
                    }


                }
            }
        }
    }
}

// returns true if one items is in the other array
/*function fUNQ66(a1, a2) {

    for (var item in a1) {
        if (fUNQ67(a1[item], a2)) {
            return true;
        }
    }
    return false;
}
  */



// returns true if the value is a valid date
function fUNQ124(d) {
    if (Object.prototype.toString.call(d) !== "[object Date]") return false;
    return !isNaN(d.getTime());
}

/*
function fUNQ125(columnHeaders) {


    // go for the first column that matches "group" case insensitive

    var exactGroupPattern = /\bgroup\b/i;

    var key ;

    for ( key in columnHeaders) {
        // use hasOwnProperty to filter out keys from the Object.prototype
        if (columnHeaders.hasOwnProperty(key)) {

            //
            //alert('key is: ' + k + ', value is: ' + h[k]);
            if ("group" == columnHeaders[key].toLowerCase().trim()) {
                return key;
            }

        }
    }

    // nothing found, so go with a word boundary :
    for ( key in columnHeaders) {
        // use hasOwnProperty to filter out keys from the Object.prototype
        if (columnHeaders.hasOwnProperty(key)) {

            //
            //alert('key is: ' + k + ', value is: ' + h[k]);
            if (exactGroupPattern.test(columnHeaders[key]) == true) {
                return key;
            }
        }

        // none found
      //  return -1;

    }

    return -1;
}
*/

// returns the index value corresponding to the column header
function fUNQ126(name) {

    var idx = prettyMatchNames.indexOf(name);

    if(idx != -1) {
        var key = matchNames[idx];

        if(selected_columns.hasOwnProperty(key) ) {

            return selected_columns[key];
        }
    }

    return -1;

}

// sets the column header index value (or -1 if there isn't one) for values on the mObject
function fUNQ127() {


    mObject.address =   fUNQ126("address");
    mObject.city =  fUNQ126("city");
    mObject.state = fUNQ126("state");
    mObject.zip = fUNQ126("zip");
    mObject.country = fUNQ126("country");
    mObject.lat = fUNQ126("lat");
    mObject.lng = fUNQ126("long");
    mObject.title = fUNQ126("title");
    mObject.web = fUNQ126("url");
    mObject.image = fUNQ126("image");
    mObject.email = fUNQ126("email");
    mObject.group = fUNQ126("group");
    //   mObject.pin = fUNQ126("icon");


}

// update the progress bar:
function fUNQ128(percentage) {

    var percentageStr = percentage.toString() + '%';

    $('#progressDisplayDiv').css( 'width', percentageStr );

}


// some general utilities:

// add trim where it does not exist, mainly IE 8 and below.
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g,'');
    }
}

function fUNQ129() {


    var qs = (location.pathname.length > 0 ? location.pathname.substring(1) : ""),
        items = qs.length ? qs.split("/") : [];

    var mapType = 'basic';

    if(items.length == 1) {
        mapType = items[0];

    }

    if(mObject.mapType == null && (mapType == 'advanced' || mapType =='basic'))
            mObject.mapType = mapType;


        return (mObject.mapType == 'advanced');

}

String.prototype.endsWith = function (s) {
    return this.length >= s.length && this.substr(this.length - s.length) == s;
}

function fUNQ5(message, status){

    var aliasDiv = $('#aliasStatusDiv');

    aliasDiv.html("<strong>" + message + "</strong>");


    if(!aliasDiv.hasClass("alert"))
    {
        aliasDiv.addClass("alert");
    }


    if(status == "error") {
        // TODO : set the text color to red

        if(!aliasDiv.hasClass("alert-error"))
        {
            aliasDiv.addClass("alert-error");
        }

        if(aliasDiv.hasClass("alert-success"))
        {
            aliasDiv.removeClass("alert-success")  ;
        }
    }
    else {
        if(aliasDiv.hasClass("alert-error"))
        {
            aliasDiv.removeClass("alert-error");
        }

        if(!aliasDiv.hasClass("alert-success"))
        {
            aliasDiv.addClass("alert-success")  ;
        }

    }
}

function fUNQ6(potentialAlias, callbackFunc) {


    $.ajax({
        type: 'POST',
        url: '/modifyAlias',
        data: { id: userSettings.name, alias: potentialAlias  },
        cache: false,
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
             //   alert(data.errorMessage);
                fUNQ5 (data.errorMessage, "error");
            }

            else  if(data.status == "Saved") {
                //  $('#aliasStatusDiv').html("Url Saved");

                fUNQ5("Url Saved", "success");

                if(callbackFunc != null) {
                    callbackFunc(potentialAlias);
                }

            }
            else {
                fUNQ5("Unable to save url", "error");
                //  $('#aliasStatusDiv').html("Unable to save url");
            }

            //$("#resultDiv").html(result);



        },
        error:function(data, status, result){

            // $('#map').html("The map could not be loaded");

            fUNQ5 (data.errorMessage, "error");



        }
    });

}


function fUNQ130() {
    $('#editable_url_btn').hide();
    $('#edit-slug-buttons').show();

    var aliasStatusDiv = $('#aliasStatusDiv');
    aliasStatusDiv.html("");
    aliasStatusDiv.removeClass();

    var editableUrl = $('#editable-url');

    var origUrl = editableUrl.html();
    editableUrl.hide();

    var modUrl =  $('#mod-url');

    modUrl.html('<input type="text" value="' + origUrl + '" id="new-post-slug" MAXLENGTH=100 >');
    modUrl.show();

    $('#aliasInstDiv').show();

}

function fUNQ131() {

    var newUrl = $('#new-post-slug').val();

    // make an ajax call

    if(newUrl.length > 0 && fUNQ31( newUrl ))    {
            fUNQ6(newUrl, successUrlChange);

        }
        else {
            //    var aliasDiv = $('#aliasStatusDiv');
            //  set the text color to red
            //  aliasDiv.html("Invalid alias.");

            fUNQ5 ("Invalid alias.", "error");

        }



}

function successUrlChange( newUrl) {

    // then modify stuff for okay:
    $('#mod-url').hide();

    var editableUrl = $('#editable-url');
    editableUrl.html(newUrl);
    editableUrl.show();

    var mapFullUrl =   location.protocol + "//" + location.hostname + "/map/" + newUrl;
    $('#genMapUrl').attr("href", mapFullUrl );


    $('#edit-slug-buttons').hide();
    $('#editable_url_btn').show();
    $('#aliasInstDiv').hide();
}

function fUNQ132() {
    $('#edit-slug-buttons').hide();
    $('#editable_url_btn').show();

    $('#mod-url').hide();
    $('#editable-url').show();

    $('#aliasInstDiv').hide();

    var aliasStatusDiv = $('#aliasStatusDiv');
    aliasStatusDiv.html("");
    aliasStatusDiv.removeClass();
}