/**
 * Created with JetBrains WebStorm.
 * User: Erran
 * Date: 3/29/13
 * Time: 7:02 PM
 * To change this template use File | Settings | File Templates.
 */

          /*
// header / description information:
var columnHeaderArray = [];  // the index corresponds to a name (the header)
var headerDisplayOrderIdxs = [];  // has the headers in the order from the display marker

// group stuff
var groupHash = {};  // maps group names to index values in the lines/ array for Markers
var sortedGroupKeys = [];  // the keys of the above array in sorted order!
var groupImageHash = {};  // maps the group name to the image value (location).


var dataLines = [];   // the data for each line, minus the header, post split (this is an array that contains arrays)

var groupImageHash = {};  // maps the group name to the image value (location).

// filter stuff
var filterListNames = [];  // contains the names of the filters
var filterListArray = [];  //  the value is a hash with the names
var filterListSortedKeyHash = {};  // the key is the filter name,
// the value is a list of keys (the key into the values for the filterListArray



var selectedMapType = 'Street';
                   */


var myMapOptions = ['Street', 'Terrain', 'Satellite', 'Hybrid'];

var GOOGLE_MAPS_VERSION = "";

var MAX_PINS = 20000;
var MAX_FREE_GEO = 250;

var MAX_GROUPS = 10;
var MAX_FILTERS = 4;
var MAX_FILTER_SIZE = 200;

// use this for the kml
var BASE_IMAGE_URL = 'http://images.easymapmaker.com';

var IMAGE_PATH = '/marker_images/';
var IMG_LIST = ["red", "blue", "green", "yellow", "orange", "purple", "brown", "pink", "dark_green", "pale_blue", "dark_pink"];

var IMG_FILE_ENDING = "_Marker.png";
var IMG_HEX_COLORS = ["FF776B", "6B98FF", "97EC7D", "FFED5C", "FD8D08", "C89BFF", "CB9D7C", "FDABFF", "01BF00", "BCE3FF", "E14F9E"];

var DOT_IMAGE = "dot_";

var SMALL_IMAGE= "small_";

var DEFAULT_SHADOW = "shadow.png";

var DEFAULT_SHAPE = {
    coord: [13,0,15,1,16,2,17,3,18,4,18,5,19,6,19,7,19,8,19,9,19,10,19,11,19,12,19,13,18,14,18,15,17,16,16,17,15,18,14,19,14,20,13,21,13,22,12,23,12,24,12,25,12,26,11,27,11,28,11,29,11,30,11,31,11,32,11,33,8,33,8,32,8,31,8,30,8,29,8,28,8,27,8,26,7,25,7,24,7,23,6,22,6,21,5,20,5,19,4,18,3,17,2,16,1,15,1,14,0,13,0,12,0,11,0,10,0,9,0,8,0,7,0,6,1,5,1,4,2,3,3,2,4,1,6,0,13,0],
    type: 'poly'
};

// default  image stuff:
var DEFAULT_IMG_SIZE = [20,34];
var DEFAULT_IMG_ORIGIN = [0,0]        ;
var DEFAULT_IMG_ANCHOR = [10,34];


// default  shadow image stuff:
var DEFAULT_IMG_SIZE = [40,34];
var DEFAULT_IMG_ORIGIN = [0,0]        ;
var DEFAULT_IMG_ANCHOR = [10,34];


var ALL_FILTER = "All";


// used to store the selected filter keys.  The array is in parallel with the filter names array, the value is the item 'filter name' selected
// from the drop down.
var selectedFilterValues = [];




// don't filter on any of the above, except for group!

// maps  the select box name to the index value in the header.
//var selected_columns = {};

var userSettings = {};
 userSettings.email = null;
 userSettings.title = null;
 userSettings.description = null;
 userSettings.protectionLevel = null;
 userSettings.alias = null;
 userSettings.view_count = null;
 userSettings.name = null;
 userSettings.autoDelete = null;
 userSettings.dataOnPage = null;
 userSettings.genKML = null;
 //userSettings.mayType = 'basic';               // basic and advanced for now

var mObject = {};
mObject.address = null;
mObject.city = null;
mObject.state = null;
mObject.zip = null;
mObject.country = null;
mObject.lat = null;
mObject.lng = null;
mObject.title = null;
mObject.web = null;
mObject.image = null;
mObject.email = null;
mObject.group = null;
mObject.mapType = null; // valid values are 'baisc', 'advanced'
//mObject.pin = null;   // the pin (icon is disabled for now)

mObject.regionCode = "";
mObject.regionCountry = "Auto-Detect";
mObject.showLabels = true;

// results from geo_coding, the location in the data-line columns; -1 means not present
mObject.emm_lat = -1;
mObject.emm_lng = -1;
mObject.emm_acc = -1;
//mObject.emm__other = -1;

mObject.selectedMapType = 'Street';

// true if the data should be displayed below the map on the page.
mObject.displayDataOnPage = false;
mObject.clustering = true;

// new as of 10/28/2013
mObject.showMoreOptions = null;
mObject.disAbleDynamicFilters = null;

// use the scrollwheel
mObject.scrollWheel = false;

// header / description information:
mObject.columnHeaderArray = [];    // the index corresponds to a name (the header)
mObject.headerDisplayOrderIdxs = [];  // has the headers in the order from the display marker
mObject.groupHash = {};  // maps group names to index values in the lines/ array for Markers
mObject.sortedGroupKeys = [];  // the keys of the above array in sorted order!
mObject.groupImageHash = {};  // maps the group name to the image value (location).


// filter stuff
mObject.filterListNames = [];  // contains the names of the filters
mObject.filterListArray = [];  //  the value is a hash with the names
mObject.filterListSortedKeyHash = {};  // the key is the filter name,
mObject.filterColumnIdxs = [];
// the value is a list of keys (the key into the values for the filterListArray


// the marker index maps to an image color index (in the IMG_LIST)
mObject.markerImageIdx = [];

/*
 var labelNames = ["Address", "City", "Zip Code", "State / Province", "Country", "Latitude", "Longitude",
 "Marker Title", "Url (website)", "(website) Image", "(website) E-mail", "Group", "(Marker) Icon/Pin"
 ];

 */

//JSON.stringify(mObject)    ;

// return true if i is one of the selected items other than the group or pin
function isIgnoreSearchColumn(i) {
    return (i== mObject.lat || i == mObject.lng ||
        i == mObject.web ||
        i == mObject.image )    ;
}

// return true if i is one of the selected items other than the group or pin
function isSelectedColumn(i) {
    return (i== mObject.lat || i == mObject.lng ||
        i == mObject.address ||
        i == mObject.city || i == mObject.state || i == mObject.zip ||
        i == mObject.country || i ==  mObject.title || i == mObject.web ||
        i == mObject.image || i == mObject.email)    ;
}

function urlizeUrl(s) {

    if (s.length > 0 && !s.match(/^(https?|ftp):\/\//))
        return 'http://' + s;

    return s;
}/*! jQuery UI - v1.10.3 - 2013-05-15
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.position.js, jquery.ui.autocomplete.js, jquery.ui.menu.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
  runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
  version: "1.10.3",

  keyCode: {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    NUMPAD_ADD: 107,
    NUMPAD_DECIMAL: 110,
    NUMPAD_DIVIDE: 111,
    NUMPAD_ENTER: 108,
    NUMPAD_MULTIPLY: 106,
    NUMPAD_SUBTRACT: 109,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  }
});

// plugins
$.fn.extend({
  focus: (function( orig ) {
    return function( delay, fn ) {
      return typeof delay === "number" ?
        this.each(function() {
          var elem = this;
          setTimeout(function() {
            $( elem ).focus();
            if ( fn ) {
              fn.call( elem );
            }
          }, delay );
        }) :
        orig.apply( this, arguments );
    };
  })( $.fn.focus ),

  scrollParent: function() {
    var scrollParent;
    if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
      scrollParent = this.parents().filter(function() {
        return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
      }).eq(0);
    } else {
      scrollParent = this.parents().filter(function() {
        return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
      }).eq(0);
    }

    return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
  },

  zIndex: function( zIndex ) {
    if ( zIndex !== undefined ) {
      return this.css( "zIndex", zIndex );
    }

    if ( this.length ) {
      var elem = $( this[ 0 ] ), position, value;
      while ( elem.length && elem[ 0 ] !== document ) {
        // Ignore z-index if position is set to a value where z-index is ignored by the browser
        // This makes behavior of this function consistent across browsers
        // WebKit always returns auto if the element is positioned
        position = elem.css( "position" );
        if ( position === "absolute" || position === "relative" || position === "fixed" ) {
          // IE returns 0 when zIndex is not specified
          // other browsers return a string
          // we ignore the case of nested elements with an explicit value of 0
          // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
          value = parseInt( elem.css( "zIndex" ), 10 );
          if ( !isNaN( value ) && value !== 0 ) {
            return value;
          }
        }
        elem = elem.parent();
      }
    }

    return 0;
  },

  uniqueId: function() {
    return this.each(function() {
      if ( !this.id ) {
        this.id = "ui-id-" + (++uuid);
      }
    });
  },

  removeUniqueId: function() {
    return this.each(function() {
      if ( runiqueId.test( this.id ) ) {
        $( this ).removeAttr( "id" );
      }
    });
  }
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
  var map, mapName, img,
    nodeName = element.nodeName.toLowerCase();
  if ( "area" === nodeName ) {
    map = element.parentNode;
    mapName = map.name;
    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
      return false;
    }
    img = $( "img[usemap=#" + mapName + "]" )[0];
    return !!img && visible( img );
  }
  return ( /input|select|textarea|button|object/.test( nodeName ) ?
    !element.disabled :
    "a" === nodeName ?
      element.href || isTabIndexNotNaN :
      isTabIndexNotNaN) &&
    // the element and all of its ancestors must be visible
    visible( element );
}

function visible( element ) {
  return $.expr.filters.visible( element ) &&
    !$( element ).parents().addBack().filter(function() {
      return $.css( this, "visibility" ) === "hidden";
    }).length;
}

$.extend( $.expr[ ":" ], {
  data: $.expr.createPseudo ?
    $.expr.createPseudo(function( dataName ) {
      return function( elem ) {
        return !!$.data( elem, dataName );
      };
    }) :
    // support: jQuery <1.8
    function( elem, i, match ) {
      return !!$.data( elem, match[ 3 ] );
    },

  focusable: function( element ) {
    return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
  },

  tabbable: function( element ) {
    var tabIndex = $.attr( element, "tabindex" ),
      isTabIndexNaN = isNaN( tabIndex );
    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
  }
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
  $.each( [ "Width", "Height" ], function( i, name ) {
    var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
      type = name.toLowerCase(),
      orig = {
        innerWidth: $.fn.innerWidth,
        innerHeight: $.fn.innerHeight,
        outerWidth: $.fn.outerWidth,
        outerHeight: $.fn.outerHeight
      };

    function reduce( elem, size, border, margin ) {
      $.each( side, function() {
        size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
        if ( border ) {
          size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
        }
        if ( margin ) {
          size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
        }
      });
      return size;
    }

    $.fn[ "inner" + name ] = function( size ) {
      if ( size === undefined ) {
        return orig[ "inner" + name ].call( this );
      }

      return this.each(function() {
        $( this ).css( type, reduce( this, size ) + "px" );
      });
    };

    $.fn[ "outer" + name] = function( size, margin ) {
      if ( typeof size !== "number" ) {
        return orig[ "outer" + name ].call( this, size );
      }

      return this.each(function() {
        $( this).css( type, reduce( this, size, true, margin ) + "px" );
      });
    };
  });
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
  $.fn.addBack = function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter( selector )
    );
  };
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
  $.fn.removeData = (function( removeData ) {
    return function( key ) {
      if ( arguments.length ) {
        return removeData.call( this, $.camelCase( key ) );
      } else {
        return removeData.call( this );
      }
    };
  })( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
  disableSelection: function() {
    return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
      ".ui-disableSelection", function( event ) {
        event.preventDefault();
      });
  },

  enableSelection: function() {
    return this.unbind( ".ui-disableSelection" );
  }
});

$.extend( $.ui, {
  // $.ui.plugin is deprecated. Use $.widget() extensions instead.
  plugin: {
    add: function( module, option, set ) {
      var i,
        proto = $.ui[ module ].prototype;
      for ( i in set ) {
        proto.plugins[ i ] = proto.plugins[ i ] || [];
        proto.plugins[ i ].push( [ option, set[ i ] ] );
      }
    },
    call: function( instance, name, args ) {
      var i,
        set = instance.plugins[ name ];
      if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
        return;
      }

      for ( i = 0; i < set.length; i++ ) {
        if ( instance.options[ set[ i ][ 0 ] ] ) {
          set[ i ][ 1 ].apply( instance.element, args );
        }
      }
    }
  },

  // only used by resizable
  hasScroll: function( el, a ) {

    //If overflow is hidden, the element might have extra content, but the user wants to hide it
    if ( $( el ).css( "overflow" ) === "hidden") {
      return false;
    }

    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
      has = false;

    if ( el[ scroll ] > 0 ) {
      return true;
    }

    // TODO: determine which cases actually cause this to happen
    // if the element doesn't have the scroll set, see if it's possible to
    // set the scroll
    el[ scroll ] = 1;
    has = ( el[ scroll ] > 0 );
    el[ scroll ] = 0;
    return has;
  }
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
  slice = Array.prototype.slice,
  _cleanData = $.cleanData;
$.cleanData = function( elems ) {
  for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
    try {
      $( elem ).triggerHandler( "remove" );
    // http://bugs.jquery.com/ticket/8235
    } catch( e ) {}
  }
  _cleanData( elems );
};

$.widget = function( name, base, prototype ) {
  var fullName, existingConstructor, constructor, basePrototype,
    // proxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    proxiedPrototype = {},
    namespace = name.split( "." )[ 0 ];

  name = name.split( "." )[ 1 ];
  fullName = namespace + "-" + name;

  if ( !prototype ) {
    prototype = base;
    base = $.Widget;
  }

  // create selector for plugin
  $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
    return !!$.data( elem, fullName );
  };

  $[ namespace ] = $[ namespace ] || {};
  existingConstructor = $[ namespace ][ name ];
  constructor = $[ namespace ][ name ] = function( options, element ) {
    // allow instantiation without "new" keyword
    if ( !this._createWidget ) {
      return new constructor( options, element );
    }

    // allow instantiation without initializing for simple inheritance
    // must use "new" keyword (the code above always passes args)
    if ( arguments.length ) {
      this._createWidget( options, element );
    }
  };
  // extend with the existing constructor to carry over any static properties
  $.extend( constructor, existingConstructor, {
    version: prototype.version,
    // copy the object used to create the prototype in case we need to
    // redefine the widget later
    _proto: $.extend( {}, prototype ),
    // track widgets that inherit from this widget in case this widget is
    // redefined after a widget inherits from it
    _childConstructors: []
  });

  basePrototype = new base();
  // we need to make the options hash a property directly on the new instance
  // otherwise we'll modify the options hash on the prototype that we're
  // inheriting from
  basePrototype.options = $.widget.extend( {}, basePrototype.options );
  $.each( prototype, function( prop, value ) {
    if ( !$.isFunction( value ) ) {
      proxiedPrototype[ prop ] = value;
      return;
    }
    proxiedPrototype[ prop ] = (function() {
      var _super = function() {
          return base.prototype[ prop ].apply( this, arguments );
        },
        _superApply = function( args ) {
          return base.prototype[ prop ].apply( this, args );
        };
      return function() {
        var __super = this._super,
          __superApply = this._superApply,
          returnValue;

        this._super = _super;
        this._superApply = _superApply;

        returnValue = value.apply( this, arguments );

        this._super = __super;
        this._superApply = __superApply;

        return returnValue;
      };
    })();
  });
  constructor.prototype = $.widget.extend( basePrototype, {
    // TODO: remove support for widgetEventPrefix
    // always use the name + a colon as the prefix, e.g., draggable:start
    // don't prefix for widgets that aren't DOM-based
    widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
  }, proxiedPrototype, {
    constructor: constructor,
    namespace: namespace,
    widgetName: name,
    widgetFullName: fullName
  });

  // If this widget is being redefined then we need to find all widgets that
  // are inheriting from it and redefine all of them so that they inherit from
  // the new version of this widget. We're essentially trying to replace one
  // level in the prototype chain.
  if ( existingConstructor ) {
    $.each( existingConstructor._childConstructors, function( i, child ) {
      var childPrototype = child.prototype;

      // redefine the child widget using the same prototype that was
      // originally used, but inherit from the new version of the base
      $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
    });
    // remove the list of existing child constructors from the old constructor
    // so the old child constructors can be garbage collected
    delete existingConstructor._childConstructors;
  } else {
    base._childConstructors.push( constructor );
  }

  $.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
  var input = slice.call( arguments, 1 ),
    inputIndex = 0,
    inputLength = input.length,
    key,
    value;
  for ( ; inputIndex < inputLength; inputIndex++ ) {
    for ( key in input[ inputIndex ] ) {
      value = input[ inputIndex ][ key ];
      if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
        // Clone objects
        if ( $.isPlainObject( value ) ) {
          target[ key ] = $.isPlainObject( target[ key ] ) ?
            $.widget.extend( {}, target[ key ], value ) :
            // Don't extend strings, arrays, etc. with objects
            $.widget.extend( {}, value );
        // Copy everything else by reference
        } else {
          target[ key ] = value;
        }
      }
    }
  }
  return target;
};

$.widget.bridge = function( name, object ) {
  var fullName = object.prototype.widgetFullName || name;
  $.fn[ name ] = function( options ) {
    var isMethodCall = typeof options === "string",
      args = slice.call( arguments, 1 ),
      returnValue = this;

    // allow multiple hashes to be passed on init
    options = !isMethodCall && args.length ?
      $.widget.extend.apply( null, [ options ].concat(args) ) :
      options;

    if ( isMethodCall ) {
      this.each(function() {
        var methodValue,
          instance = $.data( this, fullName );
        if ( !instance ) {
          return $.error( "cannot call methods on " + name + " prior to initialization; " +
            "attempted to call method '" + options + "'" );
        }
        if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
          return $.error( "no such method '" + options + "' for " + name + " widget instance" );
        }
        methodValue = instance[ options ].apply( instance, args );
        if ( methodValue !== instance && methodValue !== undefined ) {
          returnValue = methodValue && methodValue.jquery ?
            returnValue.pushStack( methodValue.get() ) :
            methodValue;
          return false;
        }
      });
    } else {
      this.each(function() {
        var instance = $.data( this, fullName );
        if ( instance ) {
          instance.option( options || {} )._init();
        } else {
          $.data( this, fullName, new object( options, this ) );
        }
      });
    }

    return returnValue;
  };
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
  widgetName: "widget",
  widgetEventPrefix: "",
  defaultElement: "<div>",
  options: {
    disabled: false,

    // callbacks
    create: null
  },
  _createWidget: function( options, element ) {
    element = $( element || this.defaultElement || this )[ 0 ];
    this.element = $( element );
    this.uuid = uuid++;
    this.eventNamespace = "." + this.widgetName + this.uuid;
    this.options = $.widget.extend( {},
      this.options,
      this._getCreateOptions(),
      options );

    this.bindings = $();
    this.hoverable = $();
    this.focusable = $();

    if ( element !== this ) {
      $.data( element, this.widgetFullName, this );
      this._on( true, this.element, {
        remove: function( event ) {
          if ( event.target === element ) {
            this.destroy();
          }
        }
      });
      this.document = $( element.style ?
        // element within the document
        element.ownerDocument :
        // element is window or document
        element.document || element );
      this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
    }

    this._create();
    this._trigger( "create", null, this._getCreateEventData() );
    this._init();
  },
  _getCreateOptions: $.noop,
  _getCreateEventData: $.noop,
  _create: $.noop,
  _init: $.noop,

  destroy: function() {
    this._destroy();
    // we can probably remove the unbind calls in 2.0
    // all event bindings should go through this._on()
    this.element
      .unbind( this.eventNamespace )
      // 1.9 BC for #7810
      // TODO remove dual storage
      .removeData( this.widgetName )
      .removeData( this.widgetFullName )
      // support: jquery <1.6.3
      // http://bugs.jquery.com/ticket/9413
      .removeData( $.camelCase( this.widgetFullName ) );
    this.widget()
      .unbind( this.eventNamespace )
      .removeAttr( "aria-disabled" )
      .removeClass(
        this.widgetFullName + "-disabled " +
        "ui-state-disabled" );

    // clean up events and states
    this.bindings.unbind( this.eventNamespace );
    this.hoverable.removeClass( "ui-state-hover" );
    this.focusable.removeClass( "ui-state-focus" );
  },
  _destroy: $.noop,

  widget: function() {
    return this.element;
  },

  option: function( key, value ) {
    var options = key,
      parts,
      curOption,
      i;

    if ( arguments.length === 0 ) {
      // don't return a reference to the internal hash
      return $.widget.extend( {}, this.options );
    }

    if ( typeof key === "string" ) {
      // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
      options = {};
      parts = key.split( "." );
      key = parts.shift();
      if ( parts.length ) {
        curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
        for ( i = 0; i < parts.length - 1; i++ ) {
          curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
          curOption = curOption[ parts[ i ] ];
        }
        key = parts.pop();
        if ( value === undefined ) {
          return curOption[ key ] === undefined ? null : curOption[ key ];
        }
        curOption[ key ] = value;
      } else {
        if ( value === undefined ) {
          return this.options[ key ] === undefined ? null : this.options[ key ];
        }
        options[ key ] = value;
      }
    }

    this._setOptions( options );

    return this;
  },
  _setOptions: function( options ) {
    var key;

    for ( key in options ) {
      this._setOption( key, options[ key ] );
    }

    return this;
  },
  _setOption: function( key, value ) {
    this.options[ key ] = value;

    if ( key === "disabled" ) {
      this.widget()
        .toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
        .attr( "aria-disabled", value );
      this.hoverable.removeClass( "ui-state-hover" );
      this.focusable.removeClass( "ui-state-focus" );
    }

    return this;
  },

  enable: function() {
    return this._setOption( "disabled", false );
  },
  disable: function() {
    return this._setOption( "disabled", true );
  },

  _on: function( suppressDisabledCheck, element, handlers ) {
    var delegateElement,
      instance = this;

    // no suppressDisabledCheck flag, shuffle arguments
    if ( typeof suppressDisabledCheck !== "boolean" ) {
      handlers = element;
      element = suppressDisabledCheck;
      suppressDisabledCheck = false;
    }

    // no element argument, shuffle and use this.element
    if ( !handlers ) {
      handlers = element;
      element = this.element;
      delegateElement = this.widget();
    } else {
      // accept selectors, DOM elements
      element = delegateElement = $( element );
      this.bindings = this.bindings.add( element );
    }

    $.each( handlers, function( event, handler ) {
      function handlerProxy() {
        // allow widgets to customize the disabled handling
        // - disabled as an array instead of boolean
        // - disabled class as method for disabling individual parts
        if ( !suppressDisabledCheck &&
            ( instance.options.disabled === true ||
              $( this ).hasClass( "ui-state-disabled" ) ) ) {
          return;
        }
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply( instance, arguments );
      }

      // copy the guid so direct unbinding works
      if ( typeof handler !== "string" ) {
        handlerProxy.guid = handler.guid =
          handler.guid || handlerProxy.guid || $.guid++;
      }

      var match = event.match( /^(\w+)\s*(.*)$/ ),
        eventName = match[1] + instance.eventNamespace,
        selector = match[2];
      if ( selector ) {
        delegateElement.delegate( selector, eventName, handlerProxy );
      } else {
        element.bind( eventName, handlerProxy );
      }
    });
  },

  _off: function( element, eventName ) {
    eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
    element.unbind( eventName ).undelegate( eventName );
  },

  _delay: function( handler, delay ) {
    function handlerProxy() {
      return ( typeof handler === "string" ? instance[ handler ] : handler )
        .apply( instance, arguments );
    }
    var instance = this;
    return setTimeout( handlerProxy, delay || 0 );
  },

  _hoverable: function( element ) {
    this.hoverable = this.hoverable.add( element );
    this._on( element, {
      mouseenter: function( event ) {
        $( event.currentTarget ).addClass( "ui-state-hover" );
      },
      mouseleave: function( event ) {
        $( event.currentTarget ).removeClass( "ui-state-hover" );
      }
    });
  },

  _focusable: function( element ) {
    this.focusable = this.focusable.add( element );
    this._on( element, {
      focusin: function( event ) {
        $( event.currentTarget ).addClass( "ui-state-focus" );
      },
      focusout: function( event ) {
        $( event.currentTarget ).removeClass( "ui-state-focus" );
      }
    });
  },

  _trigger: function( type, event, data ) {
    var prop, orig,
      callback = this.options[ type ];

    data = data || {};
    event = $.Event( event );
    event.type = ( type === this.widgetEventPrefix ?
      type :
      this.widgetEventPrefix + type ).toLowerCase();
    // the original event may come from any element
    // so we need to reset the target on the new event
    event.target = this.element[ 0 ];

    // copy original event properties over to the new event
    orig = event.originalEvent;
    if ( orig ) {
      for ( prop in orig ) {
        if ( !( prop in event ) ) {
          event[ prop ] = orig[ prop ];
        }
      }
    }

    this.element.trigger( event, data );
    return !( $.isFunction( callback ) &&
      callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
      event.isDefaultPrevented() );
  }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
  $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
    if ( typeof options === "string" ) {
      options = { effect: options };
    }
    var hasOptions,
      effectName = !options ?
        method :
        options === true || typeof options === "number" ?
          defaultEffect :
          options.effect || defaultEffect;
    options = options || {};
    if ( typeof options === "number" ) {
      options = { duration: options };
    }
    hasOptions = !$.isEmptyObject( options );
    options.complete = callback;
    if ( options.delay ) {
      element.delay( options.delay );
    }
    if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
      element[ method ]( options );
    } else if ( effectName !== method && element[ effectName ] ) {
      element[ effectName ]( options.duration, options.easing, callback );
    } else {
      element.queue(function( next ) {
        $( this )[ method ]();
        if ( callback ) {
          callback.call( element[ 0 ] );
        }
        next();
      });
    }
  };
});

})( jQuery );
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
  max = Math.max,
  abs = Math.abs,
  round = Math.round,
  rhorizontal = /left|center|right/,
  rvertical = /top|center|bottom/,
  roffset = /[\+\-]\d+(\.[\d]+)?%?/,
  rposition = /^\w+/,
  rpercent = /%$/,
  _position = $.fn.position;

function getOffsets( offsets, width, height ) {
  return [
    parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
    parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
  ];
}

function parseCss( element, property ) {
  return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
  var raw = elem[0];
  if ( raw.nodeType === 9 ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: 0, left: 0 }
    };
  }
  if ( $.isWindow( raw ) ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
    };
  }
  if ( raw.preventDefault ) {
    return {
      width: 0,
      height: 0,
      offset: { top: raw.pageY, left: raw.pageX }
    };
  }
  return {
    width: elem.outerWidth(),
    height: elem.outerHeight(),
    offset: elem.offset()
  };
}

$.position = {
  scrollbarWidth: function() {
    if ( cachedScrollbarWidth !== undefined ) {
      return cachedScrollbarWidth;
    }
    var w1, w2,
      div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
      innerDiv = div.children()[0];

    $( "body" ).append( div );
    w1 = innerDiv.offsetWidth;
    div.css( "overflow", "scroll" );

    w2 = innerDiv.offsetWidth;

    if ( w1 === w2 ) {
      w2 = div[0].clientWidth;
    }

    div.remove();

    return (cachedScrollbarWidth = w1 - w2);
  },
  getScrollInfo: function( within ) {
    var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
      overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
      hasOverflowX = overflowX === "scroll" ||
        ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
      hasOverflowY = overflowY === "scroll" ||
        ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
    return {
      width: hasOverflowY ? $.position.scrollbarWidth() : 0,
      height: hasOverflowX ? $.position.scrollbarWidth() : 0
    };
  },
  getWithinInfo: function( element ) {
    var withinElement = $( element || window ),
      isWindow = $.isWindow( withinElement[0] );
    return {
      element: withinElement,
      isWindow: isWindow,
      offset: withinElement.offset() || { left: 0, top: 0 },
      scrollLeft: withinElement.scrollLeft(),
      scrollTop: withinElement.scrollTop(),
      width: isWindow ? withinElement.width() : withinElement.outerWidth(),
      height: isWindow ? withinElement.height() : withinElement.outerHeight()
    };
  }
};

$.fn.position = function( options ) {
  if ( !options || !options.of ) {
    return _position.apply( this, arguments );
  }

  // make a copy, we don't want to modify arguments
  options = $.extend( {}, options );

  var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
    target = $( options.of ),
    within = $.position.getWithinInfo( options.within ),
    scrollInfo = $.position.getScrollInfo( within ),
    collision = ( options.collision || "flip" ).split( " " ),
    offsets = {};

  dimensions = getDimensions( target );
  if ( target[0].preventDefault ) {
    // force left top to allow flipping
    options.at = "left top";
  }
  targetWidth = dimensions.width;
  targetHeight = dimensions.height;
  targetOffset = dimensions.offset;
  // clone to reuse original targetOffset later
  basePosition = $.extend( {}, targetOffset );

  // force my and at to have valid horizontal and vertical positions
  // if a value is missing or invalid, it will be converted to center
  $.each( [ "my", "at" ], function() {
    var pos = ( options[ this ] || "" ).split( " " ),
      horizontalOffset,
      verticalOffset;

    if ( pos.length === 1) {
      pos = rhorizontal.test( pos[ 0 ] ) ?
        pos.concat( [ "center" ] ) :
        rvertical.test( pos[ 0 ] ) ?
          [ "center" ].concat( pos ) :
          [ "center", "center" ];
    }
    pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
    pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

    // calculate offsets
    horizontalOffset = roffset.exec( pos[ 0 ] );
    verticalOffset = roffset.exec( pos[ 1 ] );
    offsets[ this ] = [
      horizontalOffset ? horizontalOffset[ 0 ] : 0,
      verticalOffset ? verticalOffset[ 0 ] : 0
    ];

    // reduce to just the positions without the offsets
    options[ this ] = [
      rposition.exec( pos[ 0 ] )[ 0 ],
      rposition.exec( pos[ 1 ] )[ 0 ]
    ];
  });

  // normalize collision option
  if ( collision.length === 1 ) {
    collision[ 1 ] = collision[ 0 ];
  }

  if ( options.at[ 0 ] === "right" ) {
    basePosition.left += targetWidth;
  } else if ( options.at[ 0 ] === "center" ) {
    basePosition.left += targetWidth / 2;
  }

  if ( options.at[ 1 ] === "bottom" ) {
    basePosition.top += targetHeight;
  } else if ( options.at[ 1 ] === "center" ) {
    basePosition.top += targetHeight / 2;
  }

  atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
  basePosition.left += atOffset[ 0 ];
  basePosition.top += atOffset[ 1 ];

  return this.each(function() {
    var collisionPosition, using,
      elem = $( this ),
      elemWidth = elem.outerWidth(),
      elemHeight = elem.outerHeight(),
      marginLeft = parseCss( this, "marginLeft" ),
      marginTop = parseCss( this, "marginTop" ),
      collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
      collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
      position = $.extend( {}, basePosition ),
      myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

    if ( options.my[ 0 ] === "right" ) {
      position.left -= elemWidth;
    } else if ( options.my[ 0 ] === "center" ) {
      position.left -= elemWidth / 2;
    }

    if ( options.my[ 1 ] === "bottom" ) {
      position.top -= elemHeight;
    } else if ( options.my[ 1 ] === "center" ) {
      position.top -= elemHeight / 2;
    }

    position.left += myOffset[ 0 ];
    position.top += myOffset[ 1 ];

    // if the browser doesn't support fractions, then round for consistent results
    if ( !$.support.offsetFractions ) {
      position.left = round( position.left );
      position.top = round( position.top );
    }

    collisionPosition = {
      marginLeft: marginLeft,
      marginTop: marginTop
    };

    $.each( [ "left", "top" ], function( i, dir ) {
      if ( $.ui.position[ collision[ i ] ] ) {
        $.ui.position[ collision[ i ] ][ dir ]( position, {
          targetWidth: targetWidth,
          targetHeight: targetHeight,
          elemWidth: elemWidth,
          elemHeight: elemHeight,
          collisionPosition: collisionPosition,
          collisionWidth: collisionWidth,
          collisionHeight: collisionHeight,
          offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
          my: options.my,
          at: options.at,
          within: within,
          elem : elem
        });
      }
    });

    if ( options.using ) {
      // adds feedback as second argument to using callback, if present
      using = function( props ) {
        var left = targetOffset.left - position.left,
          right = left + targetWidth - elemWidth,
          top = targetOffset.top - position.top,
          bottom = top + targetHeight - elemHeight,
          feedback = {
            target: {
              element: target,
              left: targetOffset.left,
              top: targetOffset.top,
              width: targetWidth,
              height: targetHeight
            },
            element: {
              element: elem,
              left: position.left,
              top: position.top,
              width: elemWidth,
              height: elemHeight
            },
            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
          };
        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
          feedback.horizontal = "center";
        }
        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
          feedback.vertical = "middle";
        }
        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
          feedback.important = "horizontal";
        } else {
          feedback.important = "vertical";
        }
        options.using.call( this, props, feedback );
      };
    }

    elem.offset( $.extend( position, { using: using } ) );
  });
};

$.ui.position = {
  fit: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
        outerWidth = within.width,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = withinOffset - collisionPosLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
        newOverRight;

      // element is wider than within
      if ( data.collisionWidth > outerWidth ) {
        // element is initially over the left side of within
        if ( overLeft > 0 && overRight <= 0 ) {
          newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
          position.left += overLeft - newOverRight;
        // element is initially over right side of within
        } else if ( overRight > 0 && overLeft <= 0 ) {
          position.left = withinOffset;
        // element is initially over both left and right sides of within
        } else {
          if ( overLeft > overRight ) {
            position.left = withinOffset + outerWidth - data.collisionWidth;
          } else {
            position.left = withinOffset;
          }
        }
      // too far left -> align with left edge
      } else if ( overLeft > 0 ) {
        position.left += overLeft;
      // too far right -> align with right edge
      } else if ( overRight > 0 ) {
        position.left -= overRight;
      // adjust based on position and margin
      } else {
        position.left = max( position.left - collisionPosLeft, position.left );
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
        outerHeight = data.within.height,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = withinOffset - collisionPosTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
        newOverBottom;

      // element is taller than within
      if ( data.collisionHeight > outerHeight ) {
        // element is initially over the top of within
        if ( overTop > 0 && overBottom <= 0 ) {
          newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
          position.top += overTop - newOverBottom;
        // element is initially over bottom of within
        } else if ( overBottom > 0 && overTop <= 0 ) {
          position.top = withinOffset;
        // element is initially over both top and bottom of within
        } else {
          if ( overTop > overBottom ) {
            position.top = withinOffset + outerHeight - data.collisionHeight;
          } else {
            position.top = withinOffset;
          }
        }
      // too far up -> align with top
      } else if ( overTop > 0 ) {
        position.top += overTop;
      // too far down -> align with bottom edge
      } else if ( overBottom > 0 ) {
        position.top -= overBottom;
      // adjust based on position and margin
      } else {
        position.top = max( position.top - collisionPosTop, position.top );
      }
    }
  },
  flip: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.left + within.scrollLeft,
        outerWidth = within.width,
        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = collisionPosLeft - offsetLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
        myOffset = data.my[ 0 ] === "left" ?
          -data.elemWidth :
          data.my[ 0 ] === "right" ?
            data.elemWidth :
            0,
        atOffset = data.at[ 0 ] === "left" ?
          data.targetWidth :
          data.at[ 0 ] === "right" ?
            -data.targetWidth :
            0,
        offset = -2 * data.offset[ 0 ],
        newOverRight,
        newOverLeft;

      if ( overLeft < 0 ) {
        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
          position.left += myOffset + atOffset + offset;
        }
      }
      else if ( overRight > 0 ) {
        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
          position.left += myOffset + atOffset + offset;
        }
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.top + within.scrollTop,
        outerHeight = within.height,
        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = collisionPosTop - offsetTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
        top = data.my[ 1 ] === "top",
        myOffset = top ?
          -data.elemHeight :
          data.my[ 1 ] === "bottom" ?
            data.elemHeight :
            0,
        atOffset = data.at[ 1 ] === "top" ?
          data.targetHeight :
          data.at[ 1 ] === "bottom" ?
            -data.targetHeight :
            0,
        offset = -2 * data.offset[ 1 ],
        newOverTop,
        newOverBottom;
      if ( overTop < 0 ) {
        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
        if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
          position.top += myOffset + atOffset + offset;
        }
      }
      else if ( overBottom > 0 ) {
        newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
        if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
          position.top += myOffset + atOffset + offset;
        }
      }
    }
  },
  flipfit: {
    left: function() {
      $.ui.position.flip.left.apply( this, arguments );
      $.ui.position.fit.left.apply( this, arguments );
    },
    top: function() {
      $.ui.position.flip.top.apply( this, arguments );
      $.ui.position.fit.top.apply( this, arguments );
    }
  }
};

// fraction support test
(function () {
  var testElement, testElementParent, testElementStyle, offsetLeft, i,
    body = document.getElementsByTagName( "body" )[ 0 ],
    div = document.createElement( "div" );

  //Create a "fake body" for testing based on method used in jQuery.support
  testElement = document.createElement( body ? "div" : "body" );
  testElementStyle = {
    visibility: "hidden",
    width: 0,
    height: 0,
    border: 0,
    margin: 0,
    background: "none"
  };
  if ( body ) {
    $.extend( testElementStyle, {
      position: "absolute",
      left: "-1000px",
      top: "-1000px"
    });
  }
  for ( i in testElementStyle ) {
    testElement.style[ i ] = testElementStyle[ i ];
  }
  testElement.appendChild( div );
  testElementParent = body || document.documentElement;
  testElementParent.insertBefore( testElement, testElementParent.firstChild );

  div.style.cssText = "position: absolute; left: 10.7432222px;";

  offsetLeft = $( div ).offset().left;
  $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

  testElement.innerHTML = "";
  testElementParent.removeChild( testElement );
})();

}( jQuery ) );
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
  version: "1.10.3",
  defaultElement: "<input>",
  options: {
    appendTo: null,
    autoFocus: false,
    delay: 300,
    minLength: 1,
    position: {
      my: "left top",
      at: "left bottom",
      collision: "none"
    },
    source: null,

    // callbacks
    change: null,
    close: null,
    focus: null,
    open: null,
    response: null,
    search: null,
    select: null
  },

  pending: 0,

  _create: function() {
    // Some browsers only repeat keydown events, not keypress events,
    // so we use the suppressKeyPress flag to determine if we've already
    // handled the keydown event. #7269
    // Unfortunately the code for & in keypress is the same as the up arrow,
    // so we use the suppressKeyPressRepeat flag to avoid handling keypress
    // events when we know the keydown event was used to modify the
    // search term. #7799
    var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
      nodeName = this.element[0].nodeName.toLowerCase(),
      isTextarea = nodeName === "textarea",
      isInput = nodeName === "input";

    this.isMultiLine =
      // Textareas are always multi-line
      isTextarea ? true :
      // Inputs are always single-line, even if inside a contentEditable element
      // IE also treats inputs as contentEditable
      isInput ? false :
      // All other element types are determined by whether or not they're contentEditable
      this.element.prop( "isContentEditable" );

    this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
    this.isNewMenu = true;

    this.element
      .addClass( "ui-autocomplete-input" )
      .attr( "autocomplete", "off" );

    this._on( this.element, {
      keydown: function( event ) {
        /*jshint maxcomplexity:15*/
        if ( this.element.prop( "readOnly" ) ) {
          suppressKeyPress = true;
          suppressInput = true;
          suppressKeyPressRepeat = true;
          return;
        }

        suppressKeyPress = false;
        suppressInput = false;
        suppressKeyPressRepeat = false;
        var keyCode = $.ui.keyCode;
        switch( event.keyCode ) {
        case keyCode.PAGE_UP:
          suppressKeyPress = true;
          this._move( "previousPage", event );
          break;
        case keyCode.PAGE_DOWN:
          suppressKeyPress = true;
          this._move( "nextPage", event );
          break;
        case keyCode.UP:
          suppressKeyPress = true;
          this._keyEvent( "previous", event );
          break;
        case keyCode.DOWN:
          suppressKeyPress = true;
          this._keyEvent( "next", event );
          break;
        case keyCode.ENTER:
        case keyCode.NUMPAD_ENTER:
          // when menu is open and has focus
          if ( this.menu.active ) {
            // #6055 - Opera still allows the keypress to occur
            // which causes forms to submit
            suppressKeyPress = true;
            event.preventDefault();
            this.menu.select( event );
          }
          break;
        case keyCode.TAB:
          if ( this.menu.active ) {
            this.menu.select( event );
          }
          break;
        case keyCode.ESCAPE:
          if ( this.menu.element.is( ":visible" ) ) {
            this._value( this.term );
            this.close( event );
            // Different browsers have different default behavior for escape
            // Single press can mean undo or clear
            // Double press in IE means clear the whole form
            event.preventDefault();
          }
          break;
        default:
          suppressKeyPressRepeat = true;
          // search timeout should be triggered before the input value is changed
          this._searchTimeout( event );
          break;
        }
      },
      keypress: function( event ) {
        if ( suppressKeyPress ) {
          suppressKeyPress = false;
          if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
            event.preventDefault();
          }
          return;
        }
        if ( suppressKeyPressRepeat ) {
          return;
        }

        // replicate some key handlers to allow them to repeat in Firefox and Opera
        var keyCode = $.ui.keyCode;
        switch( event.keyCode ) {
        case keyCode.PAGE_UP:
          this._move( "previousPage", event );
          break;
        case keyCode.PAGE_DOWN:
          this._move( "nextPage", event );
          break;
        case keyCode.UP:
          this._keyEvent( "previous", event );
          break;
        case keyCode.DOWN:
          this._keyEvent( "next", event );
          break;
        }
      },
      input: function( event ) {
        if ( suppressInput ) {
          suppressInput = false;
          event.preventDefault();
          return;
        }
        this._searchTimeout( event );
      },
      focus: function() {
        this.selectedItem = null;
        this.previous = this._value();
      },
      blur: function( event ) {
        if ( this.cancelBlur ) {
          delete this.cancelBlur;
          return;
        }

        clearTimeout( this.searching );
        this.close( event );
        this._change( event );
      }
    });

    this._initSource();
    this.menu = $( "<ul>" )
      .addClass( "ui-autocomplete ui-front" )
      .appendTo( this._appendTo() )
      .menu({
        // disable ARIA support, the live region takes care of that
        role: null
      })
      .hide()
      .data( "ui-menu" );

    this._on( this.menu.element, {
      mousedown: function( event ) {
        // prevent moving focus out of the text field
        event.preventDefault();

        // IE doesn't prevent moving focus even with event.preventDefault()
        // so we set a flag to know when we should ignore the blur event
        this.cancelBlur = true;
        this._delay(function() {
          delete this.cancelBlur;
        });

        // clicking on the scrollbar causes focus to shift to the body
        // but we can't detect a mouseup or a click immediately afterward
        // so we have to track the next mousedown and close the menu if
        // the user clicks somewhere outside of the autocomplete
        var menuElement = this.menu.element[ 0 ];
        if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
          this._delay(function() {
            var that = this;
            this.document.one( "mousedown", function( event ) {
              if ( event.target !== that.element[ 0 ] &&
                  event.target !== menuElement &&
                  !$.contains( menuElement, event.target ) ) {
                that.close();
              }
            });
          });
        }
      },
      menufocus: function( event, ui ) {
        // support: Firefox
        // Prevent accidental activation of menu items in Firefox (#7024 #9118)
        if ( this.isNewMenu ) {
          this.isNewMenu = false;
          if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
            this.menu.blur();

            this.document.one( "mousemove", function() {
              $( event.target ).trigger( event.originalEvent );
            });

            return;
          }
        }

        var item = ui.item.data( "ui-autocomplete-item" );
        if ( false !== this._trigger( "focus", event, { item: item } ) ) {
          // use value to match what will end up in the input, if it was a key event
          if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
            this._value( item.value );
          }
        } else {
          // Normally the input is populated with the item's value as the
          // menu is navigated, causing screen readers to notice a change and
          // announce the item. Since the focus event was canceled, this doesn't
          // happen, so we update the live region so that screen readers can
          // still notice the change and announce it.
          this.liveRegion.text( item.value );
        }
      },
      menuselect: function( event, ui ) {
        var item = ui.item.data( "ui-autocomplete-item" ),
          previous = this.previous;

        // only trigger when focus was lost (click on menu)
        if ( this.element[0] !== this.document[0].activeElement ) {
          this.element.focus();
          this.previous = previous;
          // #6109 - IE triggers two focus events and the second
          // is asynchronous, so we need to reset the previous
          // term synchronously and asynchronously :-(
          this._delay(function() {
            this.previous = previous;
            this.selectedItem = item;
          });
        }

        if ( false !== this._trigger( "select", event, { item: item } ) ) {
          this._value( item.value );
        }
        // reset the term after the select event
        // this allows custom select handling to work properly
        this.term = this._value();

        this.close( event );
        this.selectedItem = item;
      }
    });

    this.liveRegion = $( "<span>", {
        role: "status",
        "aria-live": "polite"
      })
      .addClass( "ui-helper-hidden-accessible" )
      .insertBefore( this.element );

    // turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    this._on( this.window, {
      beforeunload: function() {
        this.element.removeAttr( "autocomplete" );
      }
    });
  },

  _destroy: function() {
    clearTimeout( this.searching );
    this.element
      .removeClass( "ui-autocomplete-input" )
      .removeAttr( "autocomplete" );
    this.menu.element.remove();
    this.liveRegion.remove();
  },

  _setOption: function( key, value ) {
    this._super( key, value );
    if ( key === "source" ) {
      this._initSource();
    }
    if ( key === "appendTo" ) {
      this.menu.element.appendTo( this._appendTo() );
    }
    if ( key === "disabled" && value && this.xhr ) {
      this.xhr.abort();
    }
  },

  _appendTo: function() {
    var element = this.options.appendTo;

    if ( element ) {
      element = element.jquery || element.nodeType ?
        $( element ) :
        this.document.find( element ).eq( 0 );
    }

    if ( !element ) {
      element = this.element.closest( ".ui-front" );
    }

    if ( !element.length ) {
      element = this.document[0].body;
    }

    return element;
  },

  _initSource: function() {
    var array, url,
      that = this;
    if ( $.isArray(this.options.source) ) {
      array = this.options.source;
      this.source = function( request, response ) {
        response( $.ui.autocomplete.filter( array, request.term ) );
      };
    } else if ( typeof this.options.source === "string" ) {
      url = this.options.source;
      this.source = function( request, response ) {
        if ( that.xhr ) {
          that.xhr.abort();
        }
        that.xhr = $.ajax({
          url: url,
          data: request,
          dataType: "json",
          success: function( data ) {
            response( data );
          },
          error: function() {
            response( [] );
          }
        });
      };
    } else {
      this.source = this.options.source;
    }
  },

  _searchTimeout: function( event ) {
    clearTimeout( this.searching );
    this.searching = this._delay(function() {
      // only search if the value has changed
      if ( this.term !== this._value() ) {
        this.selectedItem = null;
        this.search( null, event );
      }
    }, this.options.delay );
  },

  search: function( value, event ) {
    value = value != null ? value : this._value();

    // always save the actual value, not the one passed as an argument
    this.term = this._value();

    if ( value.length < this.options.minLength ) {
      return this.close( event );
    }

    if ( this._trigger( "search", event ) === false ) {
      return;
    }

    return this._search( value );
  },

  _search: function( value ) {
    this.pending++;
    this.element.addClass( "ui-autocomplete-loading" );
    this.cancelSearch = false;

    this.source( { term: value }, this._response() );
  },

  _response: function() {
    var that = this,
      index = ++requestIndex;

    return function( content ) {
      if ( index === requestIndex ) {
        that.__response( content );
      }

      that.pending--;
      if ( !that.pending ) {
        that.element.removeClass( "ui-autocomplete-loading" );
      }
    };
  },

  __response: function( content ) {
    if ( content ) {
      content = this._normalize( content );
    }
    this._trigger( "response", null, { content: content } );
    if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
      this._suggest( content );
      this._trigger( "open" );
    } else {
      // use ._close() instead of .close() so we don't cancel future searches
      this._close();
    }
  },

  close: function( event ) {
    this.cancelSearch = true;
    this._close( event );
  },

  _close: function( event ) {
    if ( this.menu.element.is( ":visible" ) ) {
      this.menu.element.hide();
      this.menu.blur();
      this.isNewMenu = true;
      this._trigger( "close", event );
    }
  },

  _change: function( event ) {
    if ( this.previous !== this._value() ) {
      this._trigger( "change", event, { item: this.selectedItem } );
    }
  },

  _normalize: function( items ) {
    // assume all items have the right format when the first item is complete
    if ( items.length && items[0].label && items[0].value ) {
      return items;
    }
    return $.map( items, function( item ) {
      if ( typeof item === "string" ) {
        return {
          label: item,
          value: item
        };
      }
      return $.extend({
        label: item.label || item.value,
        value: item.value || item.label
      }, item );
    });
  },

  _suggest: function( items ) {
    var ul = this.menu.element.empty();
    this._renderMenu( ul, items );
    this.isNewMenu = true;
    this.menu.refresh();

    // size and position menu
    ul.show();
    this._resizeMenu();
    ul.position( $.extend({
      of: this.element
    }, this.options.position ));

    if ( this.options.autoFocus ) {
      this.menu.next();
    }
  },

  _resizeMenu: function() {
    var ul = this.menu.element;
    ul.outerWidth( Math.max(
      // Firefox wraps long text (possibly a rounding bug)
      // so we add 1px to avoid the wrapping (#7513)
      ul.width( "" ).outerWidth() + 1,
      this.element.outerWidth()
    ) );
  },

  _renderMenu: function( ul, items ) {
    var that = this;
    $.each( items, function( index, item ) {
      that._renderItemData( ul, item );
    });
  },

  _renderItemData: function( ul, item ) {
    return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
  },

  _renderItem: function( ul, item ) {
    return $( "<li>" )
      .append( $( "<a>" ).text( item.label ) )
      .appendTo( ul );
  },

  _move: function( direction, event ) {
    if ( !this.menu.element.is( ":visible" ) ) {
      this.search( null, event );
      return;
    }
    if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
        this.menu.isLastItem() && /^next/.test( direction ) ) {
      this._value( this.term );
      this.menu.blur();
      return;
    }
    this.menu[ direction ]( event );
  },

  widget: function() {
    return this.menu.element;
  },

  _value: function() {
    return this.valueMethod.apply( this.element, arguments );
  },

  _keyEvent: function( keyEvent, event ) {
    if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
      this._move( keyEvent, event );

      // prevents moving cursor to beginning/end of the text field in some browsers
      event.preventDefault();
    }
  }
});

$.extend( $.ui.autocomplete, {
  escapeRegex: function( value ) {
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  },
  filter: function(array, term) {
    var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
    return $.grep( array, function(value) {
      return matcher.test( value.label || value.value || value );
    });
  }
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
  options: {
    messages: {
      noResults: "No search results.",
      results: function( amount ) {
        return amount + ( amount > 1 ? " results are" : " result is" ) +
          " available, use up and down arrow keys to navigate.";
      }
    }
  },

  __response: function( content ) {
    var message;
    this._superApply( arguments );
    if ( this.options.disabled || this.cancelSearch ) {
      return;
    }
    if ( content && content.length ) {
      message = this.options.messages.results( content.length );
    } else {
      message = this.options.messages.noResults;
    }
    this.liveRegion.text( message );
  }
});

}( jQuery ));
(function( $, undefined ) {

$.widget( "ui.menu", {
  version: "1.10.3",
  defaultElement: "<ul>",
  delay: 300,
  options: {
    icons: {
      submenu: "ui-icon-carat-1-e"
    },
    menus: "ul",
    position: {
      my: "left top",
      at: "right top"
    },
    role: "menu",

    // callbacks
    blur: null,
    focus: null,
    select: null
  },

  _create: function() {
    this.activeMenu = this.element;
    // flag used to prevent firing of the click handler
    // as the event bubbles up through nested menus
    this.mouseHandled = false;
    this.element
      .uniqueId()
      .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
      .toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
      .attr({
        role: this.options.role,
        tabIndex: 0
      })
      // need to catch all clicks on disabled menu
      // not possible through _on
      .bind( "click" + this.eventNamespace, $.proxy(function( event ) {
        if ( this.options.disabled ) {
          event.preventDefault();
        }
      }, this ));

    if ( this.options.disabled ) {
      this.element
        .addClass( "ui-state-disabled" )
        .attr( "aria-disabled", "true" );
    }

    this._on({
      // Prevent focus from sticking to links inside menu after clicking
      // them (focus should always stay on UL during navigation).
      "mousedown .ui-menu-item > a": function( event ) {
        event.preventDefault();
      },
      "click .ui-state-disabled > a": function( event ) {
        event.preventDefault();
      },
      "click .ui-menu-item:has(a)": function( event ) {
        var target = $( event.target ).closest( ".ui-menu-item" );
        if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
          this.mouseHandled = true;

          this.select( event );
          // Open submenu on click
          if ( target.has( ".ui-menu" ).length ) {
            this.expand( event );
          } else if ( !this.element.is( ":focus" ) ) {
            // Redirect focus to the menu
            this.element.trigger( "focus", [ true ] );

            // If the active item is on the top level, let it stay active.
            // Otherwise, blur the active item since it is no longer visible.
            if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
              clearTimeout( this.timer );
            }
          }
        }
      },
      "mouseenter .ui-menu-item": function( event ) {
        var target = $( event.currentTarget );
        // Remove ui-state-active class from siblings of the newly focused menu item
        // to avoid a jump caused by adjacent elements both having a class with a border
        target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
        this.focus( event, target );
      },
      mouseleave: "collapseAll",
      "mouseleave .ui-menu": "collapseAll",
      focus: function( event, keepActiveItem ) {
        // If there's already an active item, keep it active
        // If not, activate the first item
        var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

        if ( !keepActiveItem ) {
          this.focus( event, item );
        }
      },
      blur: function( event ) {
        this._delay(function() {
          if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
            this.collapseAll( event );
          }
        });
      },
      keydown: "_keydown"
    });

    this.refresh();

    // Clicks outside of a menu collapse any open menus
    this._on( this.document, {
      click: function( event ) {
        if ( !$( event.target ).closest( ".ui-menu" ).length ) {
          this.collapseAll( event );
        }

        // Reset the mouseHandled flag
        this.mouseHandled = false;
      }
    });
  },

  _destroy: function() {
    // Destroy (sub)menus
    this.element
      .removeAttr( "aria-activedescendant" )
      .find( ".ui-menu" ).addBack()
        .removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
        .removeAttr( "role" )
        .removeAttr( "tabIndex" )
        .removeAttr( "aria-labelledby" )
        .removeAttr( "aria-expanded" )
        .removeAttr( "aria-hidden" )
        .removeAttr( "aria-disabled" )
        .removeUniqueId()
        .show();

    // Destroy menu items
    this.element.find( ".ui-menu-item" )
      .removeClass( "ui-menu-item" )
      .removeAttr( "role" )
      .removeAttr( "aria-disabled" )
      .children( "a" )
        .removeUniqueId()
        .removeClass( "ui-corner-all ui-state-hover" )
        .removeAttr( "tabIndex" )
        .removeAttr( "role" )
        .removeAttr( "aria-haspopup" )
        .children().each( function() {
          var elem = $( this );
          if ( elem.data( "ui-menu-submenu-carat" ) ) {
            elem.remove();
          }
        });

    // Destroy menu dividers
    this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
  },

  _keydown: function( event ) {
    /*jshint maxcomplexity:20*/
    var match, prev, character, skip, regex,
      preventDefault = true;

    function escape( value ) {
      return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
    }

    switch ( event.keyCode ) {
    case $.ui.keyCode.PAGE_UP:
      this.previousPage( event );
      break;
    case $.ui.keyCode.PAGE_DOWN:
      this.nextPage( event );
      break;
    case $.ui.keyCode.HOME:
      this._move( "first", "first", event );
      break;
    case $.ui.keyCode.END:
      this._move( "last", "last", event );
      break;
    case $.ui.keyCode.UP:
      this.previous( event );
      break;
    case $.ui.keyCode.DOWN:
      this.next( event );
      break;
    case $.ui.keyCode.LEFT:
      this.collapse( event );
      break;
    case $.ui.keyCode.RIGHT:
      if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
        this.expand( event );
      }
      break;
    case $.ui.keyCode.ENTER:
    case $.ui.keyCode.SPACE:
      this._activate( event );
      break;
    case $.ui.keyCode.ESCAPE:
      this.collapse( event );
      break;
    default:
      preventDefault = false;
      prev = this.previousFilter || "";
      character = String.fromCharCode( event.keyCode );
      skip = false;

      clearTimeout( this.filterTimer );

      if ( character === prev ) {
        skip = true;
      } else {
        character = prev + character;
      }

      regex = new RegExp( "^" + escape( character ), "i" );
      match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
        return regex.test( $( this ).children( "a" ).text() );
      });
      match = skip && match.index( this.active.next() ) !== -1 ?
        this.active.nextAll( ".ui-menu-item" ) :
        match;

      // If no matches on the current filter, reset to the last character pressed
      // to move down the menu to the first item that starts with that character
      if ( !match.length ) {
        character = String.fromCharCode( event.keyCode );
        regex = new RegExp( "^" + escape( character ), "i" );
        match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
          return regex.test( $( this ).children( "a" ).text() );
        });
      }

      if ( match.length ) {
        this.focus( event, match );
        if ( match.length > 1 ) {
          this.previousFilter = character;
          this.filterTimer = this._delay(function() {
            delete this.previousFilter;
          }, 1000 );
        } else {
          delete this.previousFilter;
        }
      } else {
        delete this.previousFilter;
      }
    }

    if ( preventDefault ) {
      event.preventDefault();
    }
  },

  _activate: function( event ) {
    if ( !this.active.is( ".ui-state-disabled" ) ) {
      if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
        this.expand( event );
      } else {
        this.select( event );
      }
    }
  },

  refresh: function() {
    var menus,
      icon = this.options.icons.submenu,
      submenus = this.element.find( this.options.menus );

    // Initialize nested menus
    submenus.filter( ":not(.ui-menu)" )
      .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
      .hide()
      .attr({
        role: this.options.role,
        "aria-hidden": "true",
        "aria-expanded": "false"
      })
      .each(function() {
        var menu = $( this ),
          item = menu.prev( "a" ),
          submenuCarat = $( "<span>" )
            .addClass( "ui-menu-icon ui-icon " + icon )
            .data( "ui-menu-submenu-carat", true );

        item
          .attr( "aria-haspopup", "true" )
          .prepend( submenuCarat );
        menu.attr( "aria-labelledby", item.attr( "id" ) );
      });

    menus = submenus.add( this.element );

    // Don't refresh list items that are already adapted
    menus.children( ":not(.ui-menu-item):has(a)" )
      .addClass( "ui-menu-item" )
      .attr( "role", "presentation" )
      .children( "a" )
        .uniqueId()
        .addClass( "ui-corner-all" )
        .attr({
          tabIndex: -1,
          role: this._itemRole()
        });

    // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
    menus.children( ":not(.ui-menu-item)" ).each(function() {
      var item = $( this );
      // hyphen, em dash, en dash
      if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
        item.addClass( "ui-widget-content ui-menu-divider" );
      }
    });

    // Add aria-disabled attribute to any disabled menu item
    menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

    // If the active item has been removed, blur the menu
    if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
      this.blur();
    }
  },

  _itemRole: function() {
    return {
      menu: "menuitem",
      listbox: "option"
    }[ this.options.role ];
  },

  _setOption: function( key, value ) {
    if ( key === "icons" ) {
      this.element.find( ".ui-menu-icon" )
        .removeClass( this.options.icons.submenu )
        .addClass( value.submenu );
    }
    this._super( key, value );
  },

  focus: function( event, item ) {
    var nested, focused;
    this.blur( event, event && event.type === "focus" );

    this._scrollIntoView( item );

    this.active = item.first();
    focused = this.active.children( "a" ).addClass( "ui-state-focus" );
    // Only update aria-activedescendant if there's a role
    // otherwise we assume focus is managed elsewhere
    if ( this.options.role ) {
      this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
    }

    // Highlight active parent menu item, if any
    this.active
      .parent()
      .closest( ".ui-menu-item" )
      .children( "a:first" )
      .addClass( "ui-state-active" );

    if ( event && event.type === "keydown" ) {
      this._close();
    } else {
      this.timer = this._delay(function() {
        this._close();
      }, this.delay );
    }

    nested = item.children( ".ui-menu" );
    if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
      this._startOpening(nested);
    }
    this.activeMenu = item.parent();

    this._trigger( "focus", event, { item: item } );
  },

  _scrollIntoView: function( item ) {
    var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
    if ( this._hasScroll() ) {
      borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
      paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
      offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
      scroll = this.activeMenu.scrollTop();
      elementHeight = this.activeMenu.height();
      itemHeight = item.height();

      if ( offset < 0 ) {
        this.activeMenu.scrollTop( scroll + offset );
      } else if ( offset + itemHeight > elementHeight ) {
        this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
      }
    }
  },

  blur: function( event, fromFocus ) {
    if ( !fromFocus ) {
      clearTimeout( this.timer );
    }

    if ( !this.active ) {
      return;
    }

    this.active.children( "a" ).removeClass( "ui-state-focus" );
    this.active = null;

    this._trigger( "blur", event, { item: this.active } );
  },

  _startOpening: function( submenu ) {
    clearTimeout( this.timer );

    // Don't open if already open fixes a Firefox bug that caused a .5 pixel
    // shift in the submenu position when mousing over the carat icon
    if ( submenu.attr( "aria-hidden" ) !== "true" ) {
      return;
    }

    this.timer = this._delay(function() {
      this._close();
      this._open( submenu );
    }, this.delay );
  },

  _open: function( submenu ) {
    var position = $.extend({
      of: this.active
    }, this.options.position );

    clearTimeout( this.timer );
    this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
      .hide()
      .attr( "aria-hidden", "true" );

    submenu
      .show()
      .removeAttr( "aria-hidden" )
      .attr( "aria-expanded", "true" )
      .position( position );
  },

  collapseAll: function( event, all ) {
    clearTimeout( this.timer );
    this.timer = this._delay(function() {
      // If we were passed an event, look for the submenu that contains the event
      var currentMenu = all ? this.element :
        $( event && event.target ).closest( this.element.find( ".ui-menu" ) );

      // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
      if ( !currentMenu.length ) {
        currentMenu = this.element;
      }

      this._close( currentMenu );

      this.blur( event );
      this.activeMenu = currentMenu;
    }, this.delay );
  },

  // With no arguments, closes the currently active menu - if nothing is active
  // it closes all menus.  If passed an argument, it will search for menus BELOW
  _close: function( startMenu ) {
    if ( !startMenu ) {
      startMenu = this.active ? this.active.parent() : this.element;
    }

    startMenu
      .find( ".ui-menu" )
        .hide()
        .attr( "aria-hidden", "true" )
        .attr( "aria-expanded", "false" )
      .end()
      .find( "a.ui-state-active" )
        .removeClass( "ui-state-active" );
  },

  collapse: function( event ) {
    var newItem = this.active &&
      this.active.parent().closest( ".ui-menu-item", this.element );
    if ( newItem && newItem.length ) {
      this._close();
      this.focus( event, newItem );
    }
  },

  expand: function( event ) {
    var newItem = this.active &&
      this.active
        .children( ".ui-menu " )
        .children( ".ui-menu-item" )
        .first();

    if ( newItem && newItem.length ) {
      this._open( newItem.parent() );

      // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
      this._delay(function() {
        this.focus( event, newItem );
      });
    }
  },

  next: function( event ) {
    this._move( "next", "first", event );
  },

  previous: function( event ) {
    this._move( "prev", "last", event );
  },

  isFirstItem: function() {
    return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
  },

  isLastItem: function() {
    return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
  },

  _move: function( direction, filter, event ) {
    var next;
    if ( this.active ) {
      if ( direction === "first" || direction === "last" ) {
        next = this.active
          [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
          .eq( -1 );
      } else {
        next = this.active
          [ direction + "All" ]( ".ui-menu-item" )
          .eq( 0 );
      }
    }
    if ( !next || !next.length || !this.active ) {
      next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
    }

    this.focus( event, next );
  },

  nextPage: function( event ) {
    var item, base, height;

    if ( !this.active ) {
      this.next( event );
      return;
    }
    if ( this.isLastItem() ) {
      return;
    }
    if ( this._hasScroll() ) {
      base = this.active.offset().top;
      height = this.element.height();
      this.active.nextAll( ".ui-menu-item" ).each(function() {
        item = $( this );
        return item.offset().top - base - height < 0;
      });

      this.focus( event, item );
    } else {
      this.focus( event, this.activeMenu.children( ".ui-menu-item" )
        [ !this.active ? "first" : "last" ]() );
    }
  },

  previousPage: function( event ) {
    var item, base, height;
    if ( !this.active ) {
      this.next( event );
      return;
    }
    if ( this.isFirstItem() ) {
      return;
    }
    if ( this._hasScroll() ) {
      base = this.active.offset().top;
      height = this.element.height();
      this.active.prevAll( ".ui-menu-item" ).each(function() {
        item = $( this );
        return item.offset().top - base + height > 0;
      });

      this.focus( event, item );
    } else {
      this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
    }
  },

  _hasScroll: function() {
    return this.element.outerHeight() < this.element.prop( "scrollHeight" );
  },

  select: function( event ) {
    // TODO: It should never be possible to not have an active item at this
    // point, but the tests don't trigger mouseenter before click.
    this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
    var ui = { item: this.active };
    if ( !this.active.has( ".ui-menu" ).length ) {
      this.collapseAll( event, true );
    }
    this._trigger( "select", event, ui );
  }
});

}( jQuery ));
/**
* simplePagination.js v1.5
* A simple jQuery pagination plugin.
* http://flaviusmatis.github.com/simplePagination.js/
*
* Copyright 2012, Flavius Matis
* Released under the MIT license.
* http://flaviusmatis.github.com/license.html
*/

(function($){

  var methods = {
    init: function(options) {
      var o = $.extend({
        items: 1,
        itemsOnPage: 1,
        pages: 0,
        displayedPages: 5,
        edges: 2,
        currentPage: 1,
        hrefTextPrefix: '#page-',
        hrefTextSuffix: '',
        prevText: 'Prev',
        nextText: 'Next',
        ellipseText: '&hellip;',
        cssStyle: 'light-theme',
        selectOnClick: true,
        onPageClick: function(pageNumber, event) {
          // Callback triggered when a page is clicked
          // Page number is given as an optional parameter
        },
        onInit: function() {
          // Callback triggered immediately after initialization
        }
      }, options || {});

      var self = this;

      o.pages = o.pages ? o.pages : Math.ceil(o.items / o.itemsOnPage) ? Math.ceil(o.items / o.itemsOnPage) : 1;
      o.currentPage = o.currentPage - 1;
      o.halfDisplayed = o.displayedPages / 2;

      this.each(function() {
        self.addClass(o.cssStyle + ' simple-pagination').data('pagination', o);
        methods._draw.call(self);
      });

      o.onInit();

      return this;
    },

    selectPage: function(page) {
      methods._selectPage.call(this, page - 1);
      return this;
    },

    prevPage: function() {
      var o = this.data('pagination');
      if (o.currentPage > 0) {
        methods._selectPage.call(this, o.currentPage - 1);
      }
      return this;
    },

    nextPage: function() {
      var o = this.data('pagination');
      if (o.currentPage < o.pages - 1) {
        methods._selectPage.call(this, o.currentPage + 1);
      }
      return this;
    },

    getPagesCount: function() {
      return this.data('pagination').pages;
    },

    getCurrentPage: function () {
      return this.data('pagination').currentPage + 1;
    },

    destroy: function(){
      this.empty();
      return this;
    },

    redraw: function(){
      methods._draw.call(this);
      return this;
    },

    disable: function(){
      var o = this.data('pagination');
      o.disabled = true;
      this.data('pagination', o);
      methods._draw.call(this);
      return this;
    },

    enable: function(){
      var o = this.data('pagination');
      o.disabled = false;
      this.data('pagination', o);
      methods._draw.call(this);
      return this;
    },

    _draw: function() {
      var o = this.data('pagination'),
        interval = methods._getInterval(o),
        i;

      methods.destroy.call(this);

      var $panel = this.prop("tagName") === "UL" ? this : $('<ul></ul>').appendTo(this);

      // Generate Prev link
      if (o.prevText) {
        methods._appendItem.call(this, o.currentPage - 1, {text: o.prevText, classes: 'prev'});
      }

      // Generate start edges
      if (interval.start > 0 && o.edges > 0) {
        var end = Math.min(o.edges, interval.start);
        for (i = 0; i < end; i++) {
          methods._appendItem.call(this, i);
        }
        if (o.edges < interval.start && (interval.start - o.edges != 1)) {
          $panel.append('<li class="disabled"><span class="ellipse">' + o.ellipseText + '</span></li>');
        } else if (interval.start - o.edges == 1) {
          methods._appendItem.call(this, o.edges);
        }
      }

      // Generate interval links
      for (i = interval.start; i < interval.end; i++) {
        methods._appendItem.call(this, i);
      }

      // Generate end edges
      if (interval.end < o.pages && o.edges > 0) {
        if (o.pages - o.edges > interval.end && (o.pages - o.edges - interval.end != 1)) {
          $panel.append('<li class="disabled"><span class="ellipse">' + o.ellipseText + '</span></li>');
        } else if (o.pages - o.edges - interval.end == 1) {
          methods._appendItem.call(this, interval.end++);
        }
        var begin = Math.max(o.pages - o.edges, interval.end);
        for (i = begin; i < o.pages; i++) {
          methods._appendItem.call(this, i);
        }
      }

      // Generate Next link
      if (o.nextText) {
        methods._appendItem.call(this, o.currentPage + 1, {text: o.nextText, classes: 'next'});
      }
    },

    _getInterval: function(o) {
      return {
        start: Math.ceil(o.currentPage > o.halfDisplayed ? Math.max(Math.min(o.currentPage - o.halfDisplayed, (o.pages - o.displayedPages)), 0) : 0),
        end: Math.ceil(o.currentPage > o.halfDisplayed ? Math.min(o.currentPage + o.halfDisplayed, o.pages) : Math.min(o.displayedPages, o.pages))
      };
    },

    _appendItem: function(pageIndex, opts) {
      var self = this, options, $link, o = self.data('pagination'), $linkWrapper = $('<li></li>'), $ul = self.find('ul');

      pageIndex = pageIndex < 0 ? 0 : (pageIndex < o.pages ? pageIndex : o.pages - 1);

      options = $.extend({
        text: pageIndex + 1,
        classes: ''
      }, opts || {});

      if (pageIndex == o.currentPage || o.disabled) {
        if (o.disabled) {
          $linkWrapper.addClass('disabled');
        } else {
          $linkWrapper.addClass('active');
        }
        $link = $('<span class="current">' + (options.text) + '</span>');
      } else {
        $link = $('<a href="' + o.hrefTextPrefix + (pageIndex + 1) + o.hrefTextSuffix + '" class="page-link">' + (options.text) + '</a>');
        $link.click(function(event){
          return methods._selectPage.call(self, pageIndex, event);
        });
      }

      if (options.classes) {
        $link.addClass(options.classes);
      }

      $linkWrapper.append($link);

      if ($ul.length) {
        $ul.append($linkWrapper);
      } else {
        self.append($linkWrapper);
      }
    },

    _selectPage: function(pageIndex, event) {
      var o = this.data('pagination');
      o.currentPage = pageIndex;
      if (o.selectOnClick) {
        methods._draw.call(this);
      }
      return o.onPageClick(pageIndex + 1, event);
    }

  };
  
  $.fn.pagination = function(method) {

    // Method calling logic
    if (methods[method] && method.charAt(0) != '_') {
      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof method === 'object' || !method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error('Method ' +  method + ' does not exist on jQuery.pagination');
    }

  };

})(jQuery);
/*jslint browser: true, confusion: true, sloppy: true, vars: true, nomen: false, plusplus: false, indent: 2 */
/*global window,google */

/**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.0.15 [October 18, 2012]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>printable</code>,
 *  <code>batchSizeIE</code>, and <code>calculator</code> properties as well as support for
 *  four more events. It also allows greater control over the styling of the text that appears
 *  on the cluster marker. The documentation has been significantly improved and the overall
 *  code has been simplified and polished. Very large numbers of markers can now be managed
 *  without causing Javascript timeout errors on Internet Explorer. Note that the name of the
 *  <code>clusterclick</code> event has been deprecated. The new name is <code>click</code>,
 *  so please change your application code now.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The height (in pixels) of the cluster icon. Required.
 * @property {number} width The width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchor] The anchor position (in pixels) of the label text to be shown on
 *  the cluster icon, relative to the top left corner of the icon.
 *  The format is <code>[yoffset, xoffset]</code>. The <code>yoffset</code> must be positive
 *  and less than <code>height</code> and the <code>xoffset</code> must be positive and less
 *  than <code>width</code>. The default is to anchor the label text so that it is centered
 *  on the icon.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right. The default anchor position is the center of the
 *  cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {number} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {number} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images.
 */
/**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
/**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
function ClusterIcon(cluster, styles) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.cluster_ = cluster;
  this.className_ = cluster.getMarkerClusterer().getClusterClass();
  this.styles_ = styles;
  this.center_ = null;
  this.div_ = null;
    this.shadowDiv_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called
}


/**
 * Adds the icon to the DOM.
 */
ClusterIcon.prototype.onAdd = function () {
  var cClusterIcon = this;
  var cMouseDownInCluster;
  var cDraggingMapByCluster;

  this.div_ = document.createElement("div");
  this.shadowDiv_ = document.createElement("div");
  this.div_.className = this.className_;
    this.shadowDiv_.className = this.className_;
    if (this.visible_) {
    this.show();
  }

  this.getPanes().overlayMouseTarget.appendChild(this.div_);
    this.getPanes().overlayMouseTarget.appendChild(this.shadowDiv_);

  // Fix for Issue 157
  google.maps.event.addListener(this.getMap(), "bounds_changed", function () {
    cDraggingMapByCluster = cMouseDownInCluster;
  });

  google.maps.event.addDomListener(this.div_, "mousedown", function () {
    cMouseDownInCluster = true;
    cDraggingMapByCluster = false;
  });

  google.maps.event.addDomListener(this.div_, "click", function (e) {
    cMouseDownInCluster = false;
    if (!cDraggingMapByCluster) {
      var theBounds;
      var mz;
      var mc = cClusterIcon.cluster_.getMarkerClusterer();
      /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
      google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
      google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_); // deprecated name

      // The default click handler follows. Disable it by setting
      // the zoomOnClick property to false.
      if (mc.getZoomOnClick()) {
        // Zoom into the cluster.
        mz = mc.getMaxZoom();
        theBounds = cClusterIcon.cluster_.getBounds();
        mc.getMap().fitBounds(theBounds);
        // There is a fix for Issue 170 here:
        setTimeout(function () {
          mc.getMap().fitBounds(theBounds);
          // Don't zoom beyond the max zoom level
          if (mz !== null && (mc.getMap().getZoom() > mz)) {
            mc.getMap().setZoom(mz + 1);
          }
        }, 100);
      }

      // Prevent event propagation to the map:
      e.cancelBubble = true;
      if (e.stopPropagation) {
        e.stopPropagation();
      }
    }
  });

  google.maps.event.addDomListener(this.div_, "mouseover", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
    google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
  });

  google.maps.event.addDomListener(this.div_, "mouseout", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
    google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
  });
};


/**
 * Removes the icon from the DOM.
 */
ClusterIcon.prototype.onRemove = function () {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    google.maps.event.clearInstanceListeners(this.div_);
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;


      if(this.shadowDiv_ && this.shadowDiv_.parentNode) {
          this.shadowDiv_.parentNode.removeChild(this.shadowDiv_);
          this.shadowDiv_ = null;
      }

  }
};


/**
 * Draws the icon.
 */
ClusterIcon.prototype.draw = function () {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + "px";
    this.div_.style.left = pos.x + "px";

      var pos = this.getPosFromLatLng_(this.center_);
      this.shadowDiv_.style.top = pos.y + "px";
      this.shadowDiv_.style.left = pos.x + "px";

  }
};


/**
 * Hides the icon.
 */
ClusterIcon.prototype.hide = function () {
  if (this.div_) {
    this.div_.style.display = "none";
  }
    if (this.shadowDiv_) {
        this.shadowDiv_.style.display = "none";
    }

  this.visible_ = false;
};


/**
 * Positions and shows the icon.
 */
ClusterIcon.prototype.show = function () {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    if (this.cluster_.printable_) {
      // (Would like to use "width: inherit;" below, but doesn't work with MSIE)
      this.div_.innerHTML = "<img src='" + this.url_ + "'><div style='position: absolute; top: 0px; left: 0px; width: " + this.width_ + "px;'>" + this.sums_.text + "</div>";
    } else {
      this.div_.innerHTML = this.sums_.text;
    }
    if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
    } else {
      this.div_.title = this.sums_.title;
    }
    this.div_.style.display = "";

      if(this.shadowDiv_) {

          this.shadowDiv_.style.cssText = this.createCssShadow(pos);
          this.shadowDiv_.style.display = "";

      }
  }
  this.visible_ = true;
};


/**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
ClusterIcon.prototype.useStyle = function (sums) {
  this.sums_ = sums;
  var index = Math.max(0, sums.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style.url;
  this.shadow_ = style.shadow;
  this.height_ = style.height;
  this.width_ = style.width;
  this.anchor_ = style.anchor;
  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
  this.textColor_ = style.textColor || "black";
  this.textSize_ = style.textSize || 11;
  this.textDecoration_ = style.textDecoration || "none";
  this.fontWeight_ = style.fontWeight || "bold";
  this.fontStyle_ = style.fontStyle || "normal";
  this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
  this.backgroundPosition_ = style.backgroundPosition || "0 0";
};



ClusterIcon.prototype.updateUrl = function (markers) {

    var uniqueMarkerColors = {};

    if (markers.length < 2)
        return;

    // data is separated by a ','; the colors are separated by a '|'

    var uniqueColorCount = 0;

    for (i = 0; i < markers.length; i++) {


        if (uniqueMarkerColors.hasOwnProperty(markers[i].hexColor)) {
            uniqueMarkerColors[markers[i].hexColor] = uniqueMarkerColors[markers[i].hexColor] + 1;
        } else {
            uniqueMarkerColors[markers[i].hexColor] = 1;
            uniqueColorCount++;
        }
    }

    var colorList = "";
    var countList = "";

    for (var color in uniqueMarkerColors) {

        if (colorList.length > 0)
            colorList = colorList + "|" + color;
        else
            colorList = color;

        if (countList.length > 0)
            countList = countList + "," + uniqueMarkerColors[color].toString();
        else
            countList = uniqueMarkerColors[color].toString();
    }

    // this.height_ = parseInt(this.height_ * 1.4);
    // this.width_ = parseInt(this.width_ * 1.4);

    if(uniqueColorCount == 1) {

           this.url_ = this.url_.replace("color_", markers[0].color)     ;
    }

    else {

        var heightIdx =       MarkerClusterer.IMAGE_SIZES.indexOf(this.height_) ;
        this.height_ =      MarkerClusterer.CHART_IMAGE_SIZES[heightIdx];
        this.width_ =      MarkerClusterer.CHART_IMAGE_SIZES[heightIdx];

        this.shadow_ = MarkerClusterer.CHART_SHADOW_PATH + "/" + this.width_.toString() +  MarkerClusterer.CHART_SHADOW;

        this.url_ = "//chart.googleapis.com/chart?cht=p&chs=" + this.height_.toString() + "x" + this.width_.toString() +

            "&chd=t:" + countList + "&chco=" + colorList + "&chf=a,s,000000|bg,s,67676700";
    }
    //  console.debug("url: " + this.height_);

}


/**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function (center) {
  this.center_ = center;
};


/**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
ClusterIcon.prototype.createCss = function (pos) {
  var style = [];
  if (!this.cluster_.printable_) {
    style.push('background-image:url(' + this.url_ + ');');
    style.push('background-position:' + this.backgroundPosition_ + ';');
  }

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + this.textColor_ + '; position:absolute; font-size:' +
      this.textSize_ + 'px; font-family:' + this.fontFamily_ + '; font-weight:' +
      this.fontWeight_ + '; font-style:' + this.fontStyle_ + '; text-decoration:' +
      this.textDecoration_ + ';');

  return style.join("");
};

ClusterIcon.prototype.createCssShadow = function (pos) {
    var style = [];
    if (!this.cluster_.printable_) {
        style.push('background-image:url(' + this.shadow_ + ');');
        style.push('background-position: -4px -4px;');
    }


  /*  if (typeof this.anchor_ === 'object') {
        if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
            this.anchor_[0] < this.height_) {
            style.push('height:' + (this.height_ - this.anchor_[0]) +
                'px; padding-top:' + this.anchor_[0] + 'px;');
        } else {
            style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
                'px;');
        }
        if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
            this.anchor_[1] < this.width_) {
            style.push('width:' + (this.width_ - this.anchor_[1]) +
                'px; padding-left:' + this.anchor_[1] + 'px;');
        } else {
            style.push('width:' + this.width_ + 'px; text-align:center;');
        }
    } else {
        style.push('height:' + this.height_ + 'px; line-height:' +
            this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
    }  */

    style.push('height:' + this.height_ + 'px; width:' + (this.width_ * 1.54).toString() + 'px;');

    style.push('z-index: -1; position: absolute; top:' + pos.y + 'px; left:' +
        pos.x + 'px; ');

    return style.join("");
}

/**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
ClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= this.anchorIcon_[1];
  pos.y -= this.anchorIcon_[0];
  return pos;
};


/**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
function Cluster(mc) {
  this.markerClusterer_ = mc;
  this.map_ = mc.getMap();
  this.gridSize_ = mc.getGridSize();
  this.minClusterSize_ = mc.getMinimumClusterSize();
  this.averageCenter_ = mc.getAverageCenter();
  this.printable_ = mc.getPrintable();
  this.markers_ = [];
  this.center_ = null;
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
}


/**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function () {
  return this.markers_.length;
};


/**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
Cluster.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
Cluster.prototype.getCenter = function () {
  return this.center_;
};


/**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
Cluster.prototype.getMap = function () {
  return this.map_;
};


/**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
Cluster.prototype.getMarkerClusterer = function () {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
Cluster.prototype.getBounds = function () {
  var i;
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster from the map.
 *
 * @ignore
 */
Cluster.prototype.remove = function () {
  this.clusterIcon_.setMap(null);
  this.markers_ = [];
  delete this.markers_;
};


/**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
Cluster.prototype.addMarker = function (marker) {
  var i;
  var mCount;
  var mz;

  if (this.isMarkerAlreadyAdded_(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  mCount = this.markers_.length;
  mz = this.markerClusterer_.getMaxZoom();
  if (mz !== null && this.map_.getZoom() > mz) {
    // Zoomed in past max zoom, so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount < this.minClusterSize_) {
    // Min cluster size not reached so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount === this.minClusterSize_) {
    // Hide the markers that were showing.
    for (i = 0; i < mCount; i++) {
      this.markers_[i].setMap(null);
    }
  } else {
    marker.setMap(null);
  }

  this.updateIcon_();
  return true;
};


/**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
Cluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Calculates the extended bounds of the cluster with the grid.
 */
Cluster.prototype.calculateBounds_ = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Updates the cluster icon.
 */
Cluster.prototype.updateIcon_ = function () {
  var mCount = this.markers_.length;
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz !== null && this.map_.getZoom() > mz) {
    this.clusterIcon_.hide();
    return;
  }

  if (mCount < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.useStyle(sums);

  // use the chart url (if appropriate)
  this.clusterIcon_.updateUrl(this.markers_);

  this.clusterIcon_.show();
};




/**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
Cluster.prototype.isMarkerAlreadyAdded_ = function (marker) {
  var i;
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) !== -1;
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        return true;
      }
    }
  }
  return false;
};


/**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {boolean} [printable=false] Whether to make the cluster icons printable. Do not
 *  set to <code>true</code> if the <code>url</code> fields in the <code>styles</code> array
 *  refer to image sprite files.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR]
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
/**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);

  opt_markers = opt_markers || [];
  opt_options = opt_options || {};

  this.markers_ = [];
  this.clusters_ = [];
  this.listeners_ = [];
  this.activeMap_ = null;
  this.ready_ = false;

  this.gridSize_ = opt_options.gridSize || 60;
  this.minClusterSize_ = opt_options.minimumClusterSize || 2;
  this.maxZoom_ = opt_options.maxZoom || null;
  this.styles_ = opt_options.styles || [];
  this.title_ = opt_options.title || "";
  this.zoomOnClick_ = true;
  if (opt_options.zoomOnClick !== undefined) {
    this.zoomOnClick_ = opt_options.zoomOnClick;
  }
  this.averageCenter_ = false;
  if (opt_options.averageCenter !== undefined) {
    this.averageCenter_ = opt_options.averageCenter;
  }
  this.ignoreHidden_ = false;
  if (opt_options.ignoreHidden !== undefined) {
    this.ignoreHidden_ = opt_options.ignoreHidden;
  }
  this.printable_ = false;
  if (opt_options.printable !== undefined) {
    this.printable_ = opt_options.printable;
  }
  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
  this.clusterClass_ = opt_options.clusterClass || "cluster";

  if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
    // Try to avoid IE timeout when processing a huge number of markers:
    this.batchSize_ = this.batchSizeIE_;
  }

  this.setupStyles_();

  this.addMarkers(opt_markers, true);
  this.setMap(map); // Note: this causes onAdd to be called
}


/**
 * Implementation of the onAdd interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function () {
  var cMarkerClusterer = this;

  this.activeMap_ = this.getMap();
  this.ready_ = true;

  this.repaint();

  // Add the map event listeners
  this.listeners_ = [
    google.maps.event.addListener(this.getMap(), "zoom_changed", function () {
      cMarkerClusterer.resetViewport_(false);
      // Workaround for this Google bug: when map is at level 0 and "-" of
      // zoom slider is clicked, a "zoom_changed" event is fired even though
      // the map doesn't zoom out any further. In this situation, no "idle"
      // event is triggered so the cluster markers that have been removed
      // do not get redrawn. Same goes for a zoom in at maxZoom.
      if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
       //   console.debug("triggering idle call from marker cluster-er");
        google.maps.event.trigger(this, "idle");
      }
    }),
    google.maps.event.addListener(this.getMap(), "idle", function () {
      //  console.debug("idle called from marker cluster-er");
      cMarkerClusterer.redraw_();
    })
  ];
};


/**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
MarkerClusterer.prototype.onRemove = function () {
  var i;

  // Put all the managed markers back on the map:
  for (i = 0; i < this.markers_.length; i++) {
    if (this.markers_[i].getMap() !== this.activeMap_) {
      this.markers_[i].setMap(this.activeMap_);
    }
  }

  // Remove all clusters:
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Remove map event listeners:
  for (i = 0; i < this.listeners_.length; i++) {
    google.maps.event.removeListener(this.listeners_[i]);
  }
  this.listeners_ = [];

  this.activeMap_ = null;
  this.ready_ = false;
};


/**
 * Implementation of the draw interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function () {};


/**
 * Sets up the styles object.
 */
MarkerClusterer.prototype.setupStyles_ = function () {
  var i, size;
  if (this.styles_.length > 0) {
    return;
  }

  for (i = 0; i < this.imageSizes_.length; i++) {
    size = this.imageSizes_[i];
    this.styles_.push({
      url: this.imagePath_ + "/" + ((i * 5) + 35) + "_color_." + this.imageExtension_,
      shadow: this.imagePath_ + "/" + ((i * 5) + 35) + "_shadow." + this.imageExtension_,
      height: size,
      width: size
    });
  }
};


/**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function () {
  var i;
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }

  this.getMap().fitBounds(bounds);
};


/**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function () {
  return this.gridSize_;
};


/**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
MarkerClusterer.prototype.setGridSize = function (gridSize) {
  this.gridSize_ = gridSize;
};


/**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
MarkerClusterer.prototype.getMinimumClusterSize = function () {
  return this.minClusterSize_;
};

/**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
MarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {
  this.minClusterSize_ = minimumClusterSize;
};


/**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function () {
  return this.maxZoom_;
};


/**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function (maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
MarkerClusterer.prototype.getStyles = function () {
  return this.styles_;
};


/**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
MarkerClusterer.prototype.setStyles = function (styles) {
  this.styles_ = styles;
};


/**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
MarkerClusterer.prototype.getTitle = function () {
  return this.title_;
};


/**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
MarkerClusterer.prototype.setTitle = function (title) {
  this.title_ = title;
};


/**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
MarkerClusterer.prototype.getZoomOnClick = function () {
  return this.zoomOnClick_;
};


/**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
MarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {
  this.zoomOnClick_ = zoomOnClick;
};


/**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
MarkerClusterer.prototype.getAverageCenter = function () {
  return this.averageCenter_;
};


/**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
MarkerClusterer.prototype.setAverageCenter = function (averageCenter) {
  this.averageCenter_ = averageCenter;
};


/**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
MarkerClusterer.prototype.getIgnoreHidden = function () {
  return this.ignoreHidden_;
};


/**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
MarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {
  this.ignoreHidden_ = ignoreHidden;
};


/**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
MarkerClusterer.prototype.getImageExtension = function () {
  return this.imageExtension_;
};


/**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
MarkerClusterer.prototype.setImageExtension = function (imageExtension) {
  this.imageExtension_ = imageExtension;
};


/**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
MarkerClusterer.prototype.getImagePath = function () {
  return this.imagePath_;
};


/**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
MarkerClusterer.prototype.setImagePath = function (imagePath) {
  this.imagePath_ = imagePath;
};


/**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
MarkerClusterer.prototype.getImageSizes = function () {
  return this.imageSizes_;
};


/**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
MarkerClusterer.prototype.setImageSizes = function (imageSizes) {
  this.imageSizes_ = imageSizes;
};


/**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
MarkerClusterer.prototype.getCalculator = function () {
  return this.calculator_;
};


/**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
MarkerClusterer.prototype.setCalculator = function (calculator) {
  this.calculator_ = calculator;
};


/**
 * Returns the value of the <code>printable</code> property.
 *
 * @return {boolean} the value of the printable property.
 */
MarkerClusterer.prototype.getPrintable = function () {
  return this.printable_;
};


/**
 * Sets the value of the <code>printable</code> property.
 *
 *  @param {boolean} printable The value of the printable property.
 */
MarkerClusterer.prototype.setPrintable = function (printable) {
  this.printable_ = printable;
};


/**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
MarkerClusterer.prototype.getBatchSizeIE = function () {
  return this.batchSizeIE_;
};


/**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
MarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {
  this.batchSizeIE_ = batchSizeIE;
};


/**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
MarkerClusterer.prototype.getClusterClass = function () {
  return this.clusterClass_;
};


/**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
MarkerClusterer.prototype.setClusterClass = function (clusterClass) {
  this.clusterClass_ = clusterClass;
};


/**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
MarkerClusterer.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function () {
  return this.markers_.length;
};


/**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getClusters = function () {
  return this.clusters_;
};


/**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getTotalClusters = function () {
  return this.clusters_.length;
};


/**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {
  var i;
  for (i = 0; i < markers.length; i++) {
    this.pushMarkerTo_(markers[i]);
  }
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.pushMarkerTo_ = function (marker) {
  // If the marker is draggable add a listener so we can update the clusters on the dragend:
  if (marker.getDraggable()) {
    var cMarkerClusterer = this;
    google.maps.event.addListener(marker, "dragend", function () {
      if (cMarkerClusterer.ready_) {
        this.isAdded = false;
        cMarkerClusterer.repaint();
      }
    });
  }
  marker.isAdded = false;
  this.markers_.push(marker);
};


/**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {
  var i, r;
  var removed = false;

  for (i = 0; i < markers.length; i++) {
    r = this.removeMarker_(markers[i]);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
MarkerClusterer.prototype.removeMarker_ = function (marker) {
  var i;
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        index = i;
        break;
      }
    }
  }

  if (index === -1) {
    // Marker is not in our list of markers, so do nothing:
    return false;
  }

  marker.setMap(null);
  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers
  return true;
};


/**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function () {
  this.resetViewport_(true);
  this.markers_ = [];
};


/**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
MarkerClusterer.prototype.repaint = function () {
  var oldClusters = this.clusters_.slice();
  this.clusters_ = [];
  this.resetViewport_(false);
  this.redraw_();

  // Remove the old clusters.
  // Do it in a timeout to prevent blinking effect.
  setTimeout(function () {
    var i;
    for (i = 0; i < oldClusters.length; i++) {
      oldClusters[i].remove();
    }
  }, 0);
};


/**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
MarkerClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Redraws all the clusters.
 */
MarkerClusterer.prototype.redraw_ = function () {
  this.createClusters_(0);
};


/**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
MarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
  var i, marker;
  // Remove all the clusters
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Reset the markers to not be added and to be removed from the map.
  for (i = 0; i < this.markers_.length; i++) {
    marker = this.markers_[i];
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }
};


/**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {
  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
  var i, d, cluster, center;
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  for (i = 0; i < this.clusters_.length; i++) {
    cluster = this.clusters_[i];
    center = cluster.getCenter();
    if (center) {
      d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
MarkerClusterer.prototype.createClusters_ = function (iFirst) {
  var i, marker;
  var mapBounds;
  var cMarkerClusterer = this;
  if (!this.ready_) {
    return;
  }

  // Cancel previous batch processing if we're working on the first batch:
  if (iFirst === 0) {
    /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringbegin", this);

    if (typeof this.timerRefStatic !== "undefined") {
      clearTimeout(this.timerRefStatic);
      delete this.timerRefStatic;
    }
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  //
  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
  if (this.getMap().getZoom() > 3) {
    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
      this.getMap().getBounds().getNorthEast());
  } else {
    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
  }
  var bounds = this.getExtendedBounds(mapBounds);

  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);

  for (i = iFirst; i < iLast; i++) {
    marker = this.markers_[i];
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
        this.addToClosestCluster_(marker);
      }
    }
  }

  if (iLast < this.markers_.length) {
    this.timerRefStatic = setTimeout(function () {
      cMarkerClusterer.createClusters_(iLast);
    }, 0);
  } else {
    delete this.timerRefStatic;

    /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringend", this);
  }
};


/**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function (obj1, obj2) {
  return (function (object) {
    var property;
    for (property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
MarkerClusterer.CALCULATOR = function (markers, numStyles) {
  var index = 0;
  var title = "";
  var count = markers.length.toString();

  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index,
    title: title
  };
};


/**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE = 2000;


/**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE_IE = 500;


/**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
//MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";


/**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_EXTENSION = "png";


/**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
//MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

MarkerClusterer.IMAGE_PATH = "/cluster_images/solid";
MarkerClusterer.IMAGE_SIZES = [35, 40,45, 50,55, 60, 65 ]; //, 70, 75, 80, 85, 90, 95];
MarkerClusterer.CHART_IMAGE_SIZES = [50,55, 60, 65, 70, 73, 75 ]; //, 80, 85, 90, 95, 100, 105];

MarkerClusterer.CHART_SHADOW_PATH = "/cluster_images/chart";
MarkerClusterer.CHART_SHADOW = "_shadow.png"
// setup the click controls for moving from the multi-select fro the
// description.

// for IE-8
if (!window.console) console = {debug: function(str) {}};

// TODO: comment out the below for non-IE testing (and prod)
var console=console||{"debug":function(){}};


// for IE-8
// add trim where it does not exist, mainly IE 8 and below.
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g,'');
    }
}

    // for IE-8
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(obj, start) {
        for (var i = (start || 0), j = this.length; i < j; i++) {
            if (this[i] === obj) { return i; }
        }
        return -1;
    }
}


function fUNQ24() {

    var noDisplayElement = document.getElementById('noDisplay');
    var toDisplayElement = document.getElementById('toDisplay');

    jQuery('#moveToDisplay').click(function () {



        $('#noDisplay option:selected').each(function () {
            $('#toDisplay').append($(this).clone(true));
            $(this).remove();
        });

        fUNQ25(toDisplayElement)  ;

        fUNQ27();

        //     jQuery('#moveToDisplay').attr("disabled", "disabled");
    });

    jQuery('#removeFromDisplay').click(function () {


        $('#toDisplay option:selected').each(function () {
            $('#noDisplay').append($(this).clone(true));
            $(this).remove();
        });

        fUNQ25(noDisplayElement)  ;

        fUNQ27();
        //     jQuery('#moveToDisplay').removeAttr("disabled");
    });

    jQuery('#moveAllToDisplay').click(function () {


        $('#noDisplay option').each(function () {
            $('#toDisplay').append($(this).clone(true));
            $(this).remove();
        });
        fUNQ25(toDisplayElement)  ;
        fUNQ27();

    });

    jQuery('#removeAllFromDisplay').click(function () {


        $('#toDisplay option').each(function () {
            $('#noDisplay').append($(this).clone(true));
            $(this).remove();
        });
        fUNQ25(noDisplayElement)  ;
        fUNQ27();
    });


}

function fUNQ25(selElem) {
    var tmpAry = [], i;
    for ( i=0;i<selElem.options.length;i++) {
        tmpAry[i] = [];
        tmpAry[i][0] = selElem.options[i].text;
        tmpAry[i][1] = selElem.options[i].value;
    }
   // tmpAry.sort()

    tmpAry.sort(function (a, b) {

        return a[1] - b[1] ;
    });

    while (selElem.options.length > 0) {
        selElem.options[0] = null;
    }
    for ( i=0;i<tmpAry.length;i++) {
        selElem.options[i] = new Option(tmpAry[i][0], tmpAry[i][1]);
    }
}

// This routine is specific to setting the region.
/*
function fUNQ26(selElem) {
    var tmpAry = [], i;
    for ( i=1;i<selElem.options.length;i++) {
        tmpAry[i - 1] = [];
        tmpAry[i - 1][0] = selElem.options[i ].text;
        tmpAry[i - 1][1] = selElem.options[i ].value;
        tmpAry[i - 1][2] = selElem.options[i ].selected;
    }
    // tmpAry.sort()

    tmpAry.sort(function (a, b) {
        return a[0].localeCompare(b[0]);
       // return a[0] - b[0] ;
    });

    while (selElem.options.length > 1) {
        selElem.options[1] = null;
    }
    for ( i=1;i<tmpAry.length;i++) {
        var op = new Option(tmpAry[i - 1][0], tmpAry[i - 1][1]);

        if(tmpAry[i-1][2] == true)
        op.selected =true;

        selElem.options[i] = op;
    }
}
*/

// This is implemented to change when the items to display changes.
function fUNQ27() {


   // var markerDesc = [];

    mObject.headerDisplayOrderIdxs.length = 0;

    var descDisplay ;

    var firstLine = dataLines[0];

    var heightPx = 0;


    $('#toDisplay option').each(function () {



      //  var label = $(this).text();
        var idx = $(this).attr('value');
      //  markerDesc[markerDesc.length] = idx;
        mObject.headerDisplayOrderIdxs[mObject.headerDisplayOrderIdxs.length] = parseFloat(idx);


        heightPx += 30;

    });


   descDisplay = '<div id="innerMarkerDescDiv" >' + fUNQ28(firstLine) + '</div>';
    //descDisplay = '<div>' + fUNQ28(firstLine) + '</div>';
    $('#markerDescriptionDiv').html(descDisplay);

  /*  if(heightPx > 450) {
        heightPx = 450;
    }
    */
   // heightPx = heightPx + "px";

    // TODO ***** use this in more areas!
   // $('#markerDescriptionDiv').css('height', heightPx);


}

// Show the title at the top and have it link to the website if there is a website
//
function fUNQ28(dataItem) {

    var title = "";

    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

        if(fUNQ178(mObject.web)  && dataItem[mObject.web] != "")  {
            title = '<div><a href="'+urlizeUrl(dataItem[mObject.web])+ '" target="_blank">'+ dataItem[mObject.title] + '</a></div>';
        }
        else
            title = dataItem[mObject.title];

    }
    var address ;


        address = fUNQ162(dataItem, "<br>", true);

        if(address != "") {
            address    = '<div>' + address +   '</div>';
            // link the address to something
        }


    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {


                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');


                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }
            }
        }

    }



    var firstHalf = title + address + descDisplay;
   // ; //;+

      //    + descDisplay ;
    firstHalf +=        fUNQ29(dataItem, title)  ;

    return firstHalf;
}


function fUNQ29(dataItem, title) {

    var secondHalf = "";

    var siteImage =  "";
    if(fUNQ178(mObject.image) && dataItem[mObject.image] != "")  {
        siteImage = '<div><img src="' + dataItem[mObject.image] + '"/></div>';
    }

    var email = "";
    if(fUNQ178(mObject.email) && dataItem[mObject.email] != "") {
        email = '<div>e-mail: <a href="mailto:' + dataItem[mObject.email] + '">' +   dataItem[mObject.email] + '</a></div>';

    }
    var website = "";
    if(title == "" && fUNQ178(mObject.web) && dataItem[mObject.web] != "")  {
        website = '<div><a href="' + urlizeUrl(dataItem[mObject.web]) + '" target="_blank">' +   dataItem[mObject.web] + '</a></div>';
    }

    secondHalf += siteImage ;
    secondHalf +=   email ;
    secondHalf +=  website;
    return secondHalf;
}


function fUNQ30(a) {
    return /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/.test(a)             ;
}

function fUNQ31(a) {
    return /^[a-zA-Z0-9_-]+$/.test(a)             ;
}

/*function validateEmailComplex(a) {

     return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,4})+$/.test(a) ;
}        */

function fUNQ32(filterLimit) {

    jQuery('#moveToFilter').click(function () {

        var toFilterSelector =  $('#toFilter');



        $('#noFilter option:selected').each(function () {

            if(filterLimit >  toFilterSelector.children().length) {
                $('#toFilter').append($(this).clone(true));
                $(this).remove();

            }
        });

        if(filterLimit <=  toFilterSelector.children().length) {
            jQuery('#moveToFilter').attr("disabled", "disabled");
        }

    });

    jQuery('#removeFromFilter').click(function () {


        $('#toFilter option:selected').each(function () {
            $('#noFilter').append($(this).clone(true));
            $(this).remove();
        });

        jQuery('#moveToFilter').removeAttr("disabled");
    });

    /*   jQuery('#moveAllToDisplay').click(function () {


     $('#noDisplay option').each(function () {
     $('#toDisplay').append($(this).clone(true));
     $(this).remove();
     });


     });
     */

    jQuery('#removeAllFromFilter').click(function () {


        $('#toFilter option').each(function () {
            $('#noFilter').append($(this).clone(true));
            $(this).remove();
        });

        jQuery('#moveToFilter').removeAttr("disabled");

    });

}


// toItems and from items have the indexes,
// allItems has the index with the name
function fUNQ33(availableFromId, availableToId, toItems, fromItems, allItems) {

    var    availableFromIdSelector =  jQuery("#" + availableFromId),
        availableToIdSelector =    jQuery("#" + availableToId);

    availableFromIdSelector.empty();
    availableToIdSelector.empty();

    var appendFroms = "", idx;

    for (  idx = 0; idx < fromItems.length; idx++) {
        appendFroms += '<option value="' + fromItems[idx] + '">' + allItems[fromItems[idx] ] + '</option>';

    }


    var appendTo = "";
    for ( idx = 0; idx < toItems.length; idx++) {
        appendTo += '<option value="' + toItems[idx] + '">' + allItems[toItems[idx] ] + '</option>';

    }

    if(appendFroms != "")
    {
        availableFromIdSelector.append(appendFroms);
    }


    if(appendTo != "")
    {
        availableToIdSelector.append(appendTo);
    }

}


function fUNQ34(columnHeaderArray, dataLines) {

    var columnIdxs = [];
    $('#toFilter option').each(function () {
        var attrValue = $(this).attr('value');



        columnIdxs.push(attrValue );
    });

    if(columnIdxs.length > 0 ) {
        mObject.filterColumnIdxs =  columnIdxs;
        fUNQ35(columnIdxs, columnHeaderArray, dataLines);
    }
    else if(mObject.filterListNames.length > 0 ) {
        mObject.filterListNames.length = 0;
        mObject.filterListArray.length = 0;
        mObject.filterListSortedKeyHash = {};

    }

}

function fUNQ35(columnHeaderIdxs, columnHeaderArray, dataLines) {

    mObject.filterListNames.length = 0;
    mObject.filterListArray.length = 0;
    mObject.filterListSortedKeyHash = {};


    for(var i = 0; i < columnHeaderIdxs.length; i++) {


        var columnIdx = columnHeaderIdxs[i];

        if(columnIdx >= columnHeaderArray.length ) {
        }

        else {
            var headerName = columnHeaderArray[columnIdx];

            fUNQ36(dataLines, headerName, columnIdx, MAX_FILTER_SIZE);
        }

    }

}


function fUNQ36(allData, filterName, filterIdx, maxFilterSize) {

    var bucketHash = {};  // key is the filter value, value is the index

    var allNumbers = true;
    var allDates = true;
    var bucketSize = 0;
    var bucketKeys = [];  // list of filters (column values) (correctly sorted???)




    for (var i = 0; i < allData.length; i++) {

        var dataLine = allData[i];

        var groupItem = dataLine[filterIdx];

        if(groupItem == null || groupItem.trim().length == 0 || groupItem  == ALL_FILTER)
        {
            continue;
        }


        if (allNumbers) {

            if (!$.isNumeric(fUNQ37(groupItem))) {
                allNumbers = false;
            }
        }

        if (allDates) {

            if (!fUNQ124(groupItem)) {
                allDates = false;
            }
        }
        var bucketLineIndex;

        if (bucketHash.hasOwnProperty(groupItem)) {
             bucketLineIndex = bucketHash[groupItem];
            bucketLineIndex.push(i);

        } else if (bucketSize < maxFilterSize) {
             bucketLineIndex = [];

            bucketLineIndex.push(i);
            bucketHash[groupItem] = bucketLineIndex;
            bucketKeys.push(groupItem);
            bucketSize++;
        }
    }


    if (allNumbers) {
        bucketKeys.sort(function (a, b) {
            return fUNQ37(a) - fUNQ37(b);
        });
    }

    else if (allDates) {
        fUNQ53(bucketKeys);
//        bucketKeys.sort(function (a, b) {
//            a = new Date(a);
//            b = new Date(b);
//            return a < b ? -1 : a > b ? 1 : 0;
//        });
    } else {
        bucketKeys.sort();
    }


    mObject.filterListNames.push(filterName);
    mObject.filterListArray.push( bucketHash);
    mObject.filterListSortedKeyHash[filterName] = bucketKeys;

}

function fUNQ37(v) {

        return parseFloat(v.toString().replace(/\$|\,|\s+|\%/g, "") );

}

function fUNQ38(v) {
    return v.toString().indexOf("%") != -1 ? "%" : ""
}
function fUNQ39(v) {
    return v.toString().indexOf("$") != -1 ? "$" : ""
}

// This was used for testing purposes
/*
function fUNQ40(groups) {


    var tempGroup = [];
    tempGroup.push(ALL_FILTER);
    tempGroup = tempGroup.concat(groups);

    var selStr = fUNQ49(tempGroup, ALL_FILTER, "group_filter", "Group");

    $('#usedGroup').html(selStr );

}
*/

// This is used for testing, on the page to generate maps
// This was used for testing purposes
/*
function fUNQ41() {


//      filterListNames.push(filterName);
//     filterListArray.push( bucketHash);
//     filterListSortedKeyHash[filerName] = bucketKeys;

    var filterDisplay = "";

    if(mObject.filterListNames.length == 0)
        return;

    selectedFilterValues = new Array(mObject.filterListNames.length);

    for(var i = 0; i < mObject.filterListNames.length; i++)
    {

        var tempFilter = [];
        tempFilter.push(ALL_FILTER);
        tempFilter = tempFilter.concat(mObject.filterListSortedKeyHash[mObject.filterListNames[i]]);

        var selStr = fUNQ49(tempFilter, ALL_FILTER, mObject.filterListNames[i] +"_rfilter", mObject.filterListNames[i]);

        filterDisplay = filterDisplay + "<li>" + selStr + "</li>";

        selectedFilterValues[i] = ALL_FILTER;

    }


    filterDisplay = "<ul>" + filterDisplay + "</ul>";

    $('#usedFilters').html(filterDisplay  );

}
*/


// This is used on the map
function fUNQ42() {


    /*  filterListNames.push(filterName);
     filterListArray.push( bucketHash);
     filterListSortedKeyHash[filerName] = bucketKeys;
     */
    var filterDisplay = "", filtersDiv;

    if(mObject.filterListNames.length == 0)   {


        if(userSettings.title != null && userSettings.title.length > 0)  {

             filtersDiv =  $('#filtersDiv');

            if(filtersDiv.length > 0 ) {
                filtersDiv.html('<div id="mapTitle">' + userSettings.title + '</div>');
                filtersDiv.show();
            }
        }

        return ;

    }


    selectedFilterValues = new Array(mObject.filterListNames.length);

    var titleDisplay = "", i;
  //  var filtersDisplay = "";

    for( i = 0; i < mObject.filterListNames.length; i++)
    {

        var tempFilter = [];
        tempFilter.push(ALL_FILTER);
        tempFilter = tempFilter.concat(mObject.filterListSortedKeyHash[mObject.filterListNames[i]]);

        var selStr = fUNQ49(tempFilter, ALL_FILTER, i.toString() +"_rfilter", null );

        titleDisplay = titleDisplay + "<td>" + mObject.filterListNames[i]+ "</td>";

        filterDisplay = filterDisplay + "<td>" + selStr + "</td>";

        selectedFilterValues[i] =            ALL_FILTER;
    }

     var totalTable = "<div><table><tbody><tr>" +  titleDisplay +  "</tr><tr>" +  filterDisplay + "</tr></tbody></table></div>";
   // filterDisplay = "<ul>" + filterDisplay + "</ul>";

    //  only use this for debugging!
   // $('#usedFilters').html(totalTable  );

     filtersDiv =  $('#filtersDiv');

    if(filtersDiv.length > 0 ) {
        filtersDiv.html(totalTable);
        filtersDiv.show();
    }

    //
    for( i = 0; i < mObject.filterListNames.length; i++)
    {
        var currentIdx = i;
        var filterName = i.toString() +"_rfilter";

        fUNQ43(filterName, currentIdx)    ;

     /*   jQuery('#' + filterName).change(function () {

            //    mObject.selectedMapType = this.value;
            selectedFilterValues[currentIdx] = this.value;

            // call function to do stuff with the filters!
            fUNQ164();

        });           */
    }


}

function fUNQ43(filterName, filterIdx) {

    jQuery('#' + filterName).change(function () {

        //    mObject.selectedMapType = this.value;
        selectedFilterValues[filterIdx] = this.value;

        // call function to do stuff with the filters!
        fUNQ164();

    });
}


function fUNQ44(filterName, filterValue) {

    var idx = mObject.filterListNames.indexOf(filterName);

    if(idx == -1)
    {
        return [];
    }

    var bucketHash = mObject.filterListArray[idx];

    if (bucketHash.hasOwnProperty(filterValue)) {
        return  bucketHash[filterValue];
    }


    return [];
}


function fUNQ45(allData) {
    var attrValue = $('#group_sel option:selected').attr('value');


    if(attrValue == "none") {
        // do nothing;
        return;
    }

    fUNQ50(allData, attrValue, MAX_GROUPS);

     if(mObject.sortedGroupKeys.length > 1) {
         fUNQ46(allData.length);
     }

}

function fUNQ46(arraySize) {

    var imageIdxs = new Array(arraySize);

    mObject.groupImageHash = {};

    var imageIdx = 0;
    // for (var groupName in mObject.groupHash) {

    for(var j=0; j < mObject.sortedGroupKeys.length; j++)      {
        var groupName =     mObject.sortedGroupKeys[j];

        if(mObject.groupHash.hasOwnProperty(groupName))  {
            var bucketLineIndex = mObject.groupHash[groupName];

            for(var i = 0; i < bucketLineIndex.length; i++)  {
                imageIdxs[bucketLineIndex[i]]  = imageIdx;
            }

            mObject.groupImageHash[groupName]  = imageIdx;
            imageIdx++;
        }
    }

    if( mObject.sortedGroupKeys.length > 1)
     mObject.markerImageIdx =    imageIdxs;
}

function fUNQ47(groupName) {


    if (mObject.groupHash.hasOwnProperty(groupName)) {
       return  mObject.groupHash[groupName];

    }


    return [];
}


function fUNQ48(selectableItems, selectedItem, selectId)      {

    var dropDown = $('#' + selectId);

    var selStr = "";

    for (var i = 0; i < selectableItems.length; i++) {


        if (selectableItems[i] == selectedItem) {
            selStr = selStr.concat('<option value="'  + selectableItems[i] + '" selected>' +

                selectableItems[i] + '</option>\n');

            //selected_columns[selectId] = selItemsIdx[selItem];


        } else {
            selStr = selStr.concat('<option value="' + selectableItems[i] + '" >' +

                selectableItems[i] + '</option>\n');
        }
    }

    dropDown.html(selStr);

}

// builds the string for the drop down, return the string.
// The resulting string can be added to a div.
// a change select can also be added for this.
function fUNQ49(selectableItems, selectedItem, selectId, labelName, selectWidth) {


    var widthStr = "";

    var defaultWidth = "250";
    if(selectWidth != undefined)
    {
        defaultWidth = selectWidth;

        widthStr = ' style="width: '+ defaultWidth +'px;" ';
    }

    var labelStr = "";

    if(labelName)        {
        labelStr = '<label id="' + selectId + '_label" for="' + selectId + '">' + labelName  + '</label>';
    }



    var selStr = '<select name="' + selectId + '" id="' + selectId + '"' +  widthStr + '>\n';

    for (var i = 0; i < selectableItems.length; i++) {


        if (selectableItems[i] == selectedItem) {
            selStr = selStr.concat('<option value="'  + selectableItems[i] + '" selected>' +

                selectableItems[i] + '</option>\n');

            //selected_columns[selectId] = selItemsIdx[selItem];


        } else {
            selStr = selStr.concat('<option value="' + selectableItems[i] + '" >' +

                selectableItems[i] + '</option>\n');
        }
    }

    selStr = selStr.concat("</select>");

    return labelStr + selStr;

}





// grouping: a hash with the key being the group and the value being an array with indexes of the markers
// allData is the original data, it's an array, so the rows will need to be split based on tab
// maxGroupCount is the groups that will get bucketed

function fUNQ50(allData, groupIdx, bucketSizeLimit) {

    if(groupIdx < 0)
        return;

    var bucketHash ={};


    var allNumbers = true;
    var allDates = true;
    var bucketSize = 0;
    var bucketKeys = [];

    var emptyGroup = [];
    var i;


// used to help grouping
    //var first, last, next, rangeKey, tempIndxs;

    mObject.sortedGroupKeys.length = 0;
    mObject.groupHash = {};

    for ( i = 0; i < allData.length; i++) {

        var dataLine = allData[i];

        if(dataLine == null || dataLine.length == 0)
            continue;

        var groupItem =  dataLine[groupIdx];

        if(groupItem.trim() == "")
        {
            emptyGroup.push(i);
            continue;
        }

        if (allNumbers) {

            if (!$.isNumeric(fUNQ37(groupItem))) {
                allNumbers = false;
            }
        }

        if (allDates) {

            if (!fUNQ124(groupItem)) {
                allDates = false;
            }
        }

        var bucketLineIndex;
        if (bucketHash.hasOwnProperty(groupItem)) {
             bucketLineIndex = bucketHash[groupItem];
            bucketLineIndex.push(i);

        } else {
             bucketLineIndex = [];

            bucketLineIndex.push(i);
            bucketHash[groupItem] = bucketLineIndex;
            bucketKeys.push(groupItem);
            bucketSize++;
        }
    }

    if(emptyGroup.length > 0)
     bucketSizeLimit = bucketSizeLimit -1;

    if(bucketSizeLimit >= bucketSize) {

        if (allNumbers) {
            bucketKeys.sort(function (a, b) {
                return fUNQ37(a) - fUNQ37(b) ;
            });
        }


        else if (allDates) {

            fUNQ53(bucketKeys);

//            // reverse the date and month for non-United States Regions
//            if(mObject.region != null && mObject.region != "us") {
//                for ( i = 0; i < bucketKeys.length; i++) {
//                    bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
//                }
//            }
//
//              bucketKeys.sort(function (a, b) {
//                a = new Date(a);
//                b = new Date(b);
//
//                return a < b ? -1 : a > b ? 1 : 0;
//              });
//
//            // Revert back to the original data/time format for non-us regions
//            if(mObject.region != null && mObject.region != "us") {
//                for ( i = 0; i < bucketKeys.length; i++) {
//                    bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
//                }
//
//            }

        }

        else {
            bucketKeys.sort();
        }

        for ( i = 0; i < bucketKeys.length; i++) {
            mObject.sortedGroupKeys.push(bucketKeys[i]);
            mObject.groupHash[bucketKeys[i]] =  bucketHash[bucketKeys[i]]  ;
        }
    }


    if (bucketSize > bucketSizeLimit) {
      //  var mergeBuckets = Math.ceil(bucketSize / bucketSizeLimit);
       // var remainder = bucketSize % bucketSizeLimit;

       // var tempHash = {};

        if (allNumbers) {
            bucketKeys.sort(function (a, b) {
                return fUNQ37(a) - fUNQ37(b) ;
            });


//             first = parseInt(bucketKeys[0], 10);
//             last = parseInt(bucketKeys[bucketKeys.length - 1], 10);
//            // var rangeSize = (last - first) / bucketSizeLimit;
//
//            // var next = first + rangeSize;
//            // var next = bucketKeys[mergeBuckets]
//            var nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, 0);
//            // want to get the item before nextIdx instead of doing -1 (same for the case below as well)
//             next = parseInt(bucketKeys[nextIdx -1] , 10 ) ;
//
//
//             rangeKey = first + "-" + next;
//
//            if(first == next)
//                rangeKey = first;
//
//             tempIndxs = [];
//            mObject.groupHash[rangeKey] = tempIndxs ;
//
//
//
//            /*      for (var i = 0; i < bucketKeys.length; i++) {
//
//             if ((bucketKeys[i] / 1) > next) {
//             first = next + 1;
//             next = next + rangeSize;
//
//             if (next > last) next = last;
//
//             rangeKey = first + "-" + next;
//             var tempIndxs = [];
//
//             mObject.groupHash[rangeKey] = tempIndxs;
//             }*/
//
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if ( i >= nextIdx   && nextIdx < bucketSize -1) {
//
//                    first = bucketKeys[nextIdx];
//
//                        nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, i);
//                        next = parseInt(bucketKeys[nextIdx - 1] , 10 ) ;
//
//
//                    if(nextIdx == bucketSize -1) {
//                        next =     parseInt(bucketKeys[nextIdx] , 10 ) ;
//                    }
//
//                  //  if(nextIdx == bucketSize -1)
//                   //     next += 1;
//
//                    rangeKey = first + "-" + next;
//
//                    if(first == next)
//                        rangeKey = first;
//
//                    tempIndxs = [];
//
//                    mObject.groupHash[rangeKey] = tempIndxs;
//                }
//
//                mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//                tempIndxs = mObject.groupHash[rangeKey];
//
//                if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
//                    mObject.sortedGroupKeys.push(rangeKey);
//                }
//            }

        }

        else if (allDates) {

            fUNQ53(bucketKeys);

//            bucketKeys.sort(function (a, b) {
//                a = new Date(a);
//                b = new Date(b);
//
//                return a < b ? -1 : a > b ? 1 : 0;
//            });


//             first = bucketKeys[0];
//             last = bucketKeys[bucketKeys.length - 1];
//
//            var firstDate = new Date(first).getTime();
//            var lastDate = new Date(last).getTime();
//
//
//            var rangeSize = (lastDate - firstDate) / bucketSizeLimit;
//
//             next = firstDate + rangeSize;
//             rangeKey = new Date(firstDate).toDateString() + "-" + new Date(next).toDateString();
//             tempIndxs = [];
//            mObject.groupHash[rangeKey] = tempIndx;
//
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if ((new Date(bucketKeys[i]).getTime()) > next) {
//                    first = next + 1;
//                    next = next + rangeSize;
//
//                    if (next > last) next = last;
//
//                    rangeKey = new Date(firstDate).toDateString() + "-" + new Date(next).toDateString();
//                    tempIndxs = [];
//
//                    mObject.groupHash[rangeKey] = tempIndxs;
//                }
//                mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//                tempIndxs = mObject.groupHash[rangeKey];
//
//                if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
//                    mObject.sortedGroupKeys.push(rangeKey);
//                }
//            }



        } else {

            bucketKeys.sort(function(a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            } );
           // bucketKeys.sort();

//            // take the first x number of  items and group all the rest in the 'Other' bucket
//            for ( i = 0; i < bucketKeys.length; i++) {
//
//                if (i < bucketSizeLimit - 1 || bucketKeys.length == bucketSizeLImit) {
//                    mObject.groupHash[bucketKeys[i]] = bucketHash[bucketKeys[i]];
//                    mObject.sortedGroupKeys.push(bucketKeys[i]);
//
//                } else {
//                    if (mObject.groupHash.hasOwnProperty('Other')) {
//                         tempIndxs = mObject.groupHash['Other'];
//                        mObject.groupHash['Other'] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
//
//                    } else {
//                        mObject.groupHash['Other'] = bucketHash[bucketKeys[i]];
//                    }
//
//                    if(mObject.sortedGroupKeys.indexOf('Other') == -1)
//                        mObject.sortedGroupKeys.push('Other');
//
//                }
//
//            }

        }

        fUNQ51(bucketHash, bucketKeys, bucketSize, bucketSizeLimit);
    }

    if(emptyGroup.length > 0)
    {
        mObject.groupHash['Empty'] = emptyGroup;

        mObject.sortedGroupKeys.push('Empty');
    }

}

function fUNQ51(bucketHash, bucketKeys, bucketSize, bucketSizeLimit) {

    var i;
    var mergeBuckets = Math.ceil(bucketSize / bucketSizeLimit);
    var remainder = bucketSize % bucketSizeLimit;


    var first, /*last,*/ next, rangeKey, tempIndxs;

    first = bucketKeys[0];
  //  last = parseInt(bucketKeys[bucketKeys.length - 1], 10);
    // var rangeSize = (last - first) / bucketSizeLimit;

    // var next = first + rangeSize;
    // var next = bucketKeys[mergeBuckets]
    var nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, 0);
    // want to get the item before nextIdx instead of doing -1 (same for the case below as well)
    next = bucketKeys[nextIdx -1] ;


    rangeKey = first + "-" + next;

    if(first == next)
        rangeKey = first;

    tempIndxs = [];
    mObject.groupHash[rangeKey] = tempIndxs ;



    /*      for (var i = 0; i < bucketKeys.length; i++) {

     if ((bucketKeys[i] / 1) > next) {
     first = next + 1;
     next = next + rangeSize;

     if (next > last) next = last;

     rangeKey = first + "-" + next;
     var tempIndxs = [];

     mObject.groupHash[rangeKey] = tempIndxs;
     }*/

    for ( i = 0; i < bucketKeys.length; i++) {

        if ( i >= nextIdx   && nextIdx < bucketSize -1) {

            first = bucketKeys[nextIdx];

            nextIdx =  fUNQ52( bucketSize, mergeBuckets, remainder, i);
            next = bucketKeys[nextIdx - 1] ;


            if(nextIdx == bucketSize -1) {
                next =     bucketKeys[nextIdx]  ;
            }

            //  if(nextIdx == bucketSize -1)
            //     next += 1;

            rangeKey = first + "-" + next;

            if(first == next)
                rangeKey = first;

            tempIndxs = [];

            mObject.groupHash[rangeKey] = tempIndxs;
        }

        mObject.groupHash[rangeKey] = tempIndxs.concat(bucketHash[bucketKeys[i]]);
        tempIndxs = mObject.groupHash[rangeKey];

        if(mObject.sortedGroupKeys.indexOf(rangeKey) == -1) {
            mObject.sortedGroupKeys.push(rangeKey);
        }
    }

}


function fUNQ52(totalItems, ceiling, remainder, currentIdx) {

// 19 / 7 -> 3
// 19 %  7 = 5  -> means 5 get 3 and the others get 1 less

    var increments = 0;
    for(var i = 0; i <= totalItems; i += ceiling)
    {

        if(increments > remainder && remainder != 0) {
            i -= 1;
        }

        if( i > currentIdx)
        {
            if(i >= totalItems)
                return totalItems - 1;
            return i;
        }

        increments++;
    }

    return totalItems - 1;

}

function fUNQ53(bucketKeys) {

    var i;

    // reverse the date and month for non-United States Regions
    if(mObject.regionCode != null && mObject.regionCode.length > 0 && mObject.regionCode != "us") {
        for ( i = 0; i < bucketKeys.length; i++) {
            bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
        }
    }

    bucketKeys.sort(function (a, b) {
        a = new Date(a);
        b = new Date(b);

        return a < b ? -1 : a > b ? 1 : 0;
    });

    // Revert back to the original data/time format for non-us regions
    if(mObject.regionCode != null && mObject.regionCode.length > 0 && mObject.regionCode != "us") {
        for ( i = 0; i < bucketKeys.length; i++) {
            bucketKeys[i] = bucketKeys[i].replace(/(\d+)\/(\d+)\//,"$2/$1/");
        }

    }
}


function fUNQ54() {

    var str = "", i;

    for(i = 0; i < dataLines.length; i++) {

        if(dataLines[i] == null || dataLines[i].length == 0)
            continue;

        str = str + dataLines[i].join('\t') + "\n";

    }
    return str;
}

function fUNQ55(data) {

    if(data.country_code) {


        var selectedOption = $('#region_sel option[value="' + data.country_code.toLowerCase()  + '"]')     ;

        if(selectedOption.length > 0) {
            selectedOption.prop('selected', true) ;
        }
//        else {
//
//            // add the element
//            var regionSel = document.getElementById("region_sel");
//            var controlOption =  document.createElement('option');
//            controlOption.value=  data.country_code.toLowerCase() ;
//            controlOption.innerHTML = data.country;
//
//            regionSel.appendChild(controlOption);
//            controlOption.selected = true;
//            fUNQ26(regionSel) ;
//
//        }

    }

}

function fUNQ56(ipAddress) {

    $.ajax({
        type: 'GET',
        url: 'http://www.easymapmaker.com/location',
        data: { ip_addr: ipAddress },
        dataType: 'json',
        success:function(data, status, result){

            var tmpStatus = "OK";
            if(data.errorMessage) {
                //      alert(data.errorMessage);
                tmpStatus = data.errorMessage;
            }

            if(data.reservedIp != 0) {
                tmpStatus = "Reserved IP";
            }
                fUNQ95(data, tmpStatus, ipAddress);


        },
        error:function(data, status, result){

            var tmpStatus = "Other Error";
            if(data.errorMessage) {
                //   alert(data.errorMessage);
                tmpStatus = data.errorMessage;
            }
            fUNQ95(data, tmpStatus, ipAddress);

            //     $("#resultDiv").html(result);
        }
    });
}

function fUNQ57() {

    $.ajax({
        type: 'GET',
        url: 'http://www.easymapmaker.com/location',
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
          //      alert(data.errorMessage);
            }

            if(data.reservedIp == 0) {
                           fUNQ55(data);
            }

        },
        error:function(data, status, result){

            if(data.errorMessage) {
             //   alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);
        }
    });
 }

function fUNQ58(mapId) {

    var kmlData =       fUNQ197();

    $.ajax({
        type: 'POST',
        url: '/savekml',
        data: { kml: kmlData, Id: mapId },
        cache: false,
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
                alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);

            fUNQ59(true, mapId);
        },
        error:function(data, status, result){

            if(data.errorMessage) {
                alert(data.errorMessage);
            }

            //     $("#resultDiv").html(result);
            fUNQ59(false);
        }
    });

}


function fUNQ59(success, mapId) {

    var mapSaveStatus     = $('#mapSaveStatus')    ;
    var  mapUrl = $('#mapUrl');


    mapSaveStatus.show();

    if(success ) {

        var saveStatusMsg = "";

        if( savedMapId == null)
        {
            savedMapId = mapId;
        }
        else  {
            saveStatusMsg = "re-";
        }

        fUNQ60(mapSaveStatus, '<h5>Your map was successfully '+ saveStatusMsg + 'saved.</h5>', "success" )    ;


        if(mapId != null && mapUrl.length > 0) {

            userSettings.name = mapId.toString();

            var baseMapUrl = location.protocol + "//" + location.hostname + "/map/";
            var mapFullUrl =   location.protocol + "//" + location.hostname + "/map/"  + mapId.toString();
            mapUrl.html('<pre><p style="margin-bottom: 0px;">The map url is </p><a href="'+ mapFullUrl + '" target="_blank">' + mapFullUrl + '</a></pre>' );

          // new code:
           var str = ' <pre><p style="margin-bottom: 0px;">The map url is </p>' +
              '  <a id="genMapUrl" href="'  + mapFullUrl+ '" target="_blank">' + baseMapUrl + '<span  id="editable-url">' + mapId.toString() +
               '</span></a><span  id="mod-url" style="display: none;"></span> <a onclick="fUNQ130(); return false;"  id="editable_url_btn" class="btn btn-mini btn-primary" href="#">Edit</a>' +
               '<span id="edit-slug-buttons" style="display: none;"><a onclick="fUNQ131(); return false;"  class="btn btn-mini btn-primary" href="#">Save</a> ' +
               '<a onclick="fUNQ132(); return false;" style=" white-space: nowrap; font-size: 11px; margin-right: 10px;" href="#">Cancel</a></span>' +
               '<span id="aliasStatusDiv" style="margin-left: 5px; margin-bottom: 0; padding: 4px; white-space: nowrap;"></span>' +
               '<span id="aliasInstDiv" style="display: none;"><p>Valid characters are numbers, letters, underscores (_) and dashes (-).</p></span></pre>';

            mapUrl.html(str);
        }

        if( typeof EditingMap == 'undefined')
        {
            mapUrl.show();

            $('#mapModalButton').hide();


        }

    }
    else {
        $("#mapModalButton").button('reset') ;
        fUNQ60(mapSaveStatus, '<h5>There was a problem saving the map.</h5>', "error" )    ;
        //    mapSaveStatus.addClass("alert-error");
        //  mapSaveStatus.html('<h5>There was a problem saving the map.</h5>');
    }

}


function fUNQ60(div, message, status)  {

    div.html( message );


    if(!div.hasClass("alert"))
    {
        div.addClass("alert");
    }


    if(status == "error") {

        if(!div.hasClass("alert-error"))
        {
            div.addClass("alert-error");
        }

        if(div.hasClass("alert-success"))
        {
            div.removeClass("alert-success")  ;
        }
    }
    else {
        if(div.hasClass("alert-error"))
        {
            div.removeClass("alert-error");
        }

        if(!div.hasClass("alert-success"))
        {
            div.addClass("alert-success")  ;
        }

    }


}




function fUNQ61(editPage) {

    userSettings.email =  $('#emailInput').val();
    userSettings.title = $('#titleInput').val();
    userSettings.description =  $('#descriptionInput').val();
    userSettings.protectionLevel =  $('input[name=protectionLevel]:checked').val();

    var genKmlInput = $('#genKmlCB');

    if(genKmlInput.length > 0 )
        userSettings.genKML    =    $('#genKmlCB').is(':checked');

    //  userSettings.key = $('#securityKey').val();


    userSettings.autoDelete = true;
    userSettings.dataOnPage = true;

    if(editPage != null && editPage) {
        userSettings.autoDelete = ($('input[name=mapDelete]:checked').val() == "true");


        if( $('input[name=mapLayout]:checked').val() == "mapOnly")
            userSettings.dataOnPage = false;
    }

    return !(userSettings.email.length > 0 && !fUNQ30(userSettings.email))  ;
  //   return false;

   // return true;

}

function fUNQ62() {

    if( removedMarkers.length > 0 ) {

        fUNQ63 ();

        // should regenerate the groups and filters!
        fUNQ50(dataLines, mObject.group, MAX_GROUPS);

        // maybe this should be called by the map instead of here
        if(mObject.sortedGroupKeys.length > 1) {
            fUNQ46(dataLines.length  );
        }

        fUNQ35(mObject.filterColumnIdxs, mObject.columnHeaderArray, dataLines);

    }

}

function fUNQ63() {
    var i;
    for( i = removedMarkers.length - 1; i >= 0; i--)
    {
        dataLines.splice(removedMarkers[i], 1);
        gMapMarkers.splice(removedMarkers[i], 1);
    }

    // reset the marker idx'es
    for( i = 0; i < gMapMarkers.length; i++)
        gMapMarkers[i].idx = i;

}


function fUNQ64() {

    fUNQ62();

    var str = fUNQ54();
    var config = JSON.stringify(mObject)     ;
    var mDetails = JSON.stringify(userSettings);

    var oldMapId = "";

    if(savedMapId   != null)
        oldMapId =     savedMapId;

    /*  $.ajax({url:"/php/saveData.php",success:function(result){
     $("#resultDiv").html(result);
     }});
     */
    $.ajax({
        type: 'POST',
        url: '/savedata',
        data: ({ usercontent: str, configContent: config, mapDetails: mDetails, mapType: mObject.mapType, existingId: oldMapId }),
        cache: false,
        dataType: 'json',
        success:function(data, status, result){

            if(data.errorMessage) {
          //      alert(data.errorMessage);
            }

       //     $("#resultDiv").html(result);

            if(userSettings.genKML != null && userSettings.genKML == true)  {

                fUNQ58(data.uid);
            }
            else {
                fUNQ59(true, data.uid);
            }


        },
        error:function(data, status, result){

            if(data.errorMessage) {
            //    alert(data.errorMessage);
            }

            fUNQ59(false);

       //     $("#resultDiv").html(result);
        }
    });


}


function fUNQ65(possibleFunction) {
    return (typeof(possibleFunction) == typeof(Function));
}


// returns true if one items is in the other array
function fUNQ66(a1, a2) {

    for (var item in a1) {
        if (fUNQ67(a1[item], a2)) {
            return true;
        }
    }
    return false;
}

function fUNQ67(item, a1) {

    return (a1.indexOf(item) >= 0);
}

function fUNQ68(a1, a2) {

    var result =[];

    for (var i = 0; i < a1.length; i++) {
        if (a2.indexOf(a1[i]) !== -1) {
            result.push(a1[i]);
        }
    }

    return result;
}
// holds marker idx tha have been removed during the edit process
var removedMarkers = [];

var gMapMarkers = [];

var gMap = null;

var openMarker = null;
var openWindow = null;
//var directionInfoW = null;

var ignorePagingEvent = false;

// markers at the same position as others for info window
var samePosMarkers = [];

// holds the indexes of groups not to be displayed
var groupsOff = [];

// the markers to display either for a search, grouping, or the filters.
var selectedMarkers = [];
var selectedMarkerSet =false;

var markerCluster = null;

// corresponding google map options:
var googleMapOptions = [] ;
//var markerNumbers = [1, 2, 3, 4, 5, 6, 7,8, 9];

// teh number of items that can be displayed below the map
var DISPLAYABLE_ITEMS_PER_PAGE = 50;

var CLUSTER_ZOOM_LEVEL = 12;

// used for marker paging
var ITEMS_PER_PAGE = 5;
var currentPageMarkerNum = 1;
var nextPageMarkerNum = 1 + ITEMS_PER_PAGE;
var previousPageMarkerNum = 1;

// key is the search term, value is an array of indexes that match this (the array corresponds to the markers.
var searchTermHash = {};

var mobileDevice = false;
var tabletDevice = false;
var inIframe = false;
var showDirections = true;

var directionsService = null;
var directionsDisplay = null;

// only fill this in if displayDataOnPage is true
var markerDescriptions = [];


var showMoreOptions = false;

var mapGeocoder = null;

// Used with the nearby filter
var circle = null;
var circleFilter = false;
var showDistance = false;
var circleRadius = 0;

// number of the active dir text box, must be greater than 1 for one of them to be active (1 or 2 currently)
var activeDirTextBox = 0;

function initMap(mapDiv, mapTypeIdx) {

    if(mObject.showLabels == null)
        mObject.showLabels = true;

    if(mObject.showMoreOptions != null && mObject.showMoreOptions)
        showMoreOptions = true;

    if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))
        || (  (navigator.userAgent.match(/mobile/i))  &&  (navigator.userAgent.match(/Android/i))  ) ||
        (navigator.userAgent.match(/blackberry/i)) || (navigator.userAgent.match(/windows phone/i))   ) {
        mobileDevice = true;
    }
    if( !mobileDevice &&   ((navigator.userAgent.match(/Android/i))  ||  (navigator.userAgent.match(/iPad/i))  )  )  {
        tabletDevice = true;
    }

    if (window.location != window.parent.location)
    {
        inIframe = true;

        $('body').html( fUNQ141() );
    }
    else {
    }

    //if(true) {
    if(!inIframe && tabletDevice && showMoreOptions) {
        $('#left').html( fUNQ140()  );

    }


    googleMapOptions = [google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.TERRAIN, google.maps.MapTypeId.SATELLITE,
        google.maps.MapTypeId.HYBRID];

    var mapType =      googleMapOptions[mapTypeIdx];

    if(gMap != null)
        return;

    var sWheel = false;

    if(mObject.scrollWheel != null && mObject.scrollWheel == true)
        sWheel = true;

    var gMapOptions = {
        zoom: 4,
        center: new google.maps.LatLng(39.8282, -98.5795),     // center of us.
        mapTypeControl: false,
        scaleControl: true,
        scrollwheel: sWheel,
        minZoom: 1,
        panControlOptions : {
            position: google.maps.ControlPosition.LEFT_TOP
        },
        zoomControlOptions : {
            position: google.maps.ControlPosition.LEFT_TOP
        }
    };

    gMap = new google.maps.Map(document.getElementById('map'), gMapOptions);

    gMap.setMapTypeId(mapType);

//gMap.setMapTypeId(google.maps.MapTypeId.ROADMAP);

    // TODO: only do this is the user set it as well!
    // only add this for pc and tablets
    if (!mobileDevice && showMoreOptions) {
        var moreOptionsControl = document.createElement('div');
        moreOptionsControl.innerHTML = '<img id="moreOptionsBlank" src="/img/more_options_blank.png" style="display: none;"><img id="moreOptions" src="/img/more_options.png" onclick="fUNQ134()">';
        moreOptionsControl.index = 1;
        gMap.controls[google.maps.ControlPosition.TOP_LEFT].push(moreOptionsControl);
    }

    var homeControlDiv = document.createElement('div');
    fUNQ144(homeControlDiv, gMap, myMapOptions, mapType, googleMapOptions);

    homeControlDiv.index = 1;
    gMap.controls[google.maps.ControlPosition.TOP_RIGHT].push(homeControlDiv);


    /*            var point = new google.maps.LatLng(35.177648,-84.863288);
     var marker = new google.maps.Marker({        position: point,        map: gMap     });
     marker.setTitle('CPE 517178');
     */
    /* directionInfoW = new google.maps.InfoWindow({
     //  content: message,
     size: new google.maps.Size(50, 50)
     });
     */


    google.maps.event.addListener(gMap, 'click', function() {
        if(openWindow != null )
            openWindow.close();
        //   if(directionInfoW != null)
        //     directionInfoW.close();
    });

    addMarkers(mObject.lat, mObject.lng,   dataLines);

    fUNQ163();

    // don't show filters on mobile devices for now
    if(!mobileDevice) {
        fUNQ42();
        fUNQ189();

        if( !inIframe && mObject.displayDataOnPage && !tabletDevice )      {
            // TODO: this is only here as a test
            fUNQ180();
        }

        if(inIframe) {

            var mapHeaderDir = $('#mapHeader');

            $('#map').css('top', mapHeaderDir.outerHeight());


            if(showMoreOptions) {
                $('#left').css('top', mapHeaderDir.outerHeight());
            }

            var descDiv  = $('#descriptionDiv');
            var descHeight = 0;

            if(descDiv.length > 0) {
                descHeight += descDiv.outerHeight();
            }

            var groupsCheckDiv = $('#groupChecksDiv');
            if(groupsCheckDiv.length > 0 && groupsCheckDiv.is(':visible')) {

                // for some strange reason, adding 6 pixels seems to help since the bottom can get chopped off otherwise
                $('#map').css('bottom', groupsCheckDiv.outerHeight() + descHeight );

                if(showMoreOptions) {
                    $('#left').css('bottom', groupsCheckDiv.outerHeight() + descHeight + 6);
                }

                if(descHeight > 0) {
                    groupsCheckDiv.css('bottom', descHeight);
                }

            }
            else if (descHeight > 0) {

                $('#map').css('bottom',  descHeight);

                if(showMoreOptions) {
                    $('#left').css('bottom',  descHeight );
                }
            }

            if(showMoreOptions && inIframe) {
                $('#dirTextDiv').css('height', $('#map').outerHeight() - 137);


            }

        }

        // if(true) {
        if(showMoreOptions && !inIframe && tabletDevice) {

            var topTemp = 0;

            if( $('#mapHeader').length > 0)
                topTemp =  $('#mapHeader').outerHeight();

            $('#dirTextDiv').css('height', 250 - topTemp);
            $('#left').css('height', 400 - topTemp);

        }


    }

    if(dataLines.length >=  500 && !mObject.clustering) {
        google.maps.event.addListener(gMap, 'idle', showMarkers);
    }


    if(showMoreOptions) {
        fUNQ133();
    }

}


// TODO: move this code somewhere else
function fUNQ133() {

    if($("#mapWindowData").length == 0) {

        var displayDistance = $('#displayDistance');
        if(displayDistance.length > 0)
            displayDistance.hide();
    }

    $('#dirTabDisplay').click(function() {
        fUNQ135();
//        $('#leftDirDisplay').show();
//        $('#leftNearbyDisplay').hide();
//
//        var dirTab = $('#dirTabDisplay');
//        if(!dirTab.hasClass("activeDirHeader"))
//        {
//            dirTab.addClass("activeDirHeader");
//        }
//
//        $('#nearbyTabDisplay').removeClass("activeDirHeader");

    });


    $('#clearDirSubmit').click(function() {


        $('#dirAddress1').val("");
        $('#dirAddress2').val("");
        $('#dirError').hide();
        activeDirTextBox = 0;

        if(directionsDisplay != null) {
            directionsDisplay.setPanel(null);
            directionsDisplay.setMap(null);
        }

    });

    $('#directionSubmit').click(function() {

        var dirErrorDiv = $('#dirError');

        var addr1 = $('#dirAddress1').val();
        var addr2 = $('#dirAddress2').val();
        dirErrorDiv.hide();

        if(addr1.trim().length == 0 ){
            dirErrorDiv.show();
            dirErrorDiv.html("invalid start address");
            return;
        }
        else if(addr2.trim().length == 0) {
            dirErrorDiv.show();
            dirErrorDiv.html("invalid end address");
            return;
        }



        fUNQ138(addr1, addr2);
    });

    // hide options
    $('#hideOptions').click(function() {
        var moreOptionsBlank = $('#moreOptionsBlank');
        $('#left').hide();
        $('#moreOptions').show();
        moreOptionsBlank.hide();



        if(inIframe || tabletDevice) {

            $('#map').css('left', 0);

        }
        else {
            var div = $('#mapContainer');

            if(div.hasClass("padLeft"))
            {
                div.removeClass("padLeft");
            }
        }

        google.maps.event.trigger(gMap, 'resize');

        activeDirTextBox  = 0;
    });

    // show options:




    $('#nearbyTabDisplay').click(function() {

        $('#leftDirDisplay').hide();
        $('#leftNearbyDisplay').show();
        activeDirTextBox = 0;


        var dirTab = $('#nearbyTabDisplay');
        if(!dirTab.hasClass("activeDirHeader"))
        {
            dirTab.addClass("activeDirHeader");
        }

        $('#dirTabDisplay').removeClass("activeDirHeader");

    });

    $('#clearNearbySubmit').click(function() {

        $('#nearAddress').val("");
        $('#nearRadius').val("");
        $('#nearbyError').hide();

        if(circle != null) {
            circle.setMap(null);

        }

        if(circleFilter) {
            showDistance = false;
            circleFilter = false;
            fUNQ164();
        }
    });

    $('#nearbySubmit').click(function() {

        // circleFilter = false;
        var message = "";
        var radius = $('#nearRadius').val();
        var units = $('input[name=distType]:checked').val();
        var showCircle  = $('#showCircle').is(':checked');
         showDistance = $('#showDistance').is(':checked');
        var location = $('#nearAddress').val();
        var displayUnits = "KM";

        var nearByError = $('#nearbyError');

        if(!$.isNumeric(radius) || radius <= 0)
        {
             message = "Invalid radius: " + radius;
            nearByError.html(message);
            nearByError.show();
            return;
        }

        if(location.trim().length == 0) {
             message = "Error: Blank location.";
            nearByError.html(message);
            nearByError.show();
            return;
        }

        if(units == "mi") {
            radius *= 1.6093;
            displayUnits = "miles";

        }
        // get the radius in meters
        radius *= 1000;



        if(mapGeocoder == null)
            mapGeocoder = new google.maps.Geocoder();

        var geoSuccess = true;

        mapGeocoder.geocode({
            'address': location
        }, function (results, status) {


            if(status == google.maps.GeocoderStatus.OK) {

                var circleCenter = results[0].geometry.location;
                gMap.setCenter(results[0].geometry.location);

                if(circle != null) {
                    circle.setMap(null);
                }

                circle = new google.maps.Circle({
                    clickable: false,
                    draggable : false,
                    editable : false,
                    fillColor : "blue",
                    fillOpacity : 0.2,
                    strokeColor : "blue",
                    strokeOpacity : 0.4,
                    radius: radius,  // distance in meters
                    map: gMap,
                    center:  circleCenter,
                    visible: showCircle
                });


                gMap.fitBounds(circle.getBounds());

                circleFilter = true;
                circleRadius = radius;

                for(var i = 0; i < gMapMarkers.length; i++) {

                    if(gMapMarkers[i] != null) {

                        if(circle.getBounds().contains(gMapMarkers[i].getPosition()) ) {

                            gMapMarkers[i].distanceM = google.maps.geometry.spherical.computeDistanceBetween(circleCenter, gMapMarkers[i].getPosition());

                            if(showDistance) {

                                if(units == "mi")
                                    gMapMarkers[i].displayDistance = gMapMarkers[i].distanceM * .00062137;
                                else
                                    gMapMarkers[i].displayDistance = gMapMarkers[i].distanceM * .001;


                                // fix the decimal display : 3 decimals for less than 1, 2 for up to 100, and 0 otherwise
                                if(  gMapMarkers[i].displayDistance < 1)
                                {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed(3);
                                }
                                else if(gMapMarkers[i].displayDistance < 100) {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed(2);
                                }
                                else {
                                    gMapMarkers[i].displayDistance =  gMapMarkers[i].displayDistance.toFixed();
                                }

                                gMapMarkers[i].displayDistance += " " + displayUnits;

                            }

                        }

                    }

                }

                fUNQ164();

            }
            else {
                geoSuccess = false;
            }

        });



        if(geoSuccess)
            nearByError.hide();
        else {
            nearByError.html("Problem find the location: " + location);
            nearByError.show();
        }




    });


    $('#dirAddress1').click(function() {
        activeDirTextBox = 1;
    });

    $('#dirAddress2').click(function() {
        activeDirTextBox = 2;
    });


}

function fUNQ134() {
    $('#left').show();
    $('#moreOptionsBlank').show();
    $('#moreOptions').hide();


    if(inIframe || tabletDevice) {

        $('#map').css('left', 300);

    }

    else {
        var div = $('#mapContainer');

        if(!div.hasClass("padLeft"))
        {
            div.addClass("padLeft");
        }
    }
    google.maps.event.trigger(gMap, 'resize');

}


function fUNQ135() {


    $('#leftDirDisplay').show();
    $('#leftNearbyDisplay').hide();

    var dirTab = $('#dirTabDisplay');
    if(!dirTab.hasClass("activeDirHeader"))
    {
        dirTab.addClass("activeDirHeader");
    }

    $('#nearbyTabDisplay').removeClass("activeDirHeader");
}

function fUNQ136(markerM) {

    fUNQ134();
    fUNQ135();


    activeDirTextBox = 1;
    fUNQ137(markerM);


    activeDirTextBox = 2;
    $('#dirAddress2').val("");

}

function fUNQ137(markerM) {

    if(showMoreOptions && activeDirTextBox > 0 && $('#dirTabDisplay').is(':visible')) {

        var startLocation = "Marker " + markerM.idx + 1;
        var markerAddr = fUNQ162(dataLines[markerM.idx], " ", true);

        if(markerAddr.length > 0)
            startLocation = markerAddr;
        else if (fUNQ178(mObject.title) && dataLines[markerM.idx][mObject.title] != "")
        {
            startLocation =  dataLines[markerM.idx][mObject.title];
        }

        $('#dirAddress' + activeDirTextBox).val(startLocation);

    }


}


function fUNQ138(start, end) {

    if( directionsService == null )
        directionsService = new google.maps.DirectionsService();

    if( directionsDisplay == null )           {
        directionsDisplay = new google.maps.DirectionsRenderer({suppressMarkers: true, suppressInfoWindows: true});
        directionsDisplay.setMap(gMap);

    }

    if(start && end) {

        var request = {
            origin:start,
            destination:end,
            travelMode: google.maps.TravelMode.DRIVING
        };

        directionsService.route(request, function(result, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setMap(gMap);
                directionsDisplay.setPanel(document.getElementById('dirTextDiv'));
                directionsDisplay.setDirections(result);
            }
            else {
               // ignorePagingEvent = true;
                var dirError =  $('#dirError');
                dirError.html('Could not get directions: ' + status);
                dirError.show();
            }
        });

    }

}

function fUNQ139(resultArr, status) {


}

function fUNQ140() {

    // This is the same as the show more options html with the "left" div removed!
    return             '   <div id="left_header" class="dirHeader"> ' +
        '       <a id="dirTabDisplay" style="margin-left: 5px;" class="activeDirHeader">Directions</a> ' +
        '       <a id="nearbyTabDisplay">Nearby</a> ' +
        '       <img id="hideOptions" src="/img/hide_options.png" style="float: right; margin-right: 10px;  cursor: pointer;"> ' +
        '   </div> ' +
        '   <div id="leftDirDisplay" class="leftDiv" style="background-color: white;"> ' +
        '       <p> <label id="dirAddress1_label" for="dirAddress1" class="optionLabel">Start: </label><input id="dirAddress1"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '       <p> <label id="dirAddress2_label" for="dirAddress2" class="optionLabel">End: </label> <input id="dirAddress2"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '     <!--  <p><a href="#">add location</a></p> --> ' +

        '       <p style="text-align: right; margin-right: 50px;"><INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /> ' +
        '       <INPUT id="clearDirSubmit" value="Clear" TYPE="SUBMIT" /> </p>  ' +
        '       <div id="dirError" style="display: none; "></div>  ' +
        '       <div id="dirTextDiv" style="padding: 10px; height: 445px; overflow: auto;"></div>  ' +

        '   </div>  ' +
        '   <div id="leftNearbyDisplay" class="leftDiv" style="display: none;">  ' +
        '       <p><label id="nearAddress_label" for="nearAddress" class="optionLabel">Location: </label><input id="nearAddress"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
        '       <p> <label id="nearRadius_label" for="nearRadius" class="optionLabel">Radius: </label><input id="nearRadius"  type="text"  SIZE=3 MAXLENGTH=3 style="text-align: right;" autocomplete="off"> ' +
        '           <label class="radio" style=" text-align: left;"><input type="radio" name="distType" value="mi" id="distMi" checked  autocomplete="off">miles  </label> ' +
        '           <label class="radio" style="width: 400px;  text-align: left;"><input type="radio" name="distType" value="km"  id="distKM" > km </label></p> ' +
        '       <p><label class="checkboxText"><input type="checkbox" name="showCircle" value="false"  id="showCircle"   class="checkLabel" >show circle</label></p> ' +
        //      '      <p><label  class="checkboxText" ><input type="checkbox" name="showDistance" value="false"  id="showDistance""  class="checkLabel"><span class="checkboxText">show distance</span></label></p> ' +

        '       <p style="text-align: right; margin-right: 50px;"><INPUT id="nearbySubmit" value="Find Nearby" TYPE="SUBMIT" /> ' +
        '          <INPUT id="clearNearbySubmit" value="Clear" TYPE="SUBMIT" /> </p> ' +
        '      <div id="nearbyError" style="display: none; "></div> ' +
        '  </div> ' ;

}

function fUNQ141() {

    var descriptionDiv = "";

    if(userSettings.description != null && userSettings.description.length > 0) {
        descriptionDiv += '<div id="descriptionDiv"  style="position:fixed;left:0;right:0; bottom:0px; font-size: .8em;"> ' +  userSettings.description + '</div>'
    }

    var showOptionsHtml = "";

    if(showMoreOptions) {
        showOptionsHtml =                 '<div id="left" class="column" style="background-color: white; width: 300px; display: none; margin-left: 0; "> ' +
            '   <div id="left_header" class="dirHeader"> ' +
            '       <a id="dirTabDisplay" style="margin-left: 5px;" class="activeDirHeader">Directions</a> ' +
            '       <a id="nearbyTabDisplay">Nearby</a> ' +
            '       <img id="hideOptions" src="/img/hide_options.png" style="float: right; margin-right: 10px;  cursor: pointer;"> ' +
            '   </div> ' +
            '   <div id="leftDirDisplay" class="leftDiv" style="background-color: white;"> ' +
            '       <p> <label id="dirAddress1_label" for="dirAddress1" class="optionLabel">Start: </label><input id="dirAddress1"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '       <p> <label id="dirAddress2_label" for="dirAddress2" class="optionLabel">End: </label> <input id="dirAddress2"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '     <!--  <p><a href="#">add location</a></p> --> ' +

            '       <p style="text-align: right; margin-right: 50px;"><INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /> ' +
            '       <INPUT id="clearDirSubmit" value="Clear" TYPE="SUBMIT" /> </p>  ' +
            '       <div id="dirError" style="display: none; "></div>  ' +
            '       <div id="dirTextDiv" style="padding: 10px; height: 445px; overflow: auto;"></div>  ' +

            '   </div>  ' +
            '   <div id="leftNearbyDisplay" class="leftDiv" style="display: none;">  ' +
            '       <p><label id="nearAddress_label" for="nearAddress" class="optionLabel">Location: </label><input id="nearAddress"  type="text"  SIZE=20 MAXLENGTH=200 ></p> ' +
            '       <p> <label id="nearRadius_label" for="nearRadius" class="optionLabel">Radius: </label><input id="nearRadius"  type="text"  SIZE=3 MAXLENGTH=3 style="text-align: right;" autocomplete="off"> ' +
            '           <label class="radio" style=" text-align: left;"><input type="radio" name="distType" value="mi" id="distMi" checked  autocomplete="off">miles  </label> ' +
        '           <label class="radio" style="width: 400px;  text-align: left;"><input type="radio" name="distType" value="km"  id="distKM" > km </label></p> ' +
        '       <p><label class="checkboxText"><input type="checkbox" name="showCircle" value="false"  id="showCircle"   class="checkLabel" >show circle</label></p> ' +
  //      '      <p><label  class="checkboxText" ><input type="checkbox" name="showDistance" value="false"  id="showDistance""  class="checkLabel"><span class="checkboxText">show distance</span></label></p> ' +

            '       <p style="text-align: right; margin-right: 50px;"><INPUT id="nearbySubmit" value="Find Nearby" TYPE="SUBMIT" /> ' +
            '          <INPUT id="clearNearbySubmit" value="Clear" TYPE="SUBMIT" /> </p> ' +
            '      <div id="nearbyError" style="display: none; "></div> ' +
            '  </div> ' +

        ' </div> ';

    }


   return '<div id="mapHeader" style="left:0;right:0; z-index:100; top:0px; position: fixed; min-height: 45px;"> ' +
       ' <div id="searchDiv" class="search-query"> ' +
       '      <input id="searchBox" class="search-query span2" type="text" placeholder="Search"  onkeypress="return handleSearchSubmit(event)" value=""><img class="search-query" src="/img/search.png" onclick="fUNQ190();"> ' +
       '     <a href="http://www.easymapmaker.com" target="_blank"><img class="search-query" src="/img/small_logo2.png" Title="Map made with EasyMapMaker.com" onclick="fUNQ190();"></a> ' +

       ' </div> ' +

       ' <div id="filtersDiv" ></div> ' +

       '</div> ' +

       '<div id="mapContainer" style="position:absolute;left:0;right:0; top:0px;bottom:0px;"> ' +
       '    <div id="map" ' +
       '        style="position:absolute;left:0;right:0; top:0px;bottom:0px;"></div> ' +
       showOptionsHtml +
       '   <div id="groupsOverDiv" style="  text-align: center;     width: 100%; -webkit-text-size-adjust: none;"> ' +
       '       <div id="groupChecksDiv" class="groupsDivPC" style="left:0;right:0; z-index:100; bottom:0px; position: fixed; display: inline-block;"> ' +

       '        </div> ' +
       '   </div> ' + descriptionDiv +



       '</div> ' ;


}


// should probably only do this for more than 100 markers.
function fUNQ142() {


    if(gMapMarkers.length < 500)
        return;


    var bounds = gMap.getBounds();

    // Call you server with ajax passing it the bounds

    // In the ajax callback delete the current markers and add new markers

    //
    // make this work for grouping/clusting by keeping an index of the visible markers and have a boolean
    // indicating whether all the markers are visible


    var i;

  //  if(mObject.clustering)
   //     markerCluster.clearMarkers();

    // TODO: also, do the paging thing for this as well

    if(selectedMarkers.length > 0 || selectedMarkerSet) {


        for( i = 0; i < selectedMarkers.length; i++) {

            if(selectedMarkers[i] < gMapMarkers.length) {

                if(gMapMarkers[selectedMarkers[i]] == null )
                    continue;

                if(  bounds.contains(gMapMarkers[selectedMarkers[i]].getPosition() && gMapMarkers[selectedMarkers[i]].getMap() == null ))       {

                        gMapMarkers[selectedMarkers[i]].setMap(gMap);

                }
                else if(  gMapMarkers[selectedMarkers[i]].getMap() != null){
                    gMapMarkers[selectedMarkers[i]].setMap(null);

                  //  if(mObject.clustering)
                  //      hideClusterMarkers.push(gMapMarkers[selectedMarkers[i]]);
                }
            }

        }


    }
    else {

        for( i = 0; i < gMapMarkers.length; i++) {


            if(gMapMarkers[i] == null )
                continue;

            if(  bounds.contains(gMapMarkers[i].getPosition()) && gMapMarkers[i].getMap() == null)   {

                    gMapMarkers[i].setMap(gMap);
            }
            else if ( gMapMarkers[i].getMap() != null ){

                // TODO: verify what this is supposed to do, probably something with the open window
                if(openWindow != null && openMarker.idx == i)
                    continue;

                gMapMarkers[i].setMap(null);

            }
        }


    }


}

// TODO: zoom into the markers that are visible on a search change, filter change or group change
// This assumes that the markers that don't match the result are already hidden!
function fUNQ143(markerList) {

    var preZoom = gMap.getZoom();


    var latLngBounds = null;

    var extendedBoundsCount = 0;

    var showClusterMarkers = [];

    if(openWindow != null      )
    {
        openWindow.close();
        openWindow = null;
        openMarker = null;
    }

    if(mObject.clustering) {

        markerCluster.clearMarkers();
    }

    // no markers, so leave the zoom level as is and
    // clear other stuff from the page.
    if(markerList.length==0)       {

//        if(mObject.clustering) {
//
//            clusterer.clearMarkers();
//        }

        fUNQ179();

        return;
    }


    for(var i = 0; i < markerList.length; i++) {

        var idx = markerList[i];

        if(idx < gMapMarkers.length) {

            if(gMapMarkers[idx] == null )  {
                continue;
            }


             if(latLngBounds == null){

                 latLngBounds = new google.maps.LatLngBounds(gMapMarkers[idx].getPosition(), gMapMarkers[idx].getPosition());
             }
            else {

                 latLngBounds.extend(gMapMarkers[idx].getPosition());
                 extendedBoundsCount++;
             }

            if(mObject.clustering) {
                showClusterMarkers.push(gMapMarkers[idx])  ;
            }

        }

    }


    // don't adjust the map when there is a circle filter, let the user change the map if they want
    // only change it if there is 1 item (as in the code below)
    if(!circleFilter) {

        gMap.fitBounds(latLngBounds);

        gMap.setCenter(latLngBounds.getCenter());
    }



    //    (17 looks like a good level!)
    if(extendedBoundsCount == 0 ) {

        // without this, the map would zoom to 21 (right on a building, yikes).

        if(preZoom < 17)
         gMap.setZoom(17);
        else {
            gMap.setZoom(preZoom );
        }
    }



    if(mObject.clustering) {

     //   markerCluster.clearMarkers();
        markerCluster.addMarkers(showClusterMarkers);
    }


    fUNQ180();
}

function fUNQ144(controlDiv, map, optionsArray, selectedOption, googleOptionType) {

    controlDiv.style.padding = '5px';

    var controlUI = document.createElement('div');
    controlUI.align = 'center';

    controlDiv.appendChild(controlUI);


    // Set CSS for the control interior.
    var controlSelect = document.createElement('select');
    controlSelect.name = 'MapStyle';
    controlSelect.id = 'MapStyle';
    controlUI.appendChild(controlSelect);

    for (var i = 0; i < optionsArray.length; i++) {

        var controlOption = document.createElement('option');
        controlOption.value = optionsArray[i];
        controlOption.innerHTML = optionsArray[i];

        if (selectedOption.toLowerCase() == optionsArray[i].toLowerCase()) {
            controlOption.selected = 'selected';
        }

        controlSelect.appendChild(controlOption);

    }

    // Setup the click event listeners: simply set the map to Chicago.
    google.maps.event.addDomListener(controlSelect, 'change', function () {

        for (var i = 0; i < optionsArray.length; i++) {
            if (this.value == optionsArray[i]) {
                map.setMapTypeId(googleOptionType[i]);
            }
        }


    });


}


function addMarkers(latIdx, lngIdx,  dataLines) {

  if(dataLines.length == 0)
    return;

  //var clustering = true;

  var latLng = new google.maps.LatLng(dataLines[0][latIdx],dataLines[0][lngIdx]);

  var latLngBounds =  new google.maps.LatLngBounds(latLng, latLng);


  for(var i = 0; i < dataLines.length; i++) {

     latLng = new google.maps.LatLng(dataLines[i][latIdx],dataLines[i][lngIdx]);

        var color = IMG_LIST[0];
        var hexColor = IMG_HEX_COLORS[0];

        var iconUrl =  '/marker_images/image.png';

        if(mObject.markerImageIdx != undefined  && mObject.markerImageIdx.length >= i &&
            mObject.markerImageIdx[i] >=0 &&  mObject.markerImageIdx[i] != null) {

            if( mObject.markerImageIdx.length > 0  && mObject.markerImageIdx[i] < IMG_LIST.length)            {

                iconUrl =       IMAGE_PATH + IMG_LIST[mObject.markerImageIdx[i]] + IMG_FILE_ENDING;
                //  marker.setIcon( IMAGE_PATH + IMG_LIST[mObject.markerImageIdx[i]] + IMG_FILE_ENDING );
              color =  IMG_LIST[mObject.markerImageIdx[i]];
                hexColor =   IMG_HEX_COLORS[mObject.markerImageIdx[i]];
            }
            // otherwise, use the default icon

            // marker.setIcon( IMAGE_PATH + IMG_LIST[i] + IMG_FILE_ENDING );

        }

        var image = {
           url: iconUrl,
            size: new google.maps.Size(20,34),
            origin: new google.maps.Point(0,0),
            anchor: new google.maps.Point(10,34)
        };

        var shadow = {
            url: '/marker_images/shadow.png',
            size: new google.maps.Size(40,34),
            origin: new google.maps.Point(0,0),
            anchor: new google.maps.Point(10,34)
        };


    var marker = new google.maps.Marker({  position:  latLng,
                                map: gMap ,
                        icon: image,
                        shadow: shadow,
                        shape: DEFAULT_SHAPE,
                        zIndex: dataLines.length - i    });


        // TODO: tooltip for title, see http://googlemapapitutorial.com/customizedtooltip.jsp
      /*  if(fUNQ178(mObject.title))
        {
            marker.setTitle(dataLines[i][mObject.title]);
        }
        */
    
    latLngBounds.extend(latLng);

    marker.idx = i;
        marker.color = color;
        marker.hexColor = hexColor;


    if(editMap) {
      marker.setDraggable(true);    
    }

    fUNQ145(marker, i, dataLines[i]);

    gMapMarkers.push(marker);

    if(editMap) {
      google.maps.event.addListener(marker, "dragend", function() {
        fUNQ160(this, latIdx, lngIdx);  

      } );
    }
  }

    // TODO: in the future, use some calculation for the grid size and zoom level based on marker density
    if(mObject.clustering)   {
        markerCluster = new MarkerClusterer(gMap, gMapMarkers,
         {
             calculator:  myCalculator,
             maxZoom: CLUSTER_ZOOM_LEVEL,
             averageCenter: true,
             gridSize: 65
         }
     );
    }

  gMap.fitBounds(latLngBounds);

  gMap.setCenter(latLngBounds.getCenter());

}



function fUNQ145(markerM, markerIdx, dataItems) {
    "use strict";
    var message = fUNQ158( dataItems);


    if(mObject.displayDataOnPage && !mobileDevice && !inIframe && !tabletDevice)  {

        var simpleMessage = fUNQ157(dataItems);

        markerDescriptions[markerDescriptions.length] = {message: simpleMessage, markerIdx: markerIdx};
    }

// TODO: look at adjusting the top on parent div to 26 pixels (should look at other browsers for this as well!)
    message = '<div id="markerDiv" class ="markerDescriptionReg">' + message ;

  if(mobileDevice) {

      message = '<div id="markerDiv" style="overflow-y:scroll; font-size:10pt; top: 26px; font-family:arial; font-weight:bold;">' + message ;

  }


// old width: width: 450px;

    if(editMap) {

        message = message + '<a id="removeMarker">Remove Pin</a> ' ;
    }

    message = message + '</div>';

    var infowindow = new google.maps.InfoWindow({
        content: message,
        size: new google.maps.Size(50, 50)  
    });

    // openWindow.setContent(message);

  if(mobileDevice) {
//    infowindow.setOptions({maxWidth : 150 });
  }
    else {

      //  infowindow.setOptions({maxWidth : 400 });
    }


    google.maps.event.addListener(markerM, "click", function () {



        if (openWindow != null && openWindow != infowindow) {
            openWindow.close();
        }

        if(mObject.clustering && markerM.getMap() !== gMap )
        {
            gMap.setZoom(15);
            markerCluster.repaint();
        }

        samePosMarkers.length = 0;
        for(var i = 0; i < dataLines.length && i < gMapMarkers.length ; i++ ) {

            if( gMapMarkers[i] == null)
                continue;

            if(i != markerM.idx && dataLines[i].length  && gMapMarkers[i].idx >= 0 &&  gMapMarkers[i].getMap() != null &&
                fUNQ183(dataLines[markerM.idx][mObject.lat], dataLines[markerM.idx][mObject.lng],dataLines[i][mObject.lat], dataLines[i][mObject.lng] ))   {
                samePosMarkers[samePosMarkers.length]  =  gMapMarkers[i].idx;
            }

        }
        if(samePosMarkers.length > 0) {
            samePosMarkers.unshift(markerM.idx);

             currentPageMarkerNum = 1;
             nextPageMarkerNum = 1 + ITEMS_PER_PAGE;
             previousPageMarkerNum = 1;

        }

        // set the messageback to what it was if it changed.
        if(showDirections || samePosMarkers.length > 0) {
            infowindow.setContent(message);
        }

        ignorePagingEvent = false;

        openMarker = markerM;
        infowindow.open(gMap, markerM);
        openWindow = infowindow;

        // set the address for the direction text box
        fUNQ137(markerM);

        if(editMap || samePosMarkers.length > 0  || showDirections) {
            google.maps.event.addListenerOnce(infowindow, 'domready', function () {

                //jQuery code here

                if(samePosMarkers.length > 0 && !ignorePagingEvent) {
                    fUNQ149() ;
                }

               if(showDirections) {

                    fUNQ153(markerM, openWindow) ;
                }

                if(editMap) {


                    fUNQ146(markerM, openWindow)    ;
                }   //   end  if(editMap)
            });

        } // end  if(editMap || samePosMarkers.length > 0
    });



    google.maps.event.addListener(infowindow, "closeclick", function () {
        if (openWindow == infowindow) {
            openWindow = null;
        }
    });


}

function fUNQ146(markerM , infowindow) {

    $('#removeMarker').click(function () {

        // confirmation that the user wants to remove the marker.


        var confRes = confirm("Remove the marker?");


        if(confRes == false)
            return;


        if(samePosMarkers.length > 0) {
            markerM =  gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;

        }

        infowindow.close();
        markerM.setVisible(false); // to do, should remove the marker from other places as well

        markerM.setMap(null);

        removedMarkers.push(markerM.idx);
        dataLines[markerM.idx].length = 0;

        gMapMarkers[markerM.idx] = null;

    });

}


function fUNQ147() {

    openMarker =   gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;
    var markerTemp = gMapMarkers[samePosMarkers[currentPageMarkerNum - 1]]   ;

   // var message = fUNQ158(mObject.headerDisplayOrderIdxs, dataLines[markerTemp.idx], mObject.columnHeaderArray);

    var message = fUNQ158(dataLines[markerTemp.idx]);

    message = '<div id="markerDiv" class="markerDescriptionReg">' + message + '</div>.';

   // TO DO: look at adjusting the top on parent div to 26 pixels (should look at other browsers for this as well!)
 //   message = '<div id="markerDiv" style="width: 450px; font-size:10pt; top: 26px; font-family:arial; font-weight:bold;">' + message ;

    if(editMap) {

        message = message + '<a id="removeMarker">Remove Pin</a> ' ;
        // removed the javascript:void0); from the href=""
        // the removal works.

        // TODO: may need to do something to support the call to remove markers when paging (like for handle directions)
        // may need to add something to handle teh
    }

  //  message = message + '</div>';
  //  $('#markerDiv').html(message);
    ignorePagingEvent = true;
    openWindow.setContent(message);

    fUNQ153(openMarker, openWindow) ;


}


function fUNQ148() {

    var pagingMarker = $('#markerPaging');
    if(pagingMarker.length > 0 ){
        pagingMarker.remove();
    }
}

function fUNQ149() {

    var pagingDiv = $('#markerDiv').parent().parent().parent();
    var pagingMarker = $('#markerPaging');

    var pageDisplay =            fUNQ152();
    var pageHtml = '<div id="markerPaging" class="pagination marker-pagination-centered">' + pageDisplay +
        '</div>';


    if(pagingMarker.length > 0 ){

        pagingMarker.html(pageDisplay);
    }
    else {
        pagingDiv.prepend(pageHtml);
    }

    fUNQ150() ;


}

function fUNQ150() {


    $('#markerPaging li').click ( function() {
        var elementId = $(this).attr('id');

        if( $(this).text() != currentPageMarkerNum) {

            $('#markerPaging li').unbind('click');

            fUNQ151(elementId, $(this).text());
        }
    } );

}

function fUNQ151(markerId, markerNumber) {

    if(markerId == "pgPrevLI") {
        currentPageMarkerNum = previousPageMarkerNum;

        nextPageMarkerNum = currentPageMarkerNum + 1;
    }

    else if(markerId == "pgNextLI") {
        currentPageMarkerNum = nextPageMarkerNum;

        previousPageMarkerNum = currentPageMarkerNum -1;
    }
    else {
        currentPageMarkerNum = markerNumber;
    }

    fUNQ147();

    $('#markerPaging').html(fUNQ152());

    fUNQ150() ;
}

function fUNQ152() {

    var lis = "";
    var endLis = "";

    if(samePosMarkers.length > ITEMS_PER_PAGE && currentPageMarkerNum > ITEMS_PER_PAGE) {
        lis = '<li id="pgPrevLI">&lt;</li>';
    }

    if(samePosMarkers.length > ITEMS_PER_PAGE && nextPageMarkerNum > currentPageMarkerNum ) {
        endLis = '<li id="pgNextLI">&gt;</li>';
    }

    var startingMarker = ITEMS_PER_PAGE * Math.floor( (currentPageMarkerNum -1) / ITEMS_PER_PAGE);

    for (var i = startingMarker; i < startingMarker + ITEMS_PER_PAGE && i < samePosMarkers.length; i++)
    {

        var displayNumber = i + 1;

        if(displayNumber  == currentPageMarkerNum) {
            lis = lis + '<li id="pgli' + displayNumber + '" class="active">'+ displayNumber  +'</li>'     ;
        }
        else {
            lis = lis + '<li id="pgli' + displayNumber + '">' + displayNumber  +'</li>';
        }

    }

    lis = lis + endLis ;
    return '<ul>' + lis + '</ul>';
}

function fUNQ153 (markerM, infoW) {

   // var startMarkerExists = true;
    /*

     from_htmls[i] = html + '<br>Directions: <a href="javascript:tohere(' + i + ')">To here<\/a> - <b>From here<\/b>' +
     '<br>End address:<form action="javascript:getDirections()">' +
     '<input type="text" SIZE=40 MAXLENGTH=40 name="daddr" id="daddr" value="" /><br>' +
     '<INPUT value="Get Directions" TYPE="SUBMIT"><br>' +
     'Walk <input type="checkbox" name="walk" id="walk" /> &nbsp; Avoid Highways <input type="checkbox" name="highways" id="highways" />' +
     '<input type="hidden" id="saddr" value="'+name+"@"+ point.lat() + ',' + point.lng() +
     '"/>';

     */


    $('#toDir').click( function(){


        // handle the directions in the more options window
        if (!mobileDevice && showMoreOptions) {

            fUNQ136(openMarker);

            return;
        }



        var description = fUNQ154();

    ignorePagingEvent = true;
    //   infoW.close();
    // openDirectionWindow(markerM, desc)      ;
        fUNQ148();
    infoW.setContent(description);
    fUNQ155(openMarker, infoW);

    }    );


}

function fUNQ154()
{

    var markerM = openMarker;


    var startLocation = "Here";

    var markerAddr = fUNQ162(dataLines[markerM.idx], " ", true);

    if(markerAddr.length > 0)
        startLocation = markerAddr;
    else if (fUNQ178(mObject.title) && dataLines[markerM.idx][mObject.title] != "")
    {
        startLocation =  dataLines[markerM.idx][mObject.title];
    }

    var description = '<div id="directions"><table>' +
        '<tr>'    +
        '<td><label>Start</label></td>  ' +
        ' <td><input type="text" SIZE=30 MAXLENGTH=200 name="startAddr" id="startAddr" value="' + startLocation + '" readonly />  ' +
        ' <INPUT type="hidden" id="markerStart" value="' + markerM.idx + '" /></td> ' +
        '<td rowspan="2"><img src="/img/reverse_img.png" Title="Get Reverse Directions" onclick="fUNQ159();"></td> ' +
        '</tr> ' +
        '<tr>' +
        '<td align="right"><label>End</label></td>' +
        '<td><input type="text" SIZE=30 MAXLENGTH=200 name="endAddr" id="endAddr" value="" />' +
        '   <INPUT type="hidden" id="markerEnd" value="" /></td>' +
        '</tr>' +
        ' <tr>' +
        '     <td colspan="2" align="right"> <INPUT id="directionSubmit" value="Get Directions" TYPE="SUBMIT" /></td><td></td>' +
        ' </tr>' +
        '</table>' +
        '<div id="dirError"></div></div>' ;

    return description;

}

function fUNQ155(markerM, infoW)    {


    $('#directionSubmit').click( function(){


        if( directionsService == null )
            directionsService = new google.maps.DirectionsService();

        if( directionsDisplay == null )           {
            directionsDisplay = new google.maps.DirectionsRenderer({suppressMarkers: true});
            directionsDisplay.setMap(gMap);

        }

        var start = "";
        var end = "";
        var markerStartSelector = $('#markerStart');
        var markerEndSelector =   $('#markerEnd');


        if(markerStartSelector.length > 0 && markerStartSelector.val() && parseInt(markerStartSelector.val(), 10) == markerM.idx ) {
            start =    markerM.getPosition();
            end =         $('#endAddr').val();

        }
        else if(markerEndSelector.length > 0 && markerEndSelector.val() && parseInt(markerEndSelector.val(), 10) == markerM.idx ) {
            start =     $('#startAddr').val();
            end =       markerM.getPosition();

        }

        if(start && end) {

            var request = {
                origin:start,
                destination:end,
                travelMode: google.maps.TravelMode.DRIVING
            };

            directionsService.route(request, function(result, status) {
                if (status == google.maps.DirectionsStatus.OK) {
                    infoW.close();
                    openWindow = null;
                   // fUNQ156( result, status, startMarkerExists,markerM );
                   directionsDisplay.setDirections(result);
                }
                else {
                    ignorePagingEvent = true;
                    $('#directions').html('Could not get directions: ' + status);
                }
            });

        }

    }  );
}

/*
function fUNQ156(response, status, startMarkerExists, markerM) {

    var bounds = new google.maps.LatLngBounds();
    var route = response.routes[0];
 //   var summaryPanel = document.getElementById("directions_panel");
 //   var detailsPanel = document.getElementById("direction_details");
    startLocation = new Object();
    endLocation = new Object();

    var polyline = new google.maps.Polyline({
        path: []
    });

    var path = response.routes[0].overview_path;
    var legs = response.routes[0].legs;
    for (i=0;i<legs.length;i++) {
        if (i == 0  && !startMarkerExists) {
            startLocation.latlng = legs[i].start_location;
            startLocation.address = legs[i].start_address;
       //     startLocation.marker = createMarker(legs[i].start_location,"start",legs[i].start_address,"green");
        }
        endLocation.latlng = legs[i].end_location;
        endLocation.address = legs[i].end_address;


        var steps = legs[i].steps;
        for (j=0;j<steps.length;j++) {
            var nextSegment = steps[j].path;
//            detailsPanel.innerHTML += "<li>"+steps[j].instructions;
//            var dist_dur = "";
//            if (steps[j].distance && steps[j].distance.text) dist_dur += "&nbsp;"+steps[j].distance.text;
//            if (steps[j].duration && steps[j].duration.text) dist_dur += "&nbsp;"+steps[j].duration.text;
//            if (dist_dur != "") {
//                detailsPanel.innerHTML += "("+dist_dur+")<br /></li>";
//            } else {
//                detailsPanel.innerHTML += "</li>";
//
//            }

            for (k=0;k<nextSegment.length;k++) {
                polyline.getPath().push(nextSegment[k]);
                bounds.extend(nextSegment[k]);



            }
        }
    }

    polyline.setMap(gMap);
    gMap.fitBounds(bounds);
    if(!startMarkerExists) {
        // TODO: do something with this!!!
      //  endLocation.marker = createMarker(endLocation.latlng,"end",endLocation.address,"red");
    }

}
*/

function fUNQ157(dataItem) {


    var distanceDisplay = '';

    if(showMoreOptions) {
        distanceDisplay = ' <span class="noDistDisplay">&nbsp; (##dist##)</span>'
    }

    var title = "";
    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

            title = '<div><b>' + dataItem[mObject.title]+  distanceDisplay +  '</b></div>';

    }

    if(title.length > 0)
        distanceDisplay = '';

    var address = fUNQ162(dataItem, distanceDisplay + "<br>", true);


    if(address != "") {
        if(title.length == 0)
        {
            address = '<b>'+address + '</b>';
        }

            address    = '<div>' + address +   '</div>';
    }


    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {

                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;

                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }

            }
        }

    }


    var firstHalf = title + address + descDisplay;

    firstHalf += fUNQ29(dataItem, title)  ;

    return firstHalf;
}

function fUNQ158(dataItem) {

    var title = "";
    if(fUNQ178(mObject.title) && dataItem[mObject.title] != "")   {

        if(fUNQ178(mObject.web)  && dataItem[mObject.web] != "")  {
            title = '<div><a href="'+urlizeUrl(dataItem[mObject.web])+ '" target="_blank">'+ dataItem[mObject.title] + '</a></div>';
        }
        else
            title = dataItem[mObject.title];

    }
    var address = fUNQ162(dataItem, "<br>", true);

    if(address != "") {

        if(showDirections) {
            address    = '<div><a id="toDir" >' + address +   '</a></div>';
        }
        else {
        address    = '<div>' + address +   '</div>';

        }
    }
    else if(showDirections) {
        address = '<div><a id="toDir" >Directions</a></div>';
    }

    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {


                gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div class="markerLabelDiv"><span class="markerLabel">' + label + ': </span>'+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div class="markerLabelDiv">'+ gDataItem + '</div>' ;

                }
            }
        }

    }


    var firstHalf = title + address + descDisplay;


    firstHalf +=        fUNQ29(dataItem, title)  ;
    return firstHalf;
}




function fUNQ159() {

    var myDirs = $('#directions');

    if($this.length > 0) {

        var markerEndId = myDirs.find('#markerEnd');
        var markerStartId = myDirs.find('#markerStart');
        var startAddr = myDirs.find('#startAddr');
        var endAddr = myDirs.find('#endAddr');

        var tempEndId = "";
        var tempEndAddr = "";

        if(markerEndId.length > 0) {
            tempEndId = markerEndId.val();
        }
        if(endAddr.length > 0) {
            tempEndAddr = endAddr.val();
        }


        if(startAddr.prop("readonly"))
        {
            startAddr.prop("readonly",  false);
            endAddr.prop("readonly",  true);
        }
        else if(endAddr.prop("readonly")) {
            startAddr.prop("readonly",  true);
            endAddr.prop("readonly",  false);
        }



        markerEndId.val(markerStartId.val());
        endAddr.val(startAddr.val());

        markerStartId.val(tempEndId);
        startAddr.val(tempEndAddr);
    }

}



function fUNQ160(markerM, latIdx, lngIdx) {
  dataLines[markerM.idx][latIdx] = markerM.getPosition().lat().toFixed(6);
  dataLines[markerM.idx][lngIdx] = markerM.getPosition().lng().toFixed(6);

    fUNQ161();

}

function fUNQ161() {

   if( fUNQ65 (redrawTextArea) )
   {
       redrawTextArea() ;
   }

}

// do stuff with the address, city, state, zip
function fUNQ162(line, addrLineBreak, display) {


    var addr = fUNQ177(line, mObject.address, "", display) ,
        city =  fUNQ177(line, mObject.city, "", display) ,
        state =  fUNQ177(line, mObject.state, "", display) ,
        zip =    fUNQ177(line, mObject.zip, "", display) ,
        country = fUNQ177(line, mObject.country, "", display) ;


    // this holds line 2; addr holds line 1
    var retAddr ;

    retAddr = (city.length > 0) ? city : "";
    retAddr +=   ((city.length >  0 && state.length > 0 ) ? ", " + state : state );
    retAddr += ((retAddr.length > 0 && zip.length >  0) ? " " + zip : zip );
    retAddr += ((retAddr.length > 0 && country.length >  0) ? " " + country : country );


    if(addrLineBreak != undefined && addr.length > 0 && retAddr.length > 0)
        return addr + addrLineBreak + retAddr;

    if(addr.length > 0 && retAddr.length > 0)
        return addr + " " + retAddr;

    return (addr.length > 0 ? addr : retAddr);

}

function fUNQ163() {

    var groupDiv =  $('#groupChecksDiv');

    // don't do anything if there are not at least 2 groups
       if(mObject.sortedGroupKeys.length < 2)         {

           if(groupDiv.length > 0 ) {

               groupDiv.hide();
           }

           return;
       }


    var groupLabel = mObject.columnHeaderArray[ mObject.group] + ": " ;

    var allGroupBoxes = "";

    for(var groupName in mObject.groupImageHash)    {

        if(mObject.groupImageHash.hasOwnProperty(groupName))  {

            var imageIdx = parseInt( mObject.groupImageHash[groupName], 10);
            var imageUrl =   IMAGE_PATH +  SMALL_IMAGE +   IMG_LIST[imageIdx] +  IMG_FILE_ENDING;

            var imageIdxStr = imageIdx.toString();

            var toggleCheckBox = ' <li class="groupItem"><img src="'+ imageUrl +'"><input type="checkbox" id="groupToggle' + imageIdxStr+ '"  onclick="fUNQ170('+ imageIdxStr +');" CHECKED/><span class="middleGroupText">' + groupName +'</span></li>';

            allGroupBoxes = allGroupBoxes +  toggleCheckBox;

        }
    }

    allGroupBoxes = '<ul class="groupList"><li class="groupItem">' +  groupLabel + '</li> ' +  allGroupBoxes + '</ul>';



    if(groupDiv.length > 0 ) {
        groupDiv.html(allGroupBoxes);
        groupDiv.show();
    }

}


// This is called after a selected filter has changed.
//
// The basic idea is to get a 2-d array of items that can be displayed, take the array
// with the fewest items, put it in a hash and see what items are in every array by doing a count
// the items with the same count as the number of arrays get displayed, others get 'erased'
function fUNQ164() {


     // this will contain the idx's of the markers that get displayed
     var displayedMarkers = [];

     // first get the items displayed by the groups:
     var displayedGroupIdxs = [];

     var i;

     for( i = 0; i < mObject.sortedGroupKeys.length; i++) {
         var groupName = mObject.sortedGroupKeys[i];

         if(groupsOff.indexOf(i) < 0) {
             var markerIdxs = fUNQ47(groupName)  ;

             displayedGroupIdxs.push.apply(displayedGroupIdxs, markerIdxs)  ;
         }
     }

     var allSelectArrays = [];

     for( i = 0; i < selectedFilterValues.length; i++) {

         if(selectedFilterValues[i] && selectedFilterValues[i] != ALL_FILTER) {

             var tempArray = fUNQ44( mObject.filterListNames[i], selectedFilterValues[i])    ;

             if(tempArray.length > 0 ) {
                 allSelectArrays[allSelectArrays.length] =   tempArray;

             }
         }
     }


    if(allSelectArrays.length == 0 && mObject.sortedGroupKeys.length == 0)
    {
        // TODO: some optimization with the screen so markers can be seen
        for( i = 0; i < gMapMarkers.length;  i++) {

            if(gMapMarkers[i] == null )
                continue;

            if(fUNQ165(gMapMarkers[i]) ) {
                displayedMarkers.push(gMapMarkers[i].idx);

                fUNQ168(gMapMarkers[i]) ;
            }
            else {
                fUNQ169(gMapMarkers[i]);
            }
            //  if(!mObject.clustering && gMapMarkers[i].getMap() == null)
            //     gMapMarkers[i].setMap(gMap);
        }

         selectedMarkerSet = true;
         selectedMarkers =   displayedMarkers;

         // TODO: add an option for displaying dynamic filters and change this based on that value
         // TODO: test the line below:
        if(mObject.disAbleDynamicFilters == null || mObject.disAbleDynamicFilters == false)
         fUNQ166();

         fUNQ143(displayedMarkers);

         return;
     }


     if(mObject.sortedGroupKeys.length > 0)
         allSelectArrays[allSelectArrays.length] = displayedGroupIdxs;

     var smallestArray =  allSelectArrays[0];


     for( i = 0; i < allSelectArrays.length;  i++){

         if(allSelectArrays[i].length < smallestArray)
            smallestArray = allSelectArrays[i];
     }

     // now put the smallest array into a hash
     var uniqueMarkerIdxs = {};
     for( i = 0; i < smallestArray.length; i++) {
         uniqueMarkerIdxs[smallestArray[i].toString()] = 0;
     }

     // now count how many arrays match the items in the hash!
     for( i = 0; i < allSelectArrays.length; i++) {

         for(var j = 0; j< allSelectArrays[i].length; j++)  {

             if(uniqueMarkerIdxs.hasOwnProperty(allSelectArrays[i][j].toString()))    {
                 uniqueMarkerIdxs[allSelectArrays[i][j].toString()] = parseInt(uniqueMarkerIdxs[allSelectArrays[i][j].toString()], 10 )+ 1;
             }
         }
     }

     // remove the items that don't match all filters/groups
     for(var itemIdx in uniqueMarkerIdxs)      {
         if(uniqueMarkerIdxs[itemIdx] != allSelectArrays.length) {
             delete  uniqueMarkerIdxs[itemIdx];
         }
     }



     for( i = 0; i < gMapMarkers.length;  i++) {
         if(gMapMarkers[i] == null)
            continue;

         if(uniqueMarkerIdxs.hasOwnProperty(gMapMarkers[i].idx.toString()) && fUNQ165(gMapMarkers[i]))    {

             fUNQ168(gMapMarkers[i]);
             //gMapMarkers[i].setMap(gMap);
             displayedMarkers.push(gMapMarkers[i].idx)  ;

         }
         else {
             fUNQ169(gMapMarkers[i]) ;
             //gMapMarkers[i].setMap(null);
         }

     }

     //  take into account only displaying the items that are visible in the current map view & moving/zooming to items so they will
     // be visible if nothing is visible.
     // DONE: below!!!

     selectedMarkerSet = true;
     selectedMarkers =     displayedMarkers;

    // TODO: add an option for displaying dynamic filters and change this based on that value
    // TODO: test the line below:
    if(mObject.disAbleDynamicFilters == null || mObject.disAbleDynamicFilters == false) {
        fUNQ166();
    }


     fUNQ143(displayedMarkers);
 }


// return true if there is not a circle filter or there is a circle filter and it is in the circle
function fUNQ165(gMapMarker) {

    if(!circleFilter)
        return true;


    if(circle.getBounds().contains(gMapMarker.getPosition()) &&  gMapMarker.distanceM <= circleRadius ) {

        return true;
    }

    return false;

}

// can exclude items from other filters, but not from the selected one
function fUNQ166() {

    for(var i = 0; i <  mObject.filterListNames.length; i++) {

        var allSelectArrays = [];

        for( var j = 0; j < selectedFilterValues.length; j++ )
        {
            if(j == i || (selectedFilterValues[j] && selectedFilterValues[j] == ALL_FILTER)) {
                continue;
            }

            var tempArray = fUNQ44( mObject.filterListNames[j], selectedFilterValues[j])    ;

            if(tempArray.length > 0 ) {
              //  allSelectArrays.push.apply(allSelectArrays, tempArray);

                if(allSelectArrays.length == 0)
                    allSelectArrays.push.apply(allSelectArrays, tempArray);
                else
                    allSelectArrays = fUNQ68(allSelectArrays, tempArray) ;

            }

        }

        fUNQ167(i,  allSelectArrays, selectedFilterValues[i]);

    }

}

function fUNQ167(filterIdx,  allAvailableValues, selectedValue) {


    var tempFilter = [];
    tempFilter.push(ALL_FILTER);


    var bucketKeys = mObject.filterListSortedKeyHash[mObject.filterListNames[filterIdx]];


    for(var i = 0; i < bucketKeys.length; i++)
    {
        var filterValIdxs =   fUNQ44( mObject.filterListNames[filterIdx], bucketKeys[i])    ;

        if( allAvailableValues.length == 0 || selectedValue ==  bucketKeys[i] ||  fUNQ66(filterValIdxs, allAvailableValues) )
        {

            tempFilter.push(bucketKeys[i]);
        }


    }

    fUNQ48(tempFilter, selectedValue, filterIdx.toString() +"_rfilter")

}


function fUNQ168(marker) {

    if(!mObject.clustering && marker.getMap() == null)
        marker.setMap(gMap);

}

function fUNQ169(marker) {

    if(!mObject.clustering && marker.getMap() != null)
        marker.setMap(null);
}

// have the option to either:
// 1) display this group and none of the others
// 2) turn this group on/off
function fUNQ170(groupId) {

    var groupIdAsInt = parseInt(groupId, 10)    ;

    // if set to true, only show one group
    // if set to false turn on/off individual groups
  //  var oneGroup = true;
    var oneGroup = false;
    var offGroupIdx = groupsOff.indexOf(groupId);

    if(offGroupIdx > -1 )      {


        if(oneGroup) {
            groupsOff.length = 0;
                 // show all groups
            fUNQ164();
        }
        else {
            // show this group again
            groupsOff.splice(offGroupIdx, 1)    ;
          //  fUNQ172(groupIdAsInt, true);
            fUNQ164();
        }

    }
    else {
        if(oneGroup) {
            groupsOff =  mObject.sortedGroupKeys;
            groupsOff.splice(offGroupIdx, 1)    ;
            fUNQ164();
            // show only this group

         //   fUNQ171(false);
         //   fUNQ172(groupIdAsInt, true);
         //   fUNQ164();
        }
        else {
            groupsOff[groupsOff.length] = groupIdAsInt;

            // hide this group
          //  fUNQ172(groupIdAsInt, false);
            fUNQ164();
        }

    }

}

   // This really isn't used, but if it were, it would need to be fixed to work with clustering and filtering.
function fUNQ171(turnOn) {
    for(var i = 0;  i< gMapMarkers.length ; i++)  {

        if( gMapMarkers [i] != null   ) {

            if(turnOn) {
                fUNQ168(gMapMarkers [i]);
            }
            else {
                fUNQ169(gMapMarkers);
            }
        }
    }
}

// display selected markers should take care of everything this does
/*
// TODO: need to take into account whether or not the groups are in the current view
function fUNQ172(groupIdx, turnOn) {

    var groupName = mObject.sortedGroupKeys[groupIdx];

    var markerIdxs = fUNQ47(groupName)  ;


       for(var i = 0; i < markerIdxs.length; i++)      {
          if( markerIdxs[i] < gMapMarkers.length && gMapMarkers [markerIdxs[i]] != null)  {

              if(turnOn)
                  gMapMarkers[markerIdxs[i]].setMap(gMap);
              else
                  gMapMarkers[markerIdxs[i]].setMap(null);
          }


       }

}
*/

// call this after a search to reset the filters and groups!
function fUNQ173 () {
    fUNQ174();

    fUNQ175();
}

// checks all the groups
function fUNQ174() {


    var groupDiv =  $('#groupChecksDiv');

    if(groupDiv.length == 0)
        return;

    groupDiv.find(':checkbox').each(function(){

        $(this).prop('checked',true);

    });

    groupsOff.length = 0;
    //  $('#clusterCB').prop('checked', mObject.clustering );

}

// sets all the filters to 'All'
function fUNQ175() {

    var filterDiv =  $('#filtersDiv');

    if(filterDiv.length == 0)
        return;

    filterDiv.find('select option').each(function(){

        $(this).filter(function() {
            //may want to use $.trim in here
            return $(this).text() == ALL_FILTER;
        }).prop('selected', true);

    });

    for(var i = 0; i < selectedFilterValues.length; i++)
        selectedFilterValues[i] = ALL_FILTER;

    //  $('#clusterCB').prop('checked', mObject.clustering );

}


function fUNQ176() {

    return (fUNQ178(mObject.address) || fUNQ178( mObject.city) || fUNQ178(mObject.state) ||
        fUNQ178(mObject.zip) || fUNQ178(mObject.country) );


}

 // gets a data item from the line
function fUNQ177(line, mObjField, defaultVal, display) {

    if(display == false || fUNQ178(mObjField) == false )
        return defaultVal;

   return (( mObjField != null && (mObjField < line.length  && mObjField > -1) && line[mObjField].trim() != ""  ) ? line[mObjField].trim() : defaultVal );
}

function fUNQ178(mObjField) {

    var num = parseInt(mObjField, 10) ;


    return  ( mObjField != null &&  mObject.headerDisplayOrderIdxs.indexOf( num) > -1 );

}

// This is for when there are not any markers to display
function fUNQ179() {

    var windowData = $("#mapWindowData");

    if(windowData.length == 0 || inIframe)
        return;

    windowData.html("");

    fUNQ181(undefined, 0)   ;
}

//
function fUNQ180(pageNumber) {

    var windowData = $("#mapWindowData");

    if(windowData.length == 0 || inIframe)
        return;


    // will likely need to do some paging

    var allRows = "";
    var startPageIdx = 0;
    var i, markerIdx;

    if(pageNumber != undefined) {
            startPageIdx = (pageNumber -1 ) * DISPLAYABLE_ITEMS_PER_PAGE;

    }

    var tempMessage = '';

    if(selectedMarkers.length > 0 || selectedMarkerSet) {

        if(showMoreOptions && showDistance) {

            selectedMarkers.sort(function (a, b) {

                return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
            });

        }

        for( i = startPageIdx; i< selectedMarkers.length &&  selectedMarkers[i] < markerDescriptions.length && i < startPageIdx + DISPLAYABLE_ITEMS_PER_PAGE; i++) {

             markerIdx =  markerDescriptions[selectedMarkers[i]].markerIdx;

            // if adding a right div, put it directly under the windowRowLeft and have it float right

            allRows +=  '<div class="windowRowRight" onclick="fUNQ182(' + markerIdx.toString() + ')">' + (i +1).toString() + '</div>';

            //TODO: add code similar to below for showing the distance (or put a div next to the first line in the message and
            // do some stuff to search replace (also the message will have to be copied)
            // to add distance: allRows+= <div style="float:right;" class="showDistance">(25 miles)</div>

            tempMessage = markerDescriptions[selectedMarkers[i]].message;

            if(showMoreOptions && showDistance) {
                tempMessage = tempMessage.replace("noDistDisplay", "distDisplay").replace("##dist##", gMapMarkers[markerIdx].displayDistance );
            }

            allRows +=       '<div id="m' + markerIdx.toString() + '" class="windowRowLeft" onclick="fUNQ182(' + markerIdx.toString() + ')">' +tempMessage + '</div>';


        }


        // setup paging:
        fUNQ181(pageNumber, selectedMarkers.length)   ;

    }
    else {

        // TODO: copy the array, then sort it by distance
        var simpleSelected = [];
        for(var m = 0; m < markerDescriptions.length; m++)
        {
            simpleSelected[m] = m;
        }
        if(showMoreOptions && showDistance) {
            simpleSelected.sort(function (a, b) {

            return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
            });
        }


        /*  if(showMoreOptions && showDistance) {

              selectedMarkers.sort(function (a, b) {

                  return gMapMarkers[markerDescriptions[a].markerIdx].distanceM - gMapMarkers[markerDescriptions[b].markerIdx].distanceM ;
              });

          }
          */
        for( i = startPageIdx; i < simpleSelected.length && i < startPageIdx + DISPLAYABLE_ITEMS_PER_PAGE; i++) {

             markerIdx =  markerDescriptions[simpleSelected[i]].markerIdx;

            // if adding a right div, put it directly under the windowRowLeft and have it float right
            allRows +=  '<div class="windowRowRight" onclick="fUNQ182(' + markerIdx.toString() + ')">' + (i +1).toString() + '</div>';

            tempMessage = markerDescriptions[simpleSelected[i]].message;

            if(showMoreOptions && showDistance) {
                tempMessage = tempMessage.replace("noDistDisplay", "distDisplay").replace("##dist##", gMapMarkers[markerIdx].displayDistance );
            }

            allRows +=       '<div id="m' + markerIdx.toString() + '" class="windowRowLeft" onclick="fUNQ182(' + markerIdx.toString() + ')">' + tempMessage + '</div>';


        }

        // setup paging:
        fUNQ181(pageNumber, markerDescriptions.length)   ;

    }
    windowData.html(allRows);

}


function fUNQ181(pageNumber, itemCount) {

    // setup paging:
    // paging is showing
    if(pageNumber != undefined) {

        if(itemCount < DISPLAYABLE_ITEMS_PER_PAGE)
        {
            $('#compact-pagination').pagination('destroy');
        }

    }
    else { // paging is not showing

        if(itemCount > DISPLAYABLE_ITEMS_PER_PAGE)  {
            $('#compact-pagination').pagination({
                items: itemCount,
                itemsOnPage:   DISPLAYABLE_ITEMS_PER_PAGE,
                cssStyle: 'compact-theme',
                displayedPages: 7,
                onPageClick: changePage
            });
        }
        else if(gMapMarkers.length > DISPLAYABLE_ITEMS_PER_PAGE){
            // hide paging if it is showing
            $('#compact-pagination').pagination('destroy');
        }

    }


}

function changePage(pageNumber) {
    fUNQ180(pageNumber) ;

}

function fUNQ182(idx) {

    // trigger the info window to be opened for idx

    if(gMapMarkers[idx] == null)
        return;

    if(gMapMarkers[idx].getMap() == null)
    {
        gMapMarkers[idx].setMap(gMap);
    }

        if(gMap.getZoom() < CLUSTER_ZOOM_LEVEL) {
            gMap.setZoom(CLUSTER_ZOOM_LEVEL);
        }


    google.maps.event.trigger(gMapMarkers[idx], "click");


}


// .00011 is around 40 feet; an average block is close to 250 feet.
// for a small lot (1600 sqft), the markers would be on the same spot.
// one issue with this is a point can be 2 close to 2 points at opposite ends (such as being in the middle of a 50 foot straight line)
function fUNQ183(lat1,lon1,lat2,lon2) {

  if(lat1 == lat2 && lon1 == lon2)
    return true;

  if(Math.abs(lat1-lat2) <= .0001 && Math.abs(lon1 - lon2) <= .0001)
  {

    return ( Math.sqrt(  (Math.pow(lat1 - lat2, 2) + Math.pow(lon1 - lon2, 2) ) ) < .00011 )
  }

  return false;

}

// Returns a straight line type of distance
function fUNQ184(lat1,lon1,lat2,lon2)
{
    if(lat1 == lat2 && lon1 == lon2)
        return 0;

    return  Math.sqrt(  (Math.pow(lat1 - lat2, 2) + Math.pow(lon1 - lon2, 2) ) );
}

function fUNQ185(lat1,lon1,lat2,lon2) {
  var R = 6371; // Radius of the earth in km
  var mileR = 3959; // radius of the earth in miles
  var dLat = fUNQ186(lat2-lat1);  // fUNQ186 below
  var dLon = fUNQ186(lon2-lon1); 
  var a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(fUNQ186(lat1)) * Math.cos(fUNQ186(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2)
    ; 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return d = R * c; // Distance in km

}

function fUNQ186(deg) {
  return deg * (Math.PI/180)
}


function fUNQ187(lat, lng) {

    if ($.isNumeric(lat) && $.isNumeric(lng)  ) {

        return (Math.abs(lat) <= 90 && Math.abs(lng) <= 180) ;

    }
    return false;
}

function fUNQ188() {

    // use all the components of the address, header information, email address, title
    // don't use image or website urls



    for(var i = 0; i < dataLines.length; i++) {

        if(dataLines[i] == null || dataLines[i].length == 0 )
            continue;

        for(var j = 0; j < mObject.headerDisplayOrderIdxs.length && mObject.headerDisplayOrderIdxs[j] < dataLines[i].length; j++) {

            if(!isIgnoreSearchColumn(j) &&  dataLines[i][mObject.headerDisplayOrderIdxs[j]].length > 0)
            {
                var key = dataLines[i][mObject.headerDisplayOrderIdxs[j] ] ;
                if (searchTermHash.hasOwnProperty(dataLines[i][mObject.headerDisplayOrderIdxs[j]])) {
                    searchTermHash[key].push(i);
                }
                else {
                    var bucketLineIndex = [];

                    bucketLineIndex.push(i);
                    searchTermHash[key] = bucketLineIndex;
                }

            }

        }
    }


}



function fUNQ189 () {


    var searchBoxDiv = $("#searchBox" )      ;

    if(searchBoxDiv.length == 0)
        return ;

    fUNQ188();

    var availableTerms = fUNQ196(searchTermHash);

    //  set the available tags to the search terms
    searchBoxDiv.autocomplete({
        source: availableTerms,
        minLength: 3,

        select: function(event, ui) {

            fUNQ191( ui.item.value );
        }

    });

    // TODO: this might be wrong, but should work with the ipad
    if( mobileDevice || tabletDevice )         {

        $('#searchBox').blur  (function() {

            fUNQ190();

        }  );
    }

}



function fUNQ190() {

 //  alert("running search: " + $('#searchBox').val() );

    fUNQ191(  $('#searchBox').val() );
}

function handleSearchSubmit(e) {
    if (e.keyCode == 13) {

        fUNQ191(  $('#searchBox').val() );
        return false;

    }
}

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};



function fUNQ191(searchTerm) {

    if(searchTerm.trim().length == 0)
        return;

    //alert(Object.size(searchTermHash));

    if (searchTermHash.hasOwnProperty( searchTerm )) {

         var idxs =    searchTermHash[searchTerm];
        fUNQ192(idxs);
    }
    else {
        // try to geocode the value

        fUNQ193(searchTerm, mObject.regionCode, geoResultCallbackSearchBox);
    }

}


function fUNQ192(displayIdxs) {

    var uniqueMarkerIdxs = [], i;

    for( i = 0; i < displayIdxs.length; i++) {
        uniqueMarkerIdxs[displayIdxs[i]] = 1;
    }

    for( i = 0; i < gMapMarkers.length;  i++) {

        if(gMapMarkers[i] == null)
            continue;

        if(uniqueMarkerIdxs.hasOwnProperty(gMapMarkers[i].idx))     {
            gMapMarkers[i].setMap(gMap);
        }
        else {
            gMapMarkers[i].setMap(null);
        }

    }
    selectedMarkerSet = true;
    selectedMarkers =   displayIdxs;
    fUNQ173();

    fUNQ143(displayIdxs);

}

function fUNQ193(address, country, callback) {

    //var address = generateAddress(locObject);



    if (address.length == 0) {

        return;
    }



    if(mapGeocoder == null)
        mapGeocoder = new google.maps.Geocoder();


    if(country != undefined && country.length > 0) {
      //  alert("calling the geo-coder1: " + address);
        mapGeocoder.geocode({
            'address': address,
            'region': country
        }, function (results, status) {

            callback(results, status);
        });

    }
    else {

        mapGeocoder.geocode({
            'address': address
        }, function (results, status) {

            callback(results, status);
        });

    }

}


function fUNQ194(resultArr, status) {
   // alert("geo-coder results: " + status.toString());
    if (status == google.maps.GeocoderStatus.OK) {


        //locObject.lat = resultArr[0].geometry.location.lat();
        //locObject.long = resultArr[0].geometry.location.lng();

      /*  if (resultArr[0].partial_match != null) {
        }*/

        fUNQ195(resultArr[0].geometry.location.lat().toFixed(6), resultArr[0].geometry.location.lng().toFixed(6));

    }
    /*
    else if (status == google.maps.GeocoderStatus.ZERO_RESULTS) {
    } else if (status == google.maps.GeocoderStatus.REQUEST_DENIED) {
    } else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
    } else if (status == google.maps.GeocoderStatus.INVALID_REQUEST) {
    } else if (status == google.maps.GeocoderStatus.UNKNOWN_ERROR) {
    }
                      */



    /*

     if (status == google.maps.GeocoderStatus.OK) {
     map.setCenter(results[0].geometry.location);
     var marker = new google.maps.Marker({
     map: map,
     position: results[0].geometry.location
     });
     */


}

function fUNQ195(lat, lng) {


    var currentDistance = 10000;
    var currentMarkerIdx = -1;

    for(var i = 0; i < gMapMarkers.length; i++)  {
        if(gMapMarkers[i] != null)       {
            var markerDistance = fUNQ184(lat, lng, gMapMarkers[i].getPosition().lat().toFixed(6), gMapMarkers[i].getPosition().lng().toFixed(6))   ;

            if(markerDistance < currentDistance)   {

                currentDistance = markerDistance;
                currentMarkerIdx = i;
            }

        }
    }


    if(currentMarkerIdx >= 0) {

        gMapMarkers[currentMarkerIdx].setMap(gMap);
        // TODO: verify the zoom levels are good      ; possibly hide the other markers

        var zoomLevel = gMap.getZoom();

        if(zoomLevel < 12)
            zoomLevel = 14;
        else if(zoomLevel < 16)
            zoomLevel = 15;

        gMap.panTo(gMapMarkers[currentMarkerIdx].getPosition())   ;
        gMap.setZoom(zoomLevel);

        // TODO: don't show the other items!

    }

}



function fUNQ196(termsHash) {

    var termList = [];
    for(var item in termsHash)   {

        termList.push(item);
    }

    termList.sort();

    return termList;
}

function fUNQ197() {

       var i;
    var kml = '<?xml version="1.0" ?>'      ;
    kml += '<kml xmlns="http://www.opengis.net/kml/2.2">';


    // validates against xsd!

    kml += '<Document>\n'  ;

    if(userSettings.title != null && userSettings.title.length > 0)  {
        kml += '<name><![CDATA[' + userSettings.title + ']]></name>\n';
    }
    else {
        kml += '<name><![CDATA[ Auto-generated KML by EasyMapMaker ]]></name>\n';
    }

    if(userSettings.description != null && userSettings.description.length > 0)  {
        kml += '<description><![CDATA[' + userSettings.description + ']]></description>\n';
    }
    else {
        kml += '<description><![CDATA[ Auto-generated KML by EasyMapMaker ]></description>\n';

    }


    // generate the styles:

    /*
     <Style id="downArrowIcon">
     <IconStyle>
     <Icon>
     <href>http://maps.google.com/mapfiles/kml/pal4/icon28.png</href>
     </Icon>
     </IconStyle>
     </Style>      */

    //IMG_LIST[mObject.markerImageIdx[i]]


    var balloonStyle = '<BalloonStyle><text><![CDATA[';

    if(fUNQ178(mObject.title))
    {
        balloonStyle += '<b>$[name]</b><br /> '     ;
    }
    if(fUNQ176()) {
        balloonStyle += '$[address]<br /> '     ;
    }
    balloonStyle +=    '$[description]<br/>$[geDirections] ';
    balloonStyle +=     ']]></text></BalloonStyle>';

    var multipleImages = false;
    var singleImg =     IMG_LIST[0] ;
    if( mObject.markerImageIdx.length > 0 ) {

        for( i = 0; i < IMG_LIST.length; i++)
        {
            kml += '<Style id="' + IMG_LIST[i] +  '">' +
                '<IconStyle>'   +
                '<scale>1</scale> ' +
                '<Icon> '     +
                '<href>' + BASE_IMAGE_URL + IMAGE_PATH + IMG_LIST[i] + IMG_FILE_ENDING + '</href>'        +
                '</Icon>'     +
                ' <hotSpot x="0.5"  y="0.5"  xunits="fraction" yunits="fraction"/> '  +
                '</IconStyle>'     +
                balloonStyle +
                '</Style>\n';

        }
        multipleImages = true;

    }
    else {
        kml += '<Style id="' + IMG_LIST[0] +  '">' +
            '<IconStyle>'   +
            '<scale>1</scale> ' +
            '<Icon> '     +
            '<href>' + IMAGE_PATH + IMG_LIST[0] + IMG_FILE_ENDING + '</href>'        +
            '</Icon>'     +
            ' <hotSpot x="0.5"  y="0.5"  xunits="fraction" yunits="fraction"/> '  +
            '</IconStyle>'     +
            balloonStyle +
            '</Style>\n';
    }


    for( i = 0; i < dataLines.length && i < gMapMarkers.length; i++)           {

        if(gMapMarkers[i] == null)
            continue;

        var title = "";
        if(fUNQ178(mObject.title) && dataLines[i][mObject.title] != "")   {
            title = dataLines[i][mObject.title]  ;
        }
        var address= fUNQ162(dataLines[i], " ",  true);
        var desc =   fUNQ198(dataLines[i]);



        kml += '<Placemark>' ;
        //<![CDATA[ ]]>
        if(title.length > 0)
            kml += '<name><![CDATA[' + title + ']]></name>\n';

        if(address.length > 0)
            kml += '<address><![CDATA[' + address + ']]></address>\n';

        if(desc.length > 0)
            kml += '<description><![CDATA[' + desc + ']]></description>\n';


        var styleImg = singleImg;

        if(    multipleImages      )
            styleImg =   gMapMarkers[i].color;

        kml +=  '<styleUrl>#' + styleImg +'</styleUrl>\n';

        var lngLat = gMapMarkers[i].getPosition().lng().toFixed(6).toString() + ',' +   gMapMarkers[i].getPosition().lat().toFixed(6).toString()   ;

        kml +=  '<Point> '    +
            '<coordinates>' +lngLat + ',0</coordinates>\n'  +
            '</Point> \n' ;


        kml += '</Placemark>\n';

    }

    kml += '</Document>\n'   ;
    kml += '</kml>'    ;


    return kml;

}



function fUNQ198(dataItem) {

    var descDisplay = "";

    for(var i = 0; i < mObject.headerDisplayOrderIdxs.length; i++) {

        if(!isSelectedColumn(mObject.headerDisplayOrderIdxs[i])) {
            var gDataItem = dataItem[mObject.headerDisplayOrderIdxs[i]];
            var label = mObject.columnHeaderArray[mObject.headerDisplayOrderIdxs[i]];



            if(gDataItem.trim() != "") {

                 gDataItem = gDataItem.replace(/^((https?|ftp):\/\/[^\<]+)$/gim, '<a href="$1" target="_blank">$1</a>');

                if(mObject.showLabels)
                    descDisplay = descDisplay +  '<div>' + label + ': '+ gDataItem + '</div>' ;
                else {
                    descDisplay = descDisplay +  '<div>'+ gDataItem + '</div>' ;

                }
            }
        }

    }

    var siteImage =  "";
    if(fUNQ178(mObject.image) && dataItem[mObject.image] != "")  {
        siteImage = '<img src="' + dataItem[mObject.image] + '"/>';
    }

    var email = "";
    if(fUNQ178(mObject.email) && dataItem[mObject.email] != "") {
        email = 'e-mail: <a href="mailto:' + dataItem[mObject.email] + '">' +   dataItem[mObject.email] + '</a>';

    }
    var website = "";
    if(fUNQ178(mObject.web) && dataItem[mObject.web] != "")  {
        website = '<a href="' + urlizeUrl(dataItem[mObject.web]) + '" target="_blank">' +   dataItem[mObject.web] + '</a>';
    }

    var firstHalf = descDisplay;

    firstHalf = firstHalf + siteImage ;
    firstHalf = firstHalf +   email ;
    firstHalf = firstHalf +  website;
    return firstHalf;


}


function myCalculator(markers, numStyles) {
    var index = 0;
    var title = "";
    var count = markers.length.toString();

    var dv = count;
    while (dv !== 0) {
        dv = parseInt(dv / 3, 10);
        index++;
    }

    index = Math.min(index, numStyles);
    return {
        text: count,
        index: index,
        title: title
    };
}


// good stuff:

/*

 google.maps.event.addListener(map, "rightclick", function(event) {
 var lat = event.latLng.lat();
 var lng = event.latLng.lng();
 // populate yor box/field with lat, lng
 alert("Lat=" + lat + "; Lng=" + lng);
 });

 */

// suppress markers on directions:

/*
 // Map and directions objects
 var map = new google.maps.Map( element, options );
 var service = new google.maps.DirectionsService();
 var directions = new google.maps.DirectionsRenderer({suppressMarkers: true});

 // Start/Finish icons
 var icons = {
 start: new google.maps.MarkerImage(
 // URL
 'start.png',
 // (width,height)
 new google.maps.Size( 44, 32 ),
 // The origin point (x,y)
 new google.maps.Point( 0, 0 ),
 // The anchor point (x,y)
 new google.maps.Point( 22, 32 )
 ),
 end: new google.maps.MarkerImage(
 // URL
 'end.png',
 // (width,height)
 new google.maps.Size( 44, 32 ),
 // The origin point (x,y)
 new google.maps.Point( 0, 0 ),
 // The anchor point (x,y)
 new google.maps.Point( 22, 32 )
 )
 };

 service.route( { origin: origin, destination: destination }, function( response, status ) {
 if ( status == google.maps.DirectionsStatus.OK ) {
 display.setDirections( response );
 var leg = response.routes[ 0 ].legs[ 0 ];
 makeMarker( leg.start_location, icons.start, "title" );
 makeMarker( leg.end_location, icons.end, 'title' );
 }
 });
 function makeMarker( position, icon, title ) {
 new google.maps.Marker({
 position: position,
 map: map,
 icon: icon,
 title: title
 });
 }
*/

